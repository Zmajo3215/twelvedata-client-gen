/*
Twelve Data API

## Overview  Welcome to Twelve Data developer docs — your gateway to comprehensive financial market data through a powerful and easy-to-use API. Twelve Data provides access to financial markets across over 50 global countries, covering more than 1 million public instruments, including stocks, forex, ETFs, mutual funds, commodities, and cryptocurrencies.  ## Quickstart  To get started, you'll need to sign up for an API key. Once you have your API key, you can start making requests to the API.  ### Step 1: Create Twelve Data account  Sign up on the Twelve Data website to create your account [here](https://twelvedata.com/register). This gives you access to the API dashboard and your API key.  ### Step 2: Get your API key  After signing in, navigate to your [dashboard](https://twelvedata.com/account/api-keys) to find your unique API key. This key is required to authenticate all API and WebSocket requests.  ### Step 3: Make your first request  Try a simple API call with cURL to fetch the latest price for Apple (AAPL):  ``` curl \"https://api.twelvedata.com/price?symbol=AAPL&apikey=your_api_key\" ```  ### Step 4: Make a request from Python or Javascript  Use our client libraries or standard HTTP clients to make API calls programmatically. Here’s an example in [Python](https://github.com/twelvedata/twelvedata-python) and JavaScript:  #### Python (using official Twelve Data SDK):  ```python from twelvedata import TDClient  # Initialize client with your API key td = TDClient(apikey=\"your_api_key\")  # Get latest price for Apple price = td.price(symbol=\"AAPL\").as_json()  print(price) ```  #### JavaScript (Node.js):  ```javascript const fetch = require('node-fetch');  fetch('https://api.twelvedata.com/price?symbol=AAPL&apikey=your_api_key') &nbsp;&nbsp;.then(response => response.json()) &nbsp;&nbsp;.then(data => console.log(data)); ```  ### Step 5: Perform correlation analysis between Tesla and Microsoft prices  Fetch historical price data for Tesla (TSLA) and Microsoft (MSFT) and calculate the correlation of their closing prices:  ```python from twelvedata import TDClient import pandas as pd  # Initialize client with your API key td = TDClient(apikey=\"your_api_key\")  # Fetch historical price data for Tesla tsla_ts = td.time_series( &nbsp;&nbsp;&nbsp;&nbsp;symbol=\"TSLA\", &nbsp;&nbsp;&nbsp;&nbsp;interval=\"1day\", &nbsp;&nbsp;&nbsp;&nbsp;outputsize=100 ).as_pandas()  # Fetch historical price data for Microsoft msft_ts = td.time_series( &nbsp;&nbsp;&nbsp;&nbsp;symbol=\"MSFT\", &nbsp;&nbsp;&nbsp;&nbsp;interval=\"1day\", &nbsp;&nbsp;&nbsp;&nbsp;outputsize=100 ).as_pandas()  # Align data on datetime index combined = pd.concat( &nbsp;&nbsp;&nbsp;&nbsp;[tsla_ts['close'].astype(float), msft_ts['close'].astype(float)], &nbsp;&nbsp;&nbsp;&nbsp;axis=1, &nbsp;&nbsp;&nbsp;&nbsp;keys=[\"TSLA\", \"MSFT\"] ).dropna()  # Calculate correlation correlation = combined[\"TSLA\"].corr(combined[\"MSFT\"]) print(f\"Correlation of closing prices between TSLA and MSFT: {correlation:.2f}\") ```  ### Authentication  Authenticate your requests using one of these methods:  #### Query parameter method ``` GET https://api.twelvedata.com/endpoint?symbol=AAPL&apikey=your_api_key ```  #### HTTP header method (recommended) ``` Authorization: apikey your_api_key ```  ##### API key useful information <ul> <li> Demo API key (<code>apikey=demo</code>) available for demo requests</li> <li> Personal API key required for full access</li> <li> Premium endpoints and data require higher-tier plans (testable with <a href=\"https://twelvedata.com/exchanges\">trial symbols</a>)</li> </ul>  ### API endpoints   Service | Base URL | ---------|----------|  REST API | `https://api.twelvedata.com` |  WebSocket | `wss://ws.twelvedata.com` |  ### Parameter guidelines <ul> <li><b>Separator:</b> Use <code>&</code> to separate multiple parameters</li> <li><b>Case sensitivity:</b> Parameter names are case-insensitive</li>  <ul><li><code>symbol=AAPL</code> = <code>symbol=aapl</code></li></ul>  <li><b>Multiple values:</b> Separate with commas where supported</li> </ul>  ### Response handling  #### Default format All responses return JSON format by default unless otherwise specified.  #### Null values <b>Important:</b> Some response fields may contain `null` values when data is unavailable for specific metrics. This is expected behavior, not an error.  ##### Best Practices: <ul> <li>Always implement <code>null</code> value handling in your application</li> <li>Use defensive programming techniques for data processing</li> <li>Consider fallback values or error handling for critical metrics</li> </ul>  #### Error handling Structure your code to gracefully handle: <ul> <li>Network timeouts</li> <li>Rate limiting responses</li> <li>Invalid parameter errors</li> <li>Data unavailability periods</li> </ul>  ##### Best practices <ul> <li><b>Rate limits:</b> Adhere to your plan’s rate limits to avoid throttling. Check your dashboard for details.</li> <li><b>Error handling:</b> Implement retry logic for transient errors (e.g., <code>429 Too Many Requests</code>).</li> <li><b>Caching:</b> Cache responses for frequently accessed data to reduce API calls and improve performance.</li> <li><b>Secure storage:</b> Store your API key securely and never expose it in client-side code or public repositories.</li> </ul>  ## Errors  Twelve Data API employs a standardized error response format, delivering a JSON object with `code`, `message`, and `status` keys for clear and consistent error communication.  ### Codes  Below is a table of possible error codes, their HTTP status, meanings, and resolution steps:   Code | status | Meaning | Resolution |  --- | --- | --- | --- |  **400** | Bad Request | Invalid or incorrect parameter(s) provided. | Check the `message` in the response for details. Refer to the API Documenta­tion to correct the input. |  **401** | Unauthor­ized | Invalid or incorrect API key. | Verify your API key is correct. Sign up for a key <a href=\"https://twelvedata.com/account/api-keys\">here</a>. |  **403** | Forbidden | API key lacks permissions for the requested resource (upgrade required). | Upgrade your plan <a href=\"https://twelvedata.com/pricing\">here</a>. |  **404** | Not Found | Requested data could not be found. | Adjust parameters to be less strict as they may be too restrictive. |  **414** | Parameter Too Long | Input parameter array exceeds the allowed length. | Follow the `message` guidance to adjust the parameter length. |  **429** | Too Many Requests | API request limit reached for your key. | Wait briefly or upgrade your plan <a href=\"https://twelvedata.com/pricing\">here</a>. |  **500** | Internal Server Error | Server-side issue occurred; retry later. | Contact support <a href=\"https://twelvedata.com/contact\">here</a> for assistance. |  ### Example error response  Consider the following invalid request:  ``` https://api.twelvedata.com/time_series?symbol=AAPL&interval=0.99min&apikey=your_api_key ```  Due to the incorrect `interval` value, the API returns:  ```json { &nbsp;&nbsp;\"code\": 400, &nbsp;&nbsp;\"message\": \"Invalid **interval** provided: 0.99min. Supported intervals: 1min, 5min, 15min, 30min, 45min, 1h, 2h, 4h, 8h, 1day, 1week, 1month\", &nbsp;&nbsp;\"status\": \"error\" } ```  Refer to the API Documentation for valid parameter values to resolve such errors.  ## Libraries  Twelve Data provides a growing ecosystem of libraries and integrations to help you build faster and smarter in your preferred environment. Official libraries are actively maintained by the Twelve Data team, while selected community-built libraries offer additional flexibility.  A full list is available on our [GitHub profile](https://github.com/search?q=twelvedata).  ### Official SDKs <ul> <li><b>Python:</b> <a href=\"https://github.com/twelvedata/twelvedata-python\">twelvedata-python</a></li> <li><b>R:</b> <a href=\"https://github.com/twelvedata/twelvedata-r-sdk\">twelvedata-r-sdk</a></li> </ul>  ### AI integrations <ul> <li><b>Twelve Data MCP Server:</b> <a href=\"https://github.com/twelvedata/mcp\">Repository</a> — Model Context Protocol (MCP) server that provides seamless integration with AI assistants and language models, enabling direct access to Twelve Data's financial market data within conversational interfaces and AI workflows.</li> </ul>  ### Spreadsheet add-ons <ul> <li><b>Excel:</b> <a href=\"https://twelvedata.com/excel\">Excel Add-in</a></li> <li><b>Google Sheets:</b> <a href=\"https://twelvedata.com/google-sheets\">Google Sheets Add-on</a></li> </ul>  ### Community libraries  The community has developed libraries in several popular languages. You can explore more community libraries on [GitHub](https://github.com/search?q=twelvedata). <ul> <li><b>C#:</b> <a href=\"https://github.com/pseudomarkets/TwelveDataSharp\">TwelveDataSharp</a></li> <li><b>JavaScript:</b> <a href=\"https://github.com/evzaboun/twelvedata\">twelvedata</a></li> <li><b>PHP:</b> <a href=\"https://github.com/ingelby/twelvedata\">twelvedata</a></li> <li><b>Go:</b> <a href=\"https://github.com/soulgarden/twelvedata\">twelvedata</a></li> <li><b>TypeScript:</b> <a href=\"https://github.com/Clyde-Goodall/twelve-data-wrapper\">twelve-data-wrapper</a></li> </ul>  ### Other Twelve Data repositories <ul> <li><b>searchindex</b> <i>(Go)</i>: <a href=\"https://github.com/twelvedata/searchindex\">Repository</a> — In-memory search index by strings</li> <li><b>ws-tools</b> <i>(Python)</i>: <a href=\"https://github.com/twelvedata/ws-tools\">Repository</a> — Utility tools for WebSocket stream handling</li> </ul>  ### API specification <ul> <li><b>OpenAPI / Swagger:</b> Access the <a href=\"https://api.twelvedata.com/doc/swagger/openapi.json\">complete API specification</a> in OpenAPI format. You can use this file to automatically generate client libraries in your preferred programming language, explore the API interactively via Swagger tools, or integrate Twelve Data seamlessly into your AI and LLM workflows.</li> </ul>

API version: 0.0.1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// TechnicalIndicatorAPIService TechnicalIndicatorAPI service
type TechnicalIndicatorAPIService service

type ApiGetTimeSeriesAdRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesAdRequest) Interval(interval string) ApiGetTimeSeriesAdRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesAdRequest) Symbol(symbol string) ApiGetTimeSeriesAdRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesAdRequest) Isin(isin string) ApiGetTimeSeriesAdRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesAdRequest) Figi(figi string) ApiGetTimeSeriesAdRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesAdRequest) Cusip(cusip string) ApiGetTimeSeriesAdRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesAdRequest) Outputsize(outputsize int64) ApiGetTimeSeriesAdRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesAdRequest) Exchange(exchange string) ApiGetTimeSeriesAdRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesAdRequest) MicCode(micCode string) ApiGetTimeSeriesAdRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesAdRequest) Country(country string) ApiGetTimeSeriesAdRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesAdRequest) Type_(type_ string) ApiGetTimeSeriesAdRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesAdRequest) Timezone(timezone string) ApiGetTimeSeriesAdRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesAdRequest) StartDate(startDate string) ApiGetTimeSeriesAdRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesAdRequest) EndDate(endDate string) ApiGetTimeSeriesAdRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesAdRequest) Date(date string) ApiGetTimeSeriesAdRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesAdRequest) Order(order string) ApiGetTimeSeriesAdRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesAdRequest) Prepost(prepost bool) ApiGetTimeSeriesAdRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesAdRequest) Format(format string) ApiGetTimeSeriesAdRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesAdRequest) Delimiter(delimiter string) ApiGetTimeSeriesAdRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesAdRequest) Dp(dp int64) ApiGetTimeSeriesAdRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesAdRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesAdRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesAdRequest) Adjust(adjust string) ApiGetTimeSeriesAdRequest {
	r.adjust = &adjust
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesAdRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesAdRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesAdRequest) Execute() (*GetTimeSeriesAd200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesAdExecute(r)
}

/*
GetTimeSeriesAd Accumulation/distribution

The Accumulation/Distribution (AD) endpoint provides data on the cumulative money flow into and out of a financial instrument, using its closing price, price range, and trading volume. This endpoint returns the AD line, which helps users identify potential buying or selling pressure and assess the strength of price movements.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesAdRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesAd(ctx context.Context) ApiGetTimeSeriesAdRequest {
	return ApiGetTimeSeriesAdRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesAd200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesAdExecute(r ApiGetTimeSeriesAdRequest) (*GetTimeSeriesAd200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesAd200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesAd")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ad"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesAdOscRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	fastPeriod *int64
	slowPeriod *int64
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesAdOscRequest) Interval(interval string) ApiGetTimeSeriesAdOscRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesAdOscRequest) Symbol(symbol string) ApiGetTimeSeriesAdOscRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesAdOscRequest) Isin(isin string) ApiGetTimeSeriesAdOscRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesAdOscRequest) Figi(figi string) ApiGetTimeSeriesAdOscRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesAdOscRequest) Cusip(cusip string) ApiGetTimeSeriesAdOscRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesAdOscRequest) Outputsize(outputsize int64) ApiGetTimeSeriesAdOscRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesAdOscRequest) Exchange(exchange string) ApiGetTimeSeriesAdOscRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesAdOscRequest) MicCode(micCode string) ApiGetTimeSeriesAdOscRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesAdOscRequest) Country(country string) ApiGetTimeSeriesAdOscRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesAdOscRequest) Type_(type_ string) ApiGetTimeSeriesAdOscRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesAdOscRequest) Timezone(timezone string) ApiGetTimeSeriesAdOscRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesAdOscRequest) StartDate(startDate string) ApiGetTimeSeriesAdOscRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesAdOscRequest) EndDate(endDate string) ApiGetTimeSeriesAdOscRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesAdOscRequest) Date(date string) ApiGetTimeSeriesAdOscRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesAdOscRequest) Order(order string) ApiGetTimeSeriesAdOscRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesAdOscRequest) Prepost(prepost bool) ApiGetTimeSeriesAdOscRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesAdOscRequest) Format(format string) ApiGetTimeSeriesAdOscRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesAdOscRequest) Delimiter(delimiter string) ApiGetTimeSeriesAdOscRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesAdOscRequest) Dp(dp int64) ApiGetTimeSeriesAdOscRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesAdOscRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesAdOscRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesAdOscRequest) Adjust(adjust string) ApiGetTimeSeriesAdOscRequest {
	r.adjust = &adjust
	return r
}

// Number of periods for fast moving average. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesAdOscRequest) FastPeriod(fastPeriod int64) ApiGetTimeSeriesAdOscRequest {
	r.fastPeriod = &fastPeriod
	return r
}

// Number of periods for slow moving average. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesAdOscRequest) SlowPeriod(slowPeriod int64) ApiGetTimeSeriesAdOscRequest {
	r.slowPeriod = &slowPeriod
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesAdOscRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesAdOscRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesAdOscRequest) Execute() (*GetTimeSeriesAdOsc200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesAdOscExecute(r)
}

/*
GetTimeSeriesAdOsc Accumulation/distribution oscillator

The Accumulation/Distribution Oscillator endpoint (ADOSC) calculates a momentum indicator that highlights shifts in buying or selling pressure by analyzing price and volume data over different time frames. It returns numerical values that help users identify potential trend reversals in financial markets.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesAdOscRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesAdOsc(ctx context.Context) ApiGetTimeSeriesAdOscRequest {
	return ApiGetTimeSeriesAdOscRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesAdOsc200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesAdOscExecute(r ApiGetTimeSeriesAdOscRequest) (*GetTimeSeriesAdOsc200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesAdOsc200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesAdOsc")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/adosc"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.fastPeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fast_period", r.fastPeriod, "form", "")
	} else {
        var defaultValue int64 = 12
        parameterAddToHeaderOrQuery(localVarQueryParams, "fast_period", defaultValue, "form", "")
        r.fastPeriod = &defaultValue
	}
	if r.slowPeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "slow_period", r.slowPeriod, "form", "")
	} else {
        var defaultValue int64 = 26
        parameterAddToHeaderOrQuery(localVarQueryParams, "slow_period", defaultValue, "form", "")
        r.slowPeriod = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesAddRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	seriesType1 *string
	seriesType2 *string
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesAddRequest) Interval(interval string) ApiGetTimeSeriesAddRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesAddRequest) Symbol(symbol string) ApiGetTimeSeriesAddRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesAddRequest) Isin(isin string) ApiGetTimeSeriesAddRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesAddRequest) Figi(figi string) ApiGetTimeSeriesAddRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesAddRequest) Cusip(cusip string) ApiGetTimeSeriesAddRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesAddRequest) Outputsize(outputsize int64) ApiGetTimeSeriesAddRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesAddRequest) Exchange(exchange string) ApiGetTimeSeriesAddRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesAddRequest) MicCode(micCode string) ApiGetTimeSeriesAddRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesAddRequest) Country(country string) ApiGetTimeSeriesAddRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesAddRequest) Type_(type_ string) ApiGetTimeSeriesAddRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesAddRequest) Timezone(timezone string) ApiGetTimeSeriesAddRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesAddRequest) StartDate(startDate string) ApiGetTimeSeriesAddRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesAddRequest) EndDate(endDate string) ApiGetTimeSeriesAddRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesAddRequest) Date(date string) ApiGetTimeSeriesAddRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesAddRequest) Order(order string) ApiGetTimeSeriesAddRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesAddRequest) Prepost(prepost bool) ApiGetTimeSeriesAddRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesAddRequest) Format(format string) ApiGetTimeSeriesAddRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesAddRequest) Delimiter(delimiter string) ApiGetTimeSeriesAddRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesAddRequest) Dp(dp int64) ApiGetTimeSeriesAddRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesAddRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesAddRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesAddRequest) Adjust(adjust string) ApiGetTimeSeriesAddRequest {
	r.adjust = &adjust
	return r
}

// Price type used as the first part of technical indicator
func (r ApiGetTimeSeriesAddRequest) SeriesType1(seriesType1 string) ApiGetTimeSeriesAddRequest {
	r.seriesType1 = &seriesType1
	return r
}

// Price type used as the second part of technical indicator
func (r ApiGetTimeSeriesAddRequest) SeriesType2(seriesType2 string) ApiGetTimeSeriesAddRequest {
	r.seriesType2 = &seriesType2
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesAddRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesAddRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesAddRequest) Execute() (*GetTimeSeriesAdd200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesAddExecute(r)
}

/*
GetTimeSeriesAdd Addition

The Addition (ADD) endpoint calculates the sum of two input data series, such as technical indicators or price data, and returns the combined result. This endpoint is useful for users who need to aggregate data points to create custom indicators or analyze the combined effect of multiple data series in financial analysis.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesAddRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesAdd(ctx context.Context) ApiGetTimeSeriesAddRequest {
	return ApiGetTimeSeriesAddRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesAdd200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesAddExecute(r ApiGetTimeSeriesAddRequest) (*GetTimeSeriesAdd200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesAdd200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesAdd")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/add"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.seriesType1 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "series_type_1", r.seriesType1, "form", "")
	} else {
        var defaultValue string = "open"
        parameterAddToHeaderOrQuery(localVarQueryParams, "series_type_1", defaultValue, "form", "")
        r.seriesType1 = &defaultValue
	}
	if r.seriesType2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "series_type_2", r.seriesType2, "form", "")
	} else {
        var defaultValue string = "close"
        parameterAddToHeaderOrQuery(localVarQueryParams, "series_type_2", defaultValue, "form", "")
        r.seriesType2 = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesAdxRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	timePeriod *int64
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesAdxRequest) Interval(interval string) ApiGetTimeSeriesAdxRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesAdxRequest) Symbol(symbol string) ApiGetTimeSeriesAdxRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesAdxRequest) Isin(isin string) ApiGetTimeSeriesAdxRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesAdxRequest) Figi(figi string) ApiGetTimeSeriesAdxRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesAdxRequest) Cusip(cusip string) ApiGetTimeSeriesAdxRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesAdxRequest) Outputsize(outputsize int64) ApiGetTimeSeriesAdxRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesAdxRequest) Exchange(exchange string) ApiGetTimeSeriesAdxRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesAdxRequest) MicCode(micCode string) ApiGetTimeSeriesAdxRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesAdxRequest) Country(country string) ApiGetTimeSeriesAdxRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesAdxRequest) Type_(type_ string) ApiGetTimeSeriesAdxRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesAdxRequest) Timezone(timezone string) ApiGetTimeSeriesAdxRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesAdxRequest) StartDate(startDate string) ApiGetTimeSeriesAdxRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesAdxRequest) EndDate(endDate string) ApiGetTimeSeriesAdxRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesAdxRequest) Date(date string) ApiGetTimeSeriesAdxRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesAdxRequest) Order(order string) ApiGetTimeSeriesAdxRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesAdxRequest) Prepost(prepost bool) ApiGetTimeSeriesAdxRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesAdxRequest) Format(format string) ApiGetTimeSeriesAdxRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesAdxRequest) Delimiter(delimiter string) ApiGetTimeSeriesAdxRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesAdxRequest) Dp(dp int64) ApiGetTimeSeriesAdxRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesAdxRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesAdxRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesAdxRequest) Adjust(adjust string) ApiGetTimeSeriesAdxRequest {
	r.adjust = &adjust
	return r
}

// Number of periods to average over. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesAdxRequest) TimePeriod(timePeriod int64) ApiGetTimeSeriesAdxRequest {
	r.timePeriod = &timePeriod
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesAdxRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesAdxRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesAdxRequest) Execute() (*GetTimeSeriesAdx200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesAdxExecute(r)
}

/*
GetTimeSeriesAdx Average directional index

The Average Directional Index (ADX) endpoint provides data on the strength of a market trend, regardless of its direction. It returns a numerical value that helps users identify whether a market is trending or moving sideways.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesAdxRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesAdx(ctx context.Context) ApiGetTimeSeriesAdxRequest {
	return ApiGetTimeSeriesAdxRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesAdx200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesAdxExecute(r ApiGetTimeSeriesAdxRequest) (*GetTimeSeriesAdx200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesAdx200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesAdx")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/adx"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.timePeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", r.timePeriod, "form", "")
	} else {
        var defaultValue int64 = 14
        parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", defaultValue, "form", "")
        r.timePeriod = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesAdxrRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	timePeriod *int64
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesAdxrRequest) Interval(interval string) ApiGetTimeSeriesAdxrRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesAdxrRequest) Symbol(symbol string) ApiGetTimeSeriesAdxrRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesAdxrRequest) Isin(isin string) ApiGetTimeSeriesAdxrRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesAdxrRequest) Figi(figi string) ApiGetTimeSeriesAdxrRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesAdxrRequest) Cusip(cusip string) ApiGetTimeSeriesAdxrRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesAdxrRequest) Outputsize(outputsize int64) ApiGetTimeSeriesAdxrRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesAdxrRequest) Exchange(exchange string) ApiGetTimeSeriesAdxrRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesAdxrRequest) MicCode(micCode string) ApiGetTimeSeriesAdxrRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesAdxrRequest) Country(country string) ApiGetTimeSeriesAdxrRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesAdxrRequest) Type_(type_ string) ApiGetTimeSeriesAdxrRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesAdxrRequest) Timezone(timezone string) ApiGetTimeSeriesAdxrRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesAdxrRequest) StartDate(startDate string) ApiGetTimeSeriesAdxrRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesAdxrRequest) EndDate(endDate string) ApiGetTimeSeriesAdxrRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesAdxrRequest) Date(date string) ApiGetTimeSeriesAdxrRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesAdxrRequest) Order(order string) ApiGetTimeSeriesAdxrRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesAdxrRequest) Prepost(prepost bool) ApiGetTimeSeriesAdxrRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesAdxrRequest) Format(format string) ApiGetTimeSeriesAdxrRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesAdxrRequest) Delimiter(delimiter string) ApiGetTimeSeriesAdxrRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesAdxrRequest) Dp(dp int64) ApiGetTimeSeriesAdxrRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesAdxrRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesAdxrRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesAdxrRequest) Adjust(adjust string) ApiGetTimeSeriesAdxrRequest {
	r.adjust = &adjust
	return r
}

// Number of periods to average over. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesAdxrRequest) TimePeriod(timePeriod int64) ApiGetTimeSeriesAdxrRequest {
	r.timePeriod = &timePeriod
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesAdxrRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesAdxrRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesAdxrRequest) Execute() (*GetTimeSeriesAdxr200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesAdxrExecute(r)
}

/*
GetTimeSeriesAdxr Average directional movement index rating

The Average Directional Movement Index Rating (ADXR) endpoint provides a smoothed measure of trend strength for a specified financial instrument. It returns the ADXR values, which help users assess the consistency of a trend over a given period by reducing short-term fluctuations. This endpoint is useful for traders and analysts who need to evaluate the stability of market trends for better timing of entry and exit points in their trading strategies.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesAdxrRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesAdxr(ctx context.Context) ApiGetTimeSeriesAdxrRequest {
	return ApiGetTimeSeriesAdxrRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesAdxr200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesAdxrExecute(r ApiGetTimeSeriesAdxrRequest) (*GetTimeSeriesAdxr200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesAdxr200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesAdxr")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/adxr"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.timePeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", r.timePeriod, "form", "")
	} else {
        var defaultValue int64 = 14
        parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", defaultValue, "form", "")
        r.timePeriod = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesApoRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	seriesType *string
	fastPeriod *int64
	slowPeriod *int64
	maType *string
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesApoRequest) Interval(interval string) ApiGetTimeSeriesApoRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesApoRequest) Symbol(symbol string) ApiGetTimeSeriesApoRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesApoRequest) Isin(isin string) ApiGetTimeSeriesApoRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesApoRequest) Figi(figi string) ApiGetTimeSeriesApoRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesApoRequest) Cusip(cusip string) ApiGetTimeSeriesApoRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesApoRequest) Outputsize(outputsize int64) ApiGetTimeSeriesApoRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesApoRequest) Exchange(exchange string) ApiGetTimeSeriesApoRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesApoRequest) MicCode(micCode string) ApiGetTimeSeriesApoRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesApoRequest) Country(country string) ApiGetTimeSeriesApoRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesApoRequest) Type_(type_ string) ApiGetTimeSeriesApoRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesApoRequest) Timezone(timezone string) ApiGetTimeSeriesApoRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesApoRequest) StartDate(startDate string) ApiGetTimeSeriesApoRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesApoRequest) EndDate(endDate string) ApiGetTimeSeriesApoRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesApoRequest) Date(date string) ApiGetTimeSeriesApoRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesApoRequest) Order(order string) ApiGetTimeSeriesApoRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesApoRequest) Prepost(prepost bool) ApiGetTimeSeriesApoRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesApoRequest) Format(format string) ApiGetTimeSeriesApoRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesApoRequest) Delimiter(delimiter string) ApiGetTimeSeriesApoRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesApoRequest) Dp(dp int64) ApiGetTimeSeriesApoRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesApoRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesApoRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesApoRequest) Adjust(adjust string) ApiGetTimeSeriesApoRequest {
	r.adjust = &adjust
	return r
}

// Price type on which technical indicator is calculated
func (r ApiGetTimeSeriesApoRequest) SeriesType(seriesType string) ApiGetTimeSeriesApoRequest {
	r.seriesType = &seriesType
	return r
}

// Number of periods for fast moving average. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesApoRequest) FastPeriod(fastPeriod int64) ApiGetTimeSeriesApoRequest {
	r.fastPeriod = &fastPeriod
	return r
}

// Number of periods for slow moving average. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesApoRequest) SlowPeriod(slowPeriod int64) ApiGetTimeSeriesApoRequest {
	r.slowPeriod = &slowPeriod
	return r
}

// The type of moving average used
func (r ApiGetTimeSeriesApoRequest) MaType(maType string) ApiGetTimeSeriesApoRequest {
	r.maType = &maType
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesApoRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesApoRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesApoRequest) Execute() (*GetTimeSeriesApo200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesApoExecute(r)
}

/*
GetTimeSeriesApo Absolute price oscillator

The Absolute Price Oscillator (APO) endpoint calculates the difference between two specified moving averages of a financial instrument's price, providing data that helps users identify potential price trends and reversals. The response includes the calculated APO values over a specified time period, which can be used to track momentum changes and assess the strength of price movements.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesApoRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesApo(ctx context.Context) ApiGetTimeSeriesApoRequest {
	return ApiGetTimeSeriesApoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesApo200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesApoExecute(r ApiGetTimeSeriesApoRequest) (*GetTimeSeriesApo200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesApo200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesApo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apo"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.seriesType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", r.seriesType, "form", "")
	} else {
        var defaultValue string = "close"
        parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", defaultValue, "form", "")
        r.seriesType = &defaultValue
	}
	if r.fastPeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fast_period", r.fastPeriod, "form", "")
	} else {
        var defaultValue int64 = 12
        parameterAddToHeaderOrQuery(localVarQueryParams, "fast_period", defaultValue, "form", "")
        r.fastPeriod = &defaultValue
	}
	if r.slowPeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "slow_period", r.slowPeriod, "form", "")
	} else {
        var defaultValue int64 = 26
        parameterAddToHeaderOrQuery(localVarQueryParams, "slow_period", defaultValue, "form", "")
        r.slowPeriod = &defaultValue
	}
	if r.maType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ma_type", r.maType, "form", "")
	} else {
        var defaultValue string = "SMA"
        parameterAddToHeaderOrQuery(localVarQueryParams, "ma_type", defaultValue, "form", "")
        r.maType = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesAroonRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	timePeriod *int64
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesAroonRequest) Interval(interval string) ApiGetTimeSeriesAroonRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesAroonRequest) Symbol(symbol string) ApiGetTimeSeriesAroonRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesAroonRequest) Isin(isin string) ApiGetTimeSeriesAroonRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesAroonRequest) Figi(figi string) ApiGetTimeSeriesAroonRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesAroonRequest) Cusip(cusip string) ApiGetTimeSeriesAroonRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesAroonRequest) Outputsize(outputsize int64) ApiGetTimeSeriesAroonRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesAroonRequest) Exchange(exchange string) ApiGetTimeSeriesAroonRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesAroonRequest) MicCode(micCode string) ApiGetTimeSeriesAroonRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesAroonRequest) Country(country string) ApiGetTimeSeriesAroonRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesAroonRequest) Type_(type_ string) ApiGetTimeSeriesAroonRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesAroonRequest) Timezone(timezone string) ApiGetTimeSeriesAroonRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesAroonRequest) StartDate(startDate string) ApiGetTimeSeriesAroonRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesAroonRequest) EndDate(endDate string) ApiGetTimeSeriesAroonRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesAroonRequest) Date(date string) ApiGetTimeSeriesAroonRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesAroonRequest) Order(order string) ApiGetTimeSeriesAroonRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesAroonRequest) Prepost(prepost bool) ApiGetTimeSeriesAroonRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesAroonRequest) Format(format string) ApiGetTimeSeriesAroonRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesAroonRequest) Delimiter(delimiter string) ApiGetTimeSeriesAroonRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesAroonRequest) Dp(dp int64) ApiGetTimeSeriesAroonRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesAroonRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesAroonRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesAroonRequest) Adjust(adjust string) ApiGetTimeSeriesAroonRequest {
	r.adjust = &adjust
	return r
}

// Number of periods to average over. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesAroonRequest) TimePeriod(timePeriod int64) ApiGetTimeSeriesAroonRequest {
	r.timePeriod = &timePeriod
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesAroonRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesAroonRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesAroonRequest) Execute() (*GetTimeSeriesAroon200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesAroonExecute(r)
}

/*
GetTimeSeriesAroon Aroon indicator

The Aroon Indicator endpoint provides data on the time elapsed since the highest high and lowest low within a specified period, helping users identify the presence and strength of market trends. It returns two values: Aroon Up and Aroon Down, which indicate the trend direction and momentum. This endpoint is useful for traders and analysts looking to assess trend patterns and potential reversals in financial markets.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesAroonRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesAroon(ctx context.Context) ApiGetTimeSeriesAroonRequest {
	return ApiGetTimeSeriesAroonRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesAroon200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesAroonExecute(r ApiGetTimeSeriesAroonRequest) (*GetTimeSeriesAroon200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesAroon200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesAroon")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/aroon"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.timePeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", r.timePeriod, "form", "")
	} else {
        var defaultValue int64 = 14
        parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", defaultValue, "form", "")
        r.timePeriod = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesAroonOscRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	timePeriod *int64
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesAroonOscRequest) Interval(interval string) ApiGetTimeSeriesAroonOscRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesAroonOscRequest) Symbol(symbol string) ApiGetTimeSeriesAroonOscRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesAroonOscRequest) Isin(isin string) ApiGetTimeSeriesAroonOscRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesAroonOscRequest) Figi(figi string) ApiGetTimeSeriesAroonOscRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesAroonOscRequest) Cusip(cusip string) ApiGetTimeSeriesAroonOscRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesAroonOscRequest) Outputsize(outputsize int64) ApiGetTimeSeriesAroonOscRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesAroonOscRequest) Exchange(exchange string) ApiGetTimeSeriesAroonOscRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesAroonOscRequest) MicCode(micCode string) ApiGetTimeSeriesAroonOscRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesAroonOscRequest) Country(country string) ApiGetTimeSeriesAroonOscRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesAroonOscRequest) Type_(type_ string) ApiGetTimeSeriesAroonOscRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesAroonOscRequest) Timezone(timezone string) ApiGetTimeSeriesAroonOscRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesAroonOscRequest) StartDate(startDate string) ApiGetTimeSeriesAroonOscRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesAroonOscRequest) EndDate(endDate string) ApiGetTimeSeriesAroonOscRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesAroonOscRequest) Date(date string) ApiGetTimeSeriesAroonOscRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesAroonOscRequest) Order(order string) ApiGetTimeSeriesAroonOscRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesAroonOscRequest) Prepost(prepost bool) ApiGetTimeSeriesAroonOscRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesAroonOscRequest) Format(format string) ApiGetTimeSeriesAroonOscRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesAroonOscRequest) Delimiter(delimiter string) ApiGetTimeSeriesAroonOscRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesAroonOscRequest) Dp(dp int64) ApiGetTimeSeriesAroonOscRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesAroonOscRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesAroonOscRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesAroonOscRequest) Adjust(adjust string) ApiGetTimeSeriesAroonOscRequest {
	r.adjust = &adjust
	return r
}

// Number of periods to average over. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesAroonOscRequest) TimePeriod(timePeriod int64) ApiGetTimeSeriesAroonOscRequest {
	r.timePeriod = &timePeriod
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesAroonOscRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesAroonOscRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesAroonOscRequest) Execute() (*GetTimeSeriesAroonOsc200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesAroonOscExecute(r)
}

/*
GetTimeSeriesAroonOsc Aroon oscillator

The Aroon Oscillator endpoint provides the calculated difference between the Aroon Up and Aroon Down indicators for a given financial instrument. It returns a time series of values that help users identify the strength and direction of a trend, as well as potential trend reversals. This data is useful for traders and analysts seeking to evaluate market trends over a specified period.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesAroonOscRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesAroonOsc(ctx context.Context) ApiGetTimeSeriesAroonOscRequest {
	return ApiGetTimeSeriesAroonOscRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesAroonOsc200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesAroonOscExecute(r ApiGetTimeSeriesAroonOscRequest) (*GetTimeSeriesAroonOsc200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesAroonOsc200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesAroonOsc")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/aroonosc"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.timePeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", r.timePeriod, "form", "")
	} else {
        var defaultValue int64 = 14
        parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", defaultValue, "form", "")
        r.timePeriod = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesAtrRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	timePeriod *int64
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesAtrRequest) Interval(interval string) ApiGetTimeSeriesAtrRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesAtrRequest) Symbol(symbol string) ApiGetTimeSeriesAtrRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesAtrRequest) Isin(isin string) ApiGetTimeSeriesAtrRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesAtrRequest) Figi(figi string) ApiGetTimeSeriesAtrRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesAtrRequest) Cusip(cusip string) ApiGetTimeSeriesAtrRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesAtrRequest) Outputsize(outputsize int64) ApiGetTimeSeriesAtrRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesAtrRequest) Exchange(exchange string) ApiGetTimeSeriesAtrRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesAtrRequest) MicCode(micCode string) ApiGetTimeSeriesAtrRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesAtrRequest) Country(country string) ApiGetTimeSeriesAtrRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesAtrRequest) Type_(type_ string) ApiGetTimeSeriesAtrRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesAtrRequest) Timezone(timezone string) ApiGetTimeSeriesAtrRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesAtrRequest) StartDate(startDate string) ApiGetTimeSeriesAtrRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesAtrRequest) EndDate(endDate string) ApiGetTimeSeriesAtrRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesAtrRequest) Date(date string) ApiGetTimeSeriesAtrRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesAtrRequest) Order(order string) ApiGetTimeSeriesAtrRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesAtrRequest) Prepost(prepost bool) ApiGetTimeSeriesAtrRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesAtrRequest) Format(format string) ApiGetTimeSeriesAtrRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesAtrRequest) Delimiter(delimiter string) ApiGetTimeSeriesAtrRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesAtrRequest) Dp(dp int64) ApiGetTimeSeriesAtrRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesAtrRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesAtrRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesAtrRequest) Adjust(adjust string) ApiGetTimeSeriesAtrRequest {
	r.adjust = &adjust
	return r
}

// Number of periods to average over. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesAtrRequest) TimePeriod(timePeriod int64) ApiGetTimeSeriesAtrRequest {
	r.timePeriod = &timePeriod
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesAtrRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesAtrRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesAtrRequest) Execute() (*GetTimeSeriesAtr200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesAtrExecute(r)
}

/*
GetTimeSeriesAtr Average true range

The Average True Range (ATR) endpoint provides data on market volatility by calculating the average range of price movement over a user-defined period. It returns numerical values representing the ATR for each time interval, allowing users to gauge the degree of price fluctuation in a financial instrument. This data is useful for setting stop-loss levels and determining optimal entry and exit points in trading strategies.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesAtrRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesAtr(ctx context.Context) ApiGetTimeSeriesAtrRequest {
	return ApiGetTimeSeriesAtrRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesAtr200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesAtrExecute(r ApiGetTimeSeriesAtrRequest) (*GetTimeSeriesAtr200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesAtr200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesAtr")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/atr"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.timePeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", r.timePeriod, "form", "")
	} else {
        var defaultValue int64 = 14
        parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", defaultValue, "form", "")
        r.timePeriod = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesAvgRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	seriesType *string
	timePeriod *int64
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesAvgRequest) Interval(interval string) ApiGetTimeSeriesAvgRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesAvgRequest) Symbol(symbol string) ApiGetTimeSeriesAvgRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesAvgRequest) Isin(isin string) ApiGetTimeSeriesAvgRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesAvgRequest) Figi(figi string) ApiGetTimeSeriesAvgRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesAvgRequest) Cusip(cusip string) ApiGetTimeSeriesAvgRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesAvgRequest) Outputsize(outputsize int64) ApiGetTimeSeriesAvgRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesAvgRequest) Exchange(exchange string) ApiGetTimeSeriesAvgRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesAvgRequest) MicCode(micCode string) ApiGetTimeSeriesAvgRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesAvgRequest) Country(country string) ApiGetTimeSeriesAvgRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesAvgRequest) Type_(type_ string) ApiGetTimeSeriesAvgRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesAvgRequest) Timezone(timezone string) ApiGetTimeSeriesAvgRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesAvgRequest) StartDate(startDate string) ApiGetTimeSeriesAvgRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesAvgRequest) EndDate(endDate string) ApiGetTimeSeriesAvgRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesAvgRequest) Date(date string) ApiGetTimeSeriesAvgRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesAvgRequest) Order(order string) ApiGetTimeSeriesAvgRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesAvgRequest) Prepost(prepost bool) ApiGetTimeSeriesAvgRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesAvgRequest) Format(format string) ApiGetTimeSeriesAvgRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesAvgRequest) Delimiter(delimiter string) ApiGetTimeSeriesAvgRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesAvgRequest) Dp(dp int64) ApiGetTimeSeriesAvgRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesAvgRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesAvgRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesAvgRequest) Adjust(adjust string) ApiGetTimeSeriesAvgRequest {
	r.adjust = &adjust
	return r
}

// Price type on which technical indicator is calculated
func (r ApiGetTimeSeriesAvgRequest) SeriesType(seriesType string) ApiGetTimeSeriesAvgRequest {
	r.seriesType = &seriesType
	return r
}

// Number of periods to average over. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesAvgRequest) TimePeriod(timePeriod int64) ApiGetTimeSeriesAvgRequest {
	r.timePeriod = &timePeriod
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesAvgRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesAvgRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesAvgRequest) Execute() (*GetTimeSeriesAvg200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesAvgExecute(r)
}

/*
GetTimeSeriesAvg Average

The Average (AVG) endpoint calculates the arithmetic mean of a specified data series over a chosen time period. It returns a smoothed dataset that helps users identify trends by reducing short-term fluctuations. This endpoint is useful for obtaining a clearer view of data trends, particularly in time series analysis.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesAvgRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesAvg(ctx context.Context) ApiGetTimeSeriesAvgRequest {
	return ApiGetTimeSeriesAvgRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesAvg200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesAvgExecute(r ApiGetTimeSeriesAvgRequest) (*GetTimeSeriesAvg200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesAvg200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesAvg")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/avg"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.seriesType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", r.seriesType, "form", "")
	} else {
        var defaultValue string = "close"
        parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", defaultValue, "form", "")
        r.seriesType = &defaultValue
	}
	if r.timePeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", r.timePeriod, "form", "")
	} else {
        var defaultValue int64 = 9
        parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", defaultValue, "form", "")
        r.timePeriod = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesAvgPriceRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesAvgPriceRequest) Interval(interval string) ApiGetTimeSeriesAvgPriceRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesAvgPriceRequest) Symbol(symbol string) ApiGetTimeSeriesAvgPriceRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesAvgPriceRequest) Isin(isin string) ApiGetTimeSeriesAvgPriceRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesAvgPriceRequest) Figi(figi string) ApiGetTimeSeriesAvgPriceRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesAvgPriceRequest) Cusip(cusip string) ApiGetTimeSeriesAvgPriceRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesAvgPriceRequest) Outputsize(outputsize int64) ApiGetTimeSeriesAvgPriceRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesAvgPriceRequest) Exchange(exchange string) ApiGetTimeSeriesAvgPriceRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesAvgPriceRequest) MicCode(micCode string) ApiGetTimeSeriesAvgPriceRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesAvgPriceRequest) Country(country string) ApiGetTimeSeriesAvgPriceRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesAvgPriceRequest) Type_(type_ string) ApiGetTimeSeriesAvgPriceRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesAvgPriceRequest) Timezone(timezone string) ApiGetTimeSeriesAvgPriceRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesAvgPriceRequest) StartDate(startDate string) ApiGetTimeSeriesAvgPriceRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesAvgPriceRequest) EndDate(endDate string) ApiGetTimeSeriesAvgPriceRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesAvgPriceRequest) Date(date string) ApiGetTimeSeriesAvgPriceRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesAvgPriceRequest) Order(order string) ApiGetTimeSeriesAvgPriceRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesAvgPriceRequest) Prepost(prepost bool) ApiGetTimeSeriesAvgPriceRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesAvgPriceRequest) Format(format string) ApiGetTimeSeriesAvgPriceRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesAvgPriceRequest) Delimiter(delimiter string) ApiGetTimeSeriesAvgPriceRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesAvgPriceRequest) Dp(dp int64) ApiGetTimeSeriesAvgPriceRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesAvgPriceRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesAvgPriceRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesAvgPriceRequest) Adjust(adjust string) ApiGetTimeSeriesAvgPriceRequest {
	r.adjust = &adjust
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesAvgPriceRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesAvgPriceRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesAvgPriceRequest) Execute() (*GetTimeSeriesAvgPrice200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesAvgPriceExecute(r)
}

/*
GetTimeSeriesAvgPrice Average price

The Average Price (AVGPRICE) endpoint calculates and returns the mean value of a security's open, high, low, and close prices. This endpoint provides a straightforward metric to assess the overall price level of a security over a specified period.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesAvgPriceRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesAvgPrice(ctx context.Context) ApiGetTimeSeriesAvgPriceRequest {
	return ApiGetTimeSeriesAvgPriceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesAvgPrice200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesAvgPriceExecute(r ApiGetTimeSeriesAvgPriceRequest) (*GetTimeSeriesAvgPrice200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesAvgPrice200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesAvgPrice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/avgprice"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesBBandsRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	seriesType *string
	timePeriod *int64
	sd *float64
	maType *string
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesBBandsRequest) Interval(interval string) ApiGetTimeSeriesBBandsRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesBBandsRequest) Symbol(symbol string) ApiGetTimeSeriesBBandsRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesBBandsRequest) Isin(isin string) ApiGetTimeSeriesBBandsRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesBBandsRequest) Figi(figi string) ApiGetTimeSeriesBBandsRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesBBandsRequest) Cusip(cusip string) ApiGetTimeSeriesBBandsRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesBBandsRequest) Outputsize(outputsize int64) ApiGetTimeSeriesBBandsRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesBBandsRequest) Exchange(exchange string) ApiGetTimeSeriesBBandsRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesBBandsRequest) MicCode(micCode string) ApiGetTimeSeriesBBandsRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesBBandsRequest) Country(country string) ApiGetTimeSeriesBBandsRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesBBandsRequest) Type_(type_ string) ApiGetTimeSeriesBBandsRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesBBandsRequest) Timezone(timezone string) ApiGetTimeSeriesBBandsRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesBBandsRequest) StartDate(startDate string) ApiGetTimeSeriesBBandsRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesBBandsRequest) EndDate(endDate string) ApiGetTimeSeriesBBandsRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesBBandsRequest) Date(date string) ApiGetTimeSeriesBBandsRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesBBandsRequest) Order(order string) ApiGetTimeSeriesBBandsRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesBBandsRequest) Prepost(prepost bool) ApiGetTimeSeriesBBandsRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesBBandsRequest) Format(format string) ApiGetTimeSeriesBBandsRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesBBandsRequest) Delimiter(delimiter string) ApiGetTimeSeriesBBandsRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesBBandsRequest) Dp(dp int64) ApiGetTimeSeriesBBandsRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesBBandsRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesBBandsRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesBBandsRequest) Adjust(adjust string) ApiGetTimeSeriesBBandsRequest {
	r.adjust = &adjust
	return r
}

// Price type on which technical indicator is calculated
func (r ApiGetTimeSeriesBBandsRequest) SeriesType(seriesType string) ApiGetTimeSeriesBBandsRequest {
	r.seriesType = &seriesType
	return r
}

// Number of periods to average over. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesBBandsRequest) TimePeriod(timePeriod int64) ApiGetTimeSeriesBBandsRequest {
	r.timePeriod = &timePeriod
	return r
}

// Number of standard deviations. Must be at least &#x60;1&#x60;
func (r ApiGetTimeSeriesBBandsRequest) Sd(sd float64) ApiGetTimeSeriesBBandsRequest {
	r.sd = &sd
	return r
}

// The type of moving average used
func (r ApiGetTimeSeriesBBandsRequest) MaType(maType string) ApiGetTimeSeriesBBandsRequest {
	r.maType = &maType
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesBBandsRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesBBandsRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesBBandsRequest) Execute() (*GetTimeSeriesBBands200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesBBandsExecute(r)
}

/*
GetTimeSeriesBBands Bollinger bands

The Bollinger Bands (BBANDS) endpoint calculates and returns three key data points: an upper band, a lower band, and a simple moving average (SMA) for a specified financial instrument. These bands are used to assess market volatility by showing how far prices deviate from the SMA. This information helps users identify potential price reversals and determine whether an asset is overbought or oversold.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesBBandsRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesBBands(ctx context.Context) ApiGetTimeSeriesBBandsRequest {
	return ApiGetTimeSeriesBBandsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesBBands200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesBBandsExecute(r ApiGetTimeSeriesBBandsRequest) (*GetTimeSeriesBBands200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesBBands200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesBBands")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/bbands"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.seriesType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", r.seriesType, "form", "")
	} else {
        var defaultValue string = "close"
        parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", defaultValue, "form", "")
        r.seriesType = &defaultValue
	}
	if r.timePeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", r.timePeriod, "form", "")
	} else {
        var defaultValue int64 = 20
        parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", defaultValue, "form", "")
        r.timePeriod = &defaultValue
	}
	if r.sd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sd", r.sd, "form", "")
	} else {
        var defaultValue float64 = 2
        parameterAddToHeaderOrQuery(localVarQueryParams, "sd", defaultValue, "form", "")
        r.sd = &defaultValue
	}
	if r.maType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ma_type", r.maType, "form", "")
	} else {
        var defaultValue string = "SMA"
        parameterAddToHeaderOrQuery(localVarQueryParams, "ma_type", defaultValue, "form", "")
        r.maType = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesBetaRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	seriesType1 *string
	seriesType2 *string
	timePeriod *int64
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesBetaRequest) Interval(interval string) ApiGetTimeSeriesBetaRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesBetaRequest) Symbol(symbol string) ApiGetTimeSeriesBetaRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesBetaRequest) Isin(isin string) ApiGetTimeSeriesBetaRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesBetaRequest) Figi(figi string) ApiGetTimeSeriesBetaRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesBetaRequest) Cusip(cusip string) ApiGetTimeSeriesBetaRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesBetaRequest) Outputsize(outputsize int64) ApiGetTimeSeriesBetaRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesBetaRequest) Exchange(exchange string) ApiGetTimeSeriesBetaRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesBetaRequest) MicCode(micCode string) ApiGetTimeSeriesBetaRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesBetaRequest) Country(country string) ApiGetTimeSeriesBetaRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesBetaRequest) Type_(type_ string) ApiGetTimeSeriesBetaRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesBetaRequest) Timezone(timezone string) ApiGetTimeSeriesBetaRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesBetaRequest) StartDate(startDate string) ApiGetTimeSeriesBetaRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesBetaRequest) EndDate(endDate string) ApiGetTimeSeriesBetaRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesBetaRequest) Date(date string) ApiGetTimeSeriesBetaRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesBetaRequest) Order(order string) ApiGetTimeSeriesBetaRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesBetaRequest) Prepost(prepost bool) ApiGetTimeSeriesBetaRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesBetaRequest) Format(format string) ApiGetTimeSeriesBetaRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesBetaRequest) Delimiter(delimiter string) ApiGetTimeSeriesBetaRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesBetaRequest) Dp(dp int64) ApiGetTimeSeriesBetaRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesBetaRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesBetaRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesBetaRequest) Adjust(adjust string) ApiGetTimeSeriesBetaRequest {
	r.adjust = &adjust
	return r
}

// Price type used as the first part of technical indicator
func (r ApiGetTimeSeriesBetaRequest) SeriesType1(seriesType1 string) ApiGetTimeSeriesBetaRequest {
	r.seriesType1 = &seriesType1
	return r
}

// Price type used as the second part of technical indicator
func (r ApiGetTimeSeriesBetaRequest) SeriesType2(seriesType2 string) ApiGetTimeSeriesBetaRequest {
	r.seriesType2 = &seriesType2
	return r
}

// Number of periods to average over. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesBetaRequest) TimePeriod(timePeriod int64) ApiGetTimeSeriesBetaRequest {
	r.timePeriod = &timePeriod
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesBetaRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesBetaRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesBetaRequest) Execute() (*GetTimeSeriesBeta200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesBetaExecute(r)
}

/*
GetTimeSeriesBeta Beta indicator

The Beta Indicator endpoint provides data on a security's sensitivity to market movements by comparing its price changes to a benchmark index. It returns the beta value, which quantifies the systematic risk of the security relative to the market. This information is useful for evaluating how much a security's price is expected to move in relation to market changes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesBetaRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesBeta(ctx context.Context) ApiGetTimeSeriesBetaRequest {
	return ApiGetTimeSeriesBetaRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesBeta200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesBetaExecute(r ApiGetTimeSeriesBetaRequest) (*GetTimeSeriesBeta200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesBeta200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesBeta")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/beta"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.seriesType1 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "series_type_1", r.seriesType1, "form", "")
	} else {
        var defaultValue string = "open"
        parameterAddToHeaderOrQuery(localVarQueryParams, "series_type_1", defaultValue, "form", "")
        r.seriesType1 = &defaultValue
	}
	if r.seriesType2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "series_type_2", r.seriesType2, "form", "")
	} else {
        var defaultValue string = "close"
        parameterAddToHeaderOrQuery(localVarQueryParams, "series_type_2", defaultValue, "form", "")
        r.seriesType2 = &defaultValue
	}
	if r.timePeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", r.timePeriod, "form", "")
	} else {
        var defaultValue int64 = 9
        parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", defaultValue, "form", "")
        r.timePeriod = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesBopRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesBopRequest) Interval(interval string) ApiGetTimeSeriesBopRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesBopRequest) Symbol(symbol string) ApiGetTimeSeriesBopRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesBopRequest) Isin(isin string) ApiGetTimeSeriesBopRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesBopRequest) Figi(figi string) ApiGetTimeSeriesBopRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesBopRequest) Cusip(cusip string) ApiGetTimeSeriesBopRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesBopRequest) Outputsize(outputsize int64) ApiGetTimeSeriesBopRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesBopRequest) Exchange(exchange string) ApiGetTimeSeriesBopRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesBopRequest) MicCode(micCode string) ApiGetTimeSeriesBopRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesBopRequest) Country(country string) ApiGetTimeSeriesBopRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesBopRequest) Type_(type_ string) ApiGetTimeSeriesBopRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesBopRequest) Timezone(timezone string) ApiGetTimeSeriesBopRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesBopRequest) StartDate(startDate string) ApiGetTimeSeriesBopRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesBopRequest) EndDate(endDate string) ApiGetTimeSeriesBopRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesBopRequest) Date(date string) ApiGetTimeSeriesBopRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesBopRequest) Order(order string) ApiGetTimeSeriesBopRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesBopRequest) Prepost(prepost bool) ApiGetTimeSeriesBopRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesBopRequest) Format(format string) ApiGetTimeSeriesBopRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesBopRequest) Delimiter(delimiter string) ApiGetTimeSeriesBopRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesBopRequest) Dp(dp int64) ApiGetTimeSeriesBopRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesBopRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesBopRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesBopRequest) Adjust(adjust string) ApiGetTimeSeriesBopRequest {
	r.adjust = &adjust
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesBopRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesBopRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesBopRequest) Execute() (*GetTimeSeriesBop200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesBopExecute(r)
}

/*
GetTimeSeriesBop Balance of power

The Balance of Power (BOP) endpoint provides data on the buying and selling pressure of a security by analyzing its open, high, low, and close prices. It returns numerical values that help users detect shifts in market sentiment and potential price movements.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesBopRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesBop(ctx context.Context) ApiGetTimeSeriesBopRequest {
	return ApiGetTimeSeriesBopRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesBop200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesBopExecute(r ApiGetTimeSeriesBopRequest) (*GetTimeSeriesBop200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesBop200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesBop")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/bop"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesCciRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	timePeriod *int64
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesCciRequest) Interval(interval string) ApiGetTimeSeriesCciRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesCciRequest) Symbol(symbol string) ApiGetTimeSeriesCciRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesCciRequest) Isin(isin string) ApiGetTimeSeriesCciRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesCciRequest) Figi(figi string) ApiGetTimeSeriesCciRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesCciRequest) Cusip(cusip string) ApiGetTimeSeriesCciRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesCciRequest) Outputsize(outputsize int64) ApiGetTimeSeriesCciRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesCciRequest) Exchange(exchange string) ApiGetTimeSeriesCciRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesCciRequest) MicCode(micCode string) ApiGetTimeSeriesCciRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesCciRequest) Country(country string) ApiGetTimeSeriesCciRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesCciRequest) Type_(type_ string) ApiGetTimeSeriesCciRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesCciRequest) Timezone(timezone string) ApiGetTimeSeriesCciRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesCciRequest) StartDate(startDate string) ApiGetTimeSeriesCciRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesCciRequest) EndDate(endDate string) ApiGetTimeSeriesCciRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesCciRequest) Date(date string) ApiGetTimeSeriesCciRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesCciRequest) Order(order string) ApiGetTimeSeriesCciRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesCciRequest) Prepost(prepost bool) ApiGetTimeSeriesCciRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesCciRequest) Format(format string) ApiGetTimeSeriesCciRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesCciRequest) Delimiter(delimiter string) ApiGetTimeSeriesCciRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesCciRequest) Dp(dp int64) ApiGetTimeSeriesCciRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesCciRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesCciRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesCciRequest) Adjust(adjust string) ApiGetTimeSeriesCciRequest {
	r.adjust = &adjust
	return r
}

// Number of periods to average over. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesCciRequest) TimePeriod(timePeriod int64) ApiGetTimeSeriesCciRequest {
	r.timePeriod = &timePeriod
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesCciRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesCciRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesCciRequest) Execute() (*GetTimeSeriesCci200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesCciExecute(r)
}

/*
GetTimeSeriesCci Commodity channel index

The Commodity Channel Index (CCI) endpoint provides data on the CCI values for a specified security, helping users detect potential price reversals by identifying overbought or oversold conditions. It returns a series of CCI values calculated over a specified time period, allowing users to assess the momentum of a security relative to its average price range.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesCciRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesCci(ctx context.Context) ApiGetTimeSeriesCciRequest {
	return ApiGetTimeSeriesCciRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesCci200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesCciExecute(r ApiGetTimeSeriesCciRequest) (*GetTimeSeriesCci200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesCci200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesCci")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cci"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.timePeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", r.timePeriod, "form", "")
	} else {
        var defaultValue int64 = 20
        parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", defaultValue, "form", "")
        r.timePeriod = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesCeilRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	seriesType *string
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesCeilRequest) Interval(interval string) ApiGetTimeSeriesCeilRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesCeilRequest) Symbol(symbol string) ApiGetTimeSeriesCeilRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesCeilRequest) Isin(isin string) ApiGetTimeSeriesCeilRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesCeilRequest) Figi(figi string) ApiGetTimeSeriesCeilRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesCeilRequest) Cusip(cusip string) ApiGetTimeSeriesCeilRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesCeilRequest) Outputsize(outputsize int64) ApiGetTimeSeriesCeilRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesCeilRequest) Exchange(exchange string) ApiGetTimeSeriesCeilRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesCeilRequest) MicCode(micCode string) ApiGetTimeSeriesCeilRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesCeilRequest) Country(country string) ApiGetTimeSeriesCeilRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesCeilRequest) Type_(type_ string) ApiGetTimeSeriesCeilRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesCeilRequest) Timezone(timezone string) ApiGetTimeSeriesCeilRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesCeilRequest) StartDate(startDate string) ApiGetTimeSeriesCeilRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesCeilRequest) EndDate(endDate string) ApiGetTimeSeriesCeilRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesCeilRequest) Date(date string) ApiGetTimeSeriesCeilRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesCeilRequest) Order(order string) ApiGetTimeSeriesCeilRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesCeilRequest) Prepost(prepost bool) ApiGetTimeSeriesCeilRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesCeilRequest) Format(format string) ApiGetTimeSeriesCeilRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesCeilRequest) Delimiter(delimiter string) ApiGetTimeSeriesCeilRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesCeilRequest) Dp(dp int64) ApiGetTimeSeriesCeilRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesCeilRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesCeilRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesCeilRequest) Adjust(adjust string) ApiGetTimeSeriesCeilRequest {
	r.adjust = &adjust
	return r
}

// Price type on which technical indicator is calculated
func (r ApiGetTimeSeriesCeilRequest) SeriesType(seriesType string) ApiGetTimeSeriesCeilRequest {
	r.seriesType = &seriesType
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesCeilRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesCeilRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesCeilRequest) Execute() (*GetTimeSeriesCeil200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesCeilExecute(r)
}

/*
GetTimeSeriesCeil Ceiling

The Ceiling (CEIL) endpoint rounds each value in the input data series up to the nearest whole number. It returns a series where each original data point is adjusted to its ceiling value, which can be useful for precise calculations or when integrating with other technical indicators that require integer inputs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesCeilRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesCeil(ctx context.Context) ApiGetTimeSeriesCeilRequest {
	return ApiGetTimeSeriesCeilRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesCeil200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesCeilExecute(r ApiGetTimeSeriesCeilRequest) (*GetTimeSeriesCeil200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesCeil200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesCeil")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ceil"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.seriesType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", r.seriesType, "form", "")
	} else {
        var defaultValue string = "close"
        parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", defaultValue, "form", "")
        r.seriesType = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesCmoRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	seriesType *string
	timePeriod *int64
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesCmoRequest) Interval(interval string) ApiGetTimeSeriesCmoRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesCmoRequest) Symbol(symbol string) ApiGetTimeSeriesCmoRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesCmoRequest) Isin(isin string) ApiGetTimeSeriesCmoRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesCmoRequest) Figi(figi string) ApiGetTimeSeriesCmoRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesCmoRequest) Cusip(cusip string) ApiGetTimeSeriesCmoRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesCmoRequest) Outputsize(outputsize int64) ApiGetTimeSeriesCmoRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesCmoRequest) Exchange(exchange string) ApiGetTimeSeriesCmoRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesCmoRequest) MicCode(micCode string) ApiGetTimeSeriesCmoRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesCmoRequest) Country(country string) ApiGetTimeSeriesCmoRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesCmoRequest) Type_(type_ string) ApiGetTimeSeriesCmoRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesCmoRequest) Timezone(timezone string) ApiGetTimeSeriesCmoRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesCmoRequest) StartDate(startDate string) ApiGetTimeSeriesCmoRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesCmoRequest) EndDate(endDate string) ApiGetTimeSeriesCmoRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesCmoRequest) Date(date string) ApiGetTimeSeriesCmoRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesCmoRequest) Order(order string) ApiGetTimeSeriesCmoRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesCmoRequest) Prepost(prepost bool) ApiGetTimeSeriesCmoRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesCmoRequest) Format(format string) ApiGetTimeSeriesCmoRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesCmoRequest) Delimiter(delimiter string) ApiGetTimeSeriesCmoRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesCmoRequest) Dp(dp int64) ApiGetTimeSeriesCmoRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesCmoRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesCmoRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesCmoRequest) Adjust(adjust string) ApiGetTimeSeriesCmoRequest {
	r.adjust = &adjust
	return r
}

// Price type on which technical indicator is calculated
func (r ApiGetTimeSeriesCmoRequest) SeriesType(seriesType string) ApiGetTimeSeriesCmoRequest {
	r.seriesType = &seriesType
	return r
}

// Number of periods to average over. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesCmoRequest) TimePeriod(timePeriod int64) ApiGetTimeSeriesCmoRequest {
	r.timePeriod = &timePeriod
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesCmoRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesCmoRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesCmoRequest) Execute() (*GetTimeSeriesCmo200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesCmoExecute(r)
}

/*
GetTimeSeriesCmo Chande momentum oscillator

The Chande Momentum Oscillator (CMO) endpoint provides data on the momentum of a security by calculating the relative strength of recent price movements. It returns a numerical value indicating whether a security is potentially overbought or oversold, assisting users in identifying possible trend reversals.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesCmoRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesCmo(ctx context.Context) ApiGetTimeSeriesCmoRequest {
	return ApiGetTimeSeriesCmoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesCmo200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesCmoExecute(r ApiGetTimeSeriesCmoRequest) (*GetTimeSeriesCmo200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesCmo200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesCmo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cmo"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.seriesType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", r.seriesType, "form", "")
	} else {
        var defaultValue string = "close"
        parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", defaultValue, "form", "")
        r.seriesType = &defaultValue
	}
	if r.timePeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", r.timePeriod, "form", "")
	} else {
        var defaultValue int64 = 9
        parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", defaultValue, "form", "")
        r.timePeriod = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesCoppockRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	seriesType *string
	wmaPeriod *int64
	longRocPeriod *int64
	shortRocPeriod *int64
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesCoppockRequest) Interval(interval string) ApiGetTimeSeriesCoppockRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesCoppockRequest) Symbol(symbol string) ApiGetTimeSeriesCoppockRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesCoppockRequest) Isin(isin string) ApiGetTimeSeriesCoppockRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesCoppockRequest) Figi(figi string) ApiGetTimeSeriesCoppockRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesCoppockRequest) Cusip(cusip string) ApiGetTimeSeriesCoppockRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesCoppockRequest) Outputsize(outputsize int64) ApiGetTimeSeriesCoppockRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesCoppockRequest) Exchange(exchange string) ApiGetTimeSeriesCoppockRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesCoppockRequest) MicCode(micCode string) ApiGetTimeSeriesCoppockRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesCoppockRequest) Country(country string) ApiGetTimeSeriesCoppockRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesCoppockRequest) Type_(type_ string) ApiGetTimeSeriesCoppockRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesCoppockRequest) Timezone(timezone string) ApiGetTimeSeriesCoppockRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesCoppockRequest) StartDate(startDate string) ApiGetTimeSeriesCoppockRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesCoppockRequest) EndDate(endDate string) ApiGetTimeSeriesCoppockRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesCoppockRequest) Date(date string) ApiGetTimeSeriesCoppockRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesCoppockRequest) Order(order string) ApiGetTimeSeriesCoppockRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesCoppockRequest) Prepost(prepost bool) ApiGetTimeSeriesCoppockRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesCoppockRequest) Format(format string) ApiGetTimeSeriesCoppockRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesCoppockRequest) Delimiter(delimiter string) ApiGetTimeSeriesCoppockRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesCoppockRequest) Dp(dp int64) ApiGetTimeSeriesCoppockRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesCoppockRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesCoppockRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesCoppockRequest) Adjust(adjust string) ApiGetTimeSeriesCoppockRequest {
	r.adjust = &adjust
	return r
}

// Price type on which technical indicator is calculated
func (r ApiGetTimeSeriesCoppockRequest) SeriesType(seriesType string) ApiGetTimeSeriesCoppockRequest {
	r.seriesType = &seriesType
	return r
}

// Number of periods for weighted moving average. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesCoppockRequest) WmaPeriod(wmaPeriod int64) ApiGetTimeSeriesCoppockRequest {
	r.wmaPeriod = &wmaPeriod
	return r
}

// Number of periods for long term rate of change. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesCoppockRequest) LongRocPeriod(longRocPeriod int64) ApiGetTimeSeriesCoppockRequest {
	r.longRocPeriod = &longRocPeriod
	return r
}

// Number of periods for short term rate of change. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesCoppockRequest) ShortRocPeriod(shortRocPeriod int64) ApiGetTimeSeriesCoppockRequest {
	r.shortRocPeriod = &shortRocPeriod
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesCoppockRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesCoppockRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesCoppockRequest) Execute() (*GetTimeSeriesCoppock200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesCoppockExecute(r)
}

/*
GetTimeSeriesCoppock Coppock curve

The Coppock Curve is a momentum oscillator used to detect potential long-term trend reversals in financial markets. It returns the calculated values of this indicator over a specified period, allowing users to identify when a security's price may be shifting from a downtrend to an uptrend. This endpoint is particularly useful for analyzing securities in bottoming markets.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesCoppockRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesCoppock(ctx context.Context) ApiGetTimeSeriesCoppockRequest {
	return ApiGetTimeSeriesCoppockRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesCoppock200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesCoppockExecute(r ApiGetTimeSeriesCoppockRequest) (*GetTimeSeriesCoppock200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesCoppock200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesCoppock")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/coppock"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.seriesType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", r.seriesType, "form", "")
	} else {
        var defaultValue string = "close"
        parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", defaultValue, "form", "")
        r.seriesType = &defaultValue
	}
	if r.wmaPeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wma_period", r.wmaPeriod, "form", "")
	} else {
        var defaultValue int64 = 10
        parameterAddToHeaderOrQuery(localVarQueryParams, "wma_period", defaultValue, "form", "")
        r.wmaPeriod = &defaultValue
	}
	if r.longRocPeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "long_roc_period", r.longRocPeriod, "form", "")
	} else {
        var defaultValue int64 = 14
        parameterAddToHeaderOrQuery(localVarQueryParams, "long_roc_period", defaultValue, "form", "")
        r.longRocPeriod = &defaultValue
	}
	if r.shortRocPeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "short_roc_period", r.shortRocPeriod, "form", "")
	} else {
        var defaultValue int64 = 11
        parameterAddToHeaderOrQuery(localVarQueryParams, "short_roc_period", defaultValue, "form", "")
        r.shortRocPeriod = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesCorrelRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	seriesType1 *string
	seriesType2 *string
	timePeriod *int64
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesCorrelRequest) Interval(interval string) ApiGetTimeSeriesCorrelRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesCorrelRequest) Symbol(symbol string) ApiGetTimeSeriesCorrelRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesCorrelRequest) Isin(isin string) ApiGetTimeSeriesCorrelRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesCorrelRequest) Figi(figi string) ApiGetTimeSeriesCorrelRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesCorrelRequest) Cusip(cusip string) ApiGetTimeSeriesCorrelRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesCorrelRequest) Outputsize(outputsize int64) ApiGetTimeSeriesCorrelRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesCorrelRequest) Exchange(exchange string) ApiGetTimeSeriesCorrelRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesCorrelRequest) MicCode(micCode string) ApiGetTimeSeriesCorrelRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesCorrelRequest) Country(country string) ApiGetTimeSeriesCorrelRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesCorrelRequest) Type_(type_ string) ApiGetTimeSeriesCorrelRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesCorrelRequest) Timezone(timezone string) ApiGetTimeSeriesCorrelRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesCorrelRequest) StartDate(startDate string) ApiGetTimeSeriesCorrelRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesCorrelRequest) EndDate(endDate string) ApiGetTimeSeriesCorrelRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesCorrelRequest) Date(date string) ApiGetTimeSeriesCorrelRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesCorrelRequest) Order(order string) ApiGetTimeSeriesCorrelRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesCorrelRequest) Prepost(prepost bool) ApiGetTimeSeriesCorrelRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesCorrelRequest) Format(format string) ApiGetTimeSeriesCorrelRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesCorrelRequest) Delimiter(delimiter string) ApiGetTimeSeriesCorrelRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesCorrelRequest) Dp(dp int64) ApiGetTimeSeriesCorrelRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesCorrelRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesCorrelRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesCorrelRequest) Adjust(adjust string) ApiGetTimeSeriesCorrelRequest {
	r.adjust = &adjust
	return r
}

// Price type used as the first part of technical indicator
func (r ApiGetTimeSeriesCorrelRequest) SeriesType1(seriesType1 string) ApiGetTimeSeriesCorrelRequest {
	r.seriesType1 = &seriesType1
	return r
}

// Price type used as the second part of technical indicator
func (r ApiGetTimeSeriesCorrelRequest) SeriesType2(seriesType2 string) ApiGetTimeSeriesCorrelRequest {
	r.seriesType2 = &seriesType2
	return r
}

// Number of periods to average over. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesCorrelRequest) TimePeriod(timePeriod int64) ApiGetTimeSeriesCorrelRequest {
	r.timePeriod = &timePeriod
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesCorrelRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesCorrelRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesCorrelRequest) Execute() (*GetTimeSeriesCorrel200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesCorrelExecute(r)
}

/*
GetTimeSeriesCorrel Correlation

The Correlation (CORREL) endpoint calculates the statistical relationship between two securities over a specified time period, returning a correlation coefficient. This coefficient ranges from -1 to 1, indicating the strength and direction of their linear relationship. A value close to 1 suggests a strong positive correlation, while a value near -1 indicates a strong negative correlation. This data is useful for identifying securities that move together or in opposite directions, aiding in strategies like diversification or pairs trading.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesCorrelRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesCorrel(ctx context.Context) ApiGetTimeSeriesCorrelRequest {
	return ApiGetTimeSeriesCorrelRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesCorrel200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesCorrelExecute(r ApiGetTimeSeriesCorrelRequest) (*GetTimeSeriesCorrel200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesCorrel200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesCorrel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/correl"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.seriesType1 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "series_type_1", r.seriesType1, "form", "")
	} else {
        var defaultValue string = "open"
        parameterAddToHeaderOrQuery(localVarQueryParams, "series_type_1", defaultValue, "form", "")
        r.seriesType1 = &defaultValue
	}
	if r.seriesType2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "series_type_2", r.seriesType2, "form", "")
	} else {
        var defaultValue string = "close"
        parameterAddToHeaderOrQuery(localVarQueryParams, "series_type_2", defaultValue, "form", "")
        r.seriesType2 = &defaultValue
	}
	if r.timePeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", r.timePeriod, "form", "")
	} else {
        var defaultValue int64 = 9
        parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", defaultValue, "form", "")
        r.timePeriod = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesCrsiRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	seriesType *string
	rsiPeriod *int64
	upDownLength *int64
	percentRankPeriod *int64
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesCrsiRequest) Interval(interval string) ApiGetTimeSeriesCrsiRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesCrsiRequest) Symbol(symbol string) ApiGetTimeSeriesCrsiRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesCrsiRequest) Isin(isin string) ApiGetTimeSeriesCrsiRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesCrsiRequest) Figi(figi string) ApiGetTimeSeriesCrsiRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesCrsiRequest) Cusip(cusip string) ApiGetTimeSeriesCrsiRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesCrsiRequest) Outputsize(outputsize int64) ApiGetTimeSeriesCrsiRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesCrsiRequest) Exchange(exchange string) ApiGetTimeSeriesCrsiRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesCrsiRequest) MicCode(micCode string) ApiGetTimeSeriesCrsiRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesCrsiRequest) Country(country string) ApiGetTimeSeriesCrsiRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesCrsiRequest) Type_(type_ string) ApiGetTimeSeriesCrsiRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesCrsiRequest) Timezone(timezone string) ApiGetTimeSeriesCrsiRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesCrsiRequest) StartDate(startDate string) ApiGetTimeSeriesCrsiRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesCrsiRequest) EndDate(endDate string) ApiGetTimeSeriesCrsiRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesCrsiRequest) Date(date string) ApiGetTimeSeriesCrsiRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesCrsiRequest) Order(order string) ApiGetTimeSeriesCrsiRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesCrsiRequest) Prepost(prepost bool) ApiGetTimeSeriesCrsiRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesCrsiRequest) Format(format string) ApiGetTimeSeriesCrsiRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesCrsiRequest) Delimiter(delimiter string) ApiGetTimeSeriesCrsiRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesCrsiRequest) Dp(dp int64) ApiGetTimeSeriesCrsiRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesCrsiRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesCrsiRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesCrsiRequest) Adjust(adjust string) ApiGetTimeSeriesCrsiRequest {
	r.adjust = &adjust
	return r
}

// Price type on which technical indicator is calculated
func (r ApiGetTimeSeriesCrsiRequest) SeriesType(seriesType string) ApiGetTimeSeriesCrsiRequest {
	r.seriesType = &seriesType
	return r
}

// Number of periods for RSI used to calculate price momentum. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesCrsiRequest) RsiPeriod(rsiPeriod int64) ApiGetTimeSeriesCrsiRequest {
	r.rsiPeriod = &rsiPeriod
	return r
}

// Number of periods for RSI used to calculate up/down trend. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesCrsiRequest) UpDownLength(upDownLength int64) ApiGetTimeSeriesCrsiRequest {
	r.upDownLength = &upDownLength
	return r
}

// Number of periods used to calculate PercentRank. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesCrsiRequest) PercentRankPeriod(percentRankPeriod int64) ApiGetTimeSeriesCrsiRequest {
	r.percentRankPeriod = &percentRankPeriod
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesCrsiRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesCrsiRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesCrsiRequest) Execute() (*GetTimeSeriesCrsi200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesCrsiExecute(r)
}

/*
GetTimeSeriesCrsi Connors relative strength index

The Connors Relative Strength Index (CRSI) endpoint provides a detailed analysis of stock momentum by combining three components: the Relative Strength Index, the Rate of Change, and the Up/Down Length. This endpoint returns a numerical value that helps identify potential trend reversals and momentum shifts in a security's price. Ideal for traders seeking to refine entry and exit points, the CRSI offers a nuanced view of market conditions beyond traditional RSI indicators.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesCrsiRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesCrsi(ctx context.Context) ApiGetTimeSeriesCrsiRequest {
	return ApiGetTimeSeriesCrsiRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesCrsi200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesCrsiExecute(r ApiGetTimeSeriesCrsiRequest) (*GetTimeSeriesCrsi200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesCrsi200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesCrsi")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/crsi"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.seriesType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", r.seriesType, "form", "")
	} else {
        var defaultValue string = "close"
        parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", defaultValue, "form", "")
        r.seriesType = &defaultValue
	}
	if r.rsiPeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rsi_period", r.rsiPeriod, "form", "")
	} else {
        var defaultValue int64 = 3
        parameterAddToHeaderOrQuery(localVarQueryParams, "rsi_period", defaultValue, "form", "")
        r.rsiPeriod = &defaultValue
	}
	if r.upDownLength != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "up_down_length", r.upDownLength, "form", "")
	} else {
        var defaultValue int64 = 2
        parameterAddToHeaderOrQuery(localVarQueryParams, "up_down_length", defaultValue, "form", "")
        r.upDownLength = &defaultValue
	}
	if r.percentRankPeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "percent_rank_period", r.percentRankPeriod, "form", "")
	} else {
        var defaultValue int64 = 100
        parameterAddToHeaderOrQuery(localVarQueryParams, "percent_rank_period", defaultValue, "form", "")
        r.percentRankPeriod = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesDemaRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	seriesType *string
	timePeriod *int64
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesDemaRequest) Interval(interval string) ApiGetTimeSeriesDemaRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesDemaRequest) Symbol(symbol string) ApiGetTimeSeriesDemaRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesDemaRequest) Isin(isin string) ApiGetTimeSeriesDemaRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesDemaRequest) Figi(figi string) ApiGetTimeSeriesDemaRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesDemaRequest) Cusip(cusip string) ApiGetTimeSeriesDemaRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesDemaRequest) Outputsize(outputsize int64) ApiGetTimeSeriesDemaRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesDemaRequest) Exchange(exchange string) ApiGetTimeSeriesDemaRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesDemaRequest) MicCode(micCode string) ApiGetTimeSeriesDemaRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesDemaRequest) Country(country string) ApiGetTimeSeriesDemaRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesDemaRequest) Type_(type_ string) ApiGetTimeSeriesDemaRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesDemaRequest) Timezone(timezone string) ApiGetTimeSeriesDemaRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesDemaRequest) StartDate(startDate string) ApiGetTimeSeriesDemaRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesDemaRequest) EndDate(endDate string) ApiGetTimeSeriesDemaRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesDemaRequest) Date(date string) ApiGetTimeSeriesDemaRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesDemaRequest) Order(order string) ApiGetTimeSeriesDemaRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesDemaRequest) Prepost(prepost bool) ApiGetTimeSeriesDemaRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesDemaRequest) Format(format string) ApiGetTimeSeriesDemaRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesDemaRequest) Delimiter(delimiter string) ApiGetTimeSeriesDemaRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesDemaRequest) Dp(dp int64) ApiGetTimeSeriesDemaRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesDemaRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesDemaRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesDemaRequest) Adjust(adjust string) ApiGetTimeSeriesDemaRequest {
	r.adjust = &adjust
	return r
}

// Price type on which technical indicator is calculated
func (r ApiGetTimeSeriesDemaRequest) SeriesType(seriesType string) ApiGetTimeSeriesDemaRequest {
	r.seriesType = &seriesType
	return r
}

// Number of periods to average over. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesDemaRequest) TimePeriod(timePeriod int64) ApiGetTimeSeriesDemaRequest {
	r.timePeriod = &timePeriod
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesDemaRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesDemaRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesDemaRequest) Execute() (*GetTimeSeriesDema200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesDemaExecute(r)
}

/*
GetTimeSeriesDema Double exponential moving average

The Double Exponential Moving Average (DEMA) endpoint provides a data series that calculates a moving average with reduced lag by emphasizing recent price data. This endpoint returns time-series data that includes the DEMA values for a specified financial instrument, allowing users to track price trends and identify potential trading opportunities.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesDemaRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesDema(ctx context.Context) ApiGetTimeSeriesDemaRequest {
	return ApiGetTimeSeriesDemaRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesDema200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesDemaExecute(r ApiGetTimeSeriesDemaRequest) (*GetTimeSeriesDema200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesDema200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesDema")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dema"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.seriesType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", r.seriesType, "form", "")
	} else {
        var defaultValue string = "close"
        parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", defaultValue, "form", "")
        r.seriesType = &defaultValue
	}
	if r.timePeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", r.timePeriod, "form", "")
	} else {
        var defaultValue int64 = 9
        parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", defaultValue, "form", "")
        r.timePeriod = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesDivRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	seriesType1 *string
	seriesType2 *string
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesDivRequest) Interval(interval string) ApiGetTimeSeriesDivRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesDivRequest) Symbol(symbol string) ApiGetTimeSeriesDivRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesDivRequest) Isin(isin string) ApiGetTimeSeriesDivRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesDivRequest) Figi(figi string) ApiGetTimeSeriesDivRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesDivRequest) Cusip(cusip string) ApiGetTimeSeriesDivRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesDivRequest) Outputsize(outputsize int64) ApiGetTimeSeriesDivRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesDivRequest) Exchange(exchange string) ApiGetTimeSeriesDivRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesDivRequest) MicCode(micCode string) ApiGetTimeSeriesDivRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesDivRequest) Country(country string) ApiGetTimeSeriesDivRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesDivRequest) Type_(type_ string) ApiGetTimeSeriesDivRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesDivRequest) Timezone(timezone string) ApiGetTimeSeriesDivRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesDivRequest) StartDate(startDate string) ApiGetTimeSeriesDivRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesDivRequest) EndDate(endDate string) ApiGetTimeSeriesDivRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesDivRequest) Date(date string) ApiGetTimeSeriesDivRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesDivRequest) Order(order string) ApiGetTimeSeriesDivRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesDivRequest) Prepost(prepost bool) ApiGetTimeSeriesDivRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesDivRequest) Format(format string) ApiGetTimeSeriesDivRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesDivRequest) Delimiter(delimiter string) ApiGetTimeSeriesDivRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesDivRequest) Dp(dp int64) ApiGetTimeSeriesDivRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesDivRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesDivRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesDivRequest) Adjust(adjust string) ApiGetTimeSeriesDivRequest {
	r.adjust = &adjust
	return r
}

// Price type used as the first part of technical indicator
func (r ApiGetTimeSeriesDivRequest) SeriesType1(seriesType1 string) ApiGetTimeSeriesDivRequest {
	r.seriesType1 = &seriesType1
	return r
}

// Price type used as the second part of technical indicator
func (r ApiGetTimeSeriesDivRequest) SeriesType2(seriesType2 string) ApiGetTimeSeriesDivRequest {
	r.seriesType2 = &seriesType2
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesDivRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesDivRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesDivRequest) Execute() (*GetTimeSeriesDiv200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesDivExecute(r)
}

/*
GetTimeSeriesDiv Division

The Division (DIV) endpoint calculates the result of dividing one data series by another, providing a normalized output. It is commonly used to combine or adjust multiple technical indicators or price data for comparative analysis. This endpoint returns the division results as a time series, allowing users to easily interpret and utilize the normalized data in their financial models or charts.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesDivRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesDiv(ctx context.Context) ApiGetTimeSeriesDivRequest {
	return ApiGetTimeSeriesDivRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesDiv200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesDivExecute(r ApiGetTimeSeriesDivRequest) (*GetTimeSeriesDiv200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesDiv200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesDiv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/div"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.seriesType1 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "series_type_1", r.seriesType1, "form", "")
	} else {
        var defaultValue string = "open"
        parameterAddToHeaderOrQuery(localVarQueryParams, "series_type_1", defaultValue, "form", "")
        r.seriesType1 = &defaultValue
	}
	if r.seriesType2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "series_type_2", r.seriesType2, "form", "")
	} else {
        var defaultValue string = "close"
        parameterAddToHeaderOrQuery(localVarQueryParams, "series_type_2", defaultValue, "form", "")
        r.seriesType2 = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesDpoRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	seriesType *string
	timePeriod *int64
	centered *bool
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesDpoRequest) Interval(interval string) ApiGetTimeSeriesDpoRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesDpoRequest) Symbol(symbol string) ApiGetTimeSeriesDpoRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesDpoRequest) Isin(isin string) ApiGetTimeSeriesDpoRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesDpoRequest) Figi(figi string) ApiGetTimeSeriesDpoRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesDpoRequest) Cusip(cusip string) ApiGetTimeSeriesDpoRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesDpoRequest) Outputsize(outputsize int64) ApiGetTimeSeriesDpoRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesDpoRequest) Exchange(exchange string) ApiGetTimeSeriesDpoRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesDpoRequest) MicCode(micCode string) ApiGetTimeSeriesDpoRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesDpoRequest) Country(country string) ApiGetTimeSeriesDpoRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesDpoRequest) Type_(type_ string) ApiGetTimeSeriesDpoRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesDpoRequest) Timezone(timezone string) ApiGetTimeSeriesDpoRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesDpoRequest) StartDate(startDate string) ApiGetTimeSeriesDpoRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesDpoRequest) EndDate(endDate string) ApiGetTimeSeriesDpoRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesDpoRequest) Date(date string) ApiGetTimeSeriesDpoRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesDpoRequest) Order(order string) ApiGetTimeSeriesDpoRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesDpoRequest) Prepost(prepost bool) ApiGetTimeSeriesDpoRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesDpoRequest) Format(format string) ApiGetTimeSeriesDpoRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesDpoRequest) Delimiter(delimiter string) ApiGetTimeSeriesDpoRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesDpoRequest) Dp(dp int64) ApiGetTimeSeriesDpoRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesDpoRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesDpoRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesDpoRequest) Adjust(adjust string) ApiGetTimeSeriesDpoRequest {
	r.adjust = &adjust
	return r
}

// Price type on which technical indicator is calculated
func (r ApiGetTimeSeriesDpoRequest) SeriesType(seriesType string) ApiGetTimeSeriesDpoRequest {
	r.seriesType = &seriesType
	return r
}

// Number of periods to average over. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesDpoRequest) TimePeriod(timePeriod int64) ApiGetTimeSeriesDpoRequest {
	r.timePeriod = &timePeriod
	return r
}

// Specifies if there should be a shift to match the current price
func (r ApiGetTimeSeriesDpoRequest) Centered(centered bool) ApiGetTimeSeriesDpoRequest {
	r.centered = &centered
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesDpoRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesDpoRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesDpoRequest) Execute() (*GetTimeSeriesDpo200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesDpoExecute(r)
}

/*
GetTimeSeriesDpo Detrended price oscillator

The Detrended Price Oscillator (DPO) endpoint calculates and returns the DPO values for a specified financial instrument over a given time period. This endpoint helps traders by highlighting short-term price cycles and identifying potential overbought or oversold conditions without the influence of long-term trends. The response includes a series of DPO values, which can be used to assess price momentum and cyclical patterns in the market.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesDpoRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesDpo(ctx context.Context) ApiGetTimeSeriesDpoRequest {
	return ApiGetTimeSeriesDpoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesDpo200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesDpoExecute(r ApiGetTimeSeriesDpoRequest) (*GetTimeSeriesDpo200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesDpo200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesDpo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dpo"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.seriesType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", r.seriesType, "form", "")
	} else {
        var defaultValue string = "close"
        parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", defaultValue, "form", "")
        r.seriesType = &defaultValue
	}
	if r.timePeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", r.timePeriod, "form", "")
	} else {
        var defaultValue int64 = 9
        parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", defaultValue, "form", "")
        r.timePeriod = &defaultValue
	}
	if r.centered != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "centered", r.centered, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "centered", defaultValue, "form", "")
        r.centered = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesDxRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	timePeriod *int64
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesDxRequest) Interval(interval string) ApiGetTimeSeriesDxRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesDxRequest) Symbol(symbol string) ApiGetTimeSeriesDxRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesDxRequest) Isin(isin string) ApiGetTimeSeriesDxRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesDxRequest) Figi(figi string) ApiGetTimeSeriesDxRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesDxRequest) Cusip(cusip string) ApiGetTimeSeriesDxRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesDxRequest) Outputsize(outputsize int64) ApiGetTimeSeriesDxRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesDxRequest) Exchange(exchange string) ApiGetTimeSeriesDxRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesDxRequest) MicCode(micCode string) ApiGetTimeSeriesDxRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesDxRequest) Country(country string) ApiGetTimeSeriesDxRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesDxRequest) Type_(type_ string) ApiGetTimeSeriesDxRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesDxRequest) Timezone(timezone string) ApiGetTimeSeriesDxRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesDxRequest) StartDate(startDate string) ApiGetTimeSeriesDxRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesDxRequest) EndDate(endDate string) ApiGetTimeSeriesDxRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesDxRequest) Date(date string) ApiGetTimeSeriesDxRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesDxRequest) Order(order string) ApiGetTimeSeriesDxRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesDxRequest) Prepost(prepost bool) ApiGetTimeSeriesDxRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesDxRequest) Format(format string) ApiGetTimeSeriesDxRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesDxRequest) Delimiter(delimiter string) ApiGetTimeSeriesDxRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesDxRequest) Dp(dp int64) ApiGetTimeSeriesDxRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesDxRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesDxRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesDxRequest) Adjust(adjust string) ApiGetTimeSeriesDxRequest {
	r.adjust = &adjust
	return r
}

// Number of periods to average over. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesDxRequest) TimePeriod(timePeriod int64) ApiGetTimeSeriesDxRequest {
	r.timePeriod = &timePeriod
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesDxRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesDxRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesDxRequest) Execute() (*GetTimeSeriesDx200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesDxExecute(r)
}

/*
GetTimeSeriesDx Directional movement index

Retrieve the Directional Movement Index (DX) values for a given security to assess the strength of its positive and negative price movements. This endpoint provides a time series of DX values, which are useful for evaluating the momentum and trend direction of the security over a specified period.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesDxRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesDx(ctx context.Context) ApiGetTimeSeriesDxRequest {
	return ApiGetTimeSeriesDxRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesDx200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesDxExecute(r ApiGetTimeSeriesDxRequest) (*GetTimeSeriesDx200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesDx200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesDx")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dx"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.timePeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", r.timePeriod, "form", "")
	} else {
        var defaultValue int64 = 14
        parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", defaultValue, "form", "")
        r.timePeriod = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesEmaRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	seriesType *string
	timePeriod *int64
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesEmaRequest) Interval(interval string) ApiGetTimeSeriesEmaRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesEmaRequest) Symbol(symbol string) ApiGetTimeSeriesEmaRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesEmaRequest) Isin(isin string) ApiGetTimeSeriesEmaRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesEmaRequest) Figi(figi string) ApiGetTimeSeriesEmaRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesEmaRequest) Cusip(cusip string) ApiGetTimeSeriesEmaRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesEmaRequest) Outputsize(outputsize int64) ApiGetTimeSeriesEmaRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesEmaRequest) Exchange(exchange string) ApiGetTimeSeriesEmaRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesEmaRequest) MicCode(micCode string) ApiGetTimeSeriesEmaRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesEmaRequest) Country(country string) ApiGetTimeSeriesEmaRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesEmaRequest) Type_(type_ string) ApiGetTimeSeriesEmaRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesEmaRequest) Timezone(timezone string) ApiGetTimeSeriesEmaRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesEmaRequest) StartDate(startDate string) ApiGetTimeSeriesEmaRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesEmaRequest) EndDate(endDate string) ApiGetTimeSeriesEmaRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesEmaRequest) Date(date string) ApiGetTimeSeriesEmaRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesEmaRequest) Order(order string) ApiGetTimeSeriesEmaRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesEmaRequest) Prepost(prepost bool) ApiGetTimeSeriesEmaRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesEmaRequest) Format(format string) ApiGetTimeSeriesEmaRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesEmaRequest) Delimiter(delimiter string) ApiGetTimeSeriesEmaRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesEmaRequest) Dp(dp int64) ApiGetTimeSeriesEmaRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesEmaRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesEmaRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesEmaRequest) Adjust(adjust string) ApiGetTimeSeriesEmaRequest {
	r.adjust = &adjust
	return r
}

// Price type on which technical indicator is calculated
func (r ApiGetTimeSeriesEmaRequest) SeriesType(seriesType string) ApiGetTimeSeriesEmaRequest {
	r.seriesType = &seriesType
	return r
}

// Number of periods to average over. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesEmaRequest) TimePeriod(timePeriod int64) ApiGetTimeSeriesEmaRequest {
	r.timePeriod = &timePeriod
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesEmaRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesEmaRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesEmaRequest) Execute() (*GetTimeSeriesEma200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesEmaExecute(r)
}

/*
GetTimeSeriesEma Exponential moving average

The Exponential Moving Average (EMA) endpoint calculates the EMA for a specified financial instrument over a given time period. It returns a time series of EMA values, which highlight recent price trends by weighting recent data more heavily. This is useful for traders seeking to identify trend directions and potential trade opportunities based on recent price movements.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesEmaRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesEma(ctx context.Context) ApiGetTimeSeriesEmaRequest {
	return ApiGetTimeSeriesEmaRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesEma200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesEmaExecute(r ApiGetTimeSeriesEmaRequest) (*GetTimeSeriesEma200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesEma200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesEma")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ema"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.seriesType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", r.seriesType, "form", "")
	} else {
        var defaultValue string = "close"
        parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", defaultValue, "form", "")
        r.seriesType = &defaultValue
	}
	if r.timePeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", r.timePeriod, "form", "")
	} else {
        var defaultValue int64 = 9
        parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", defaultValue, "form", "")
        r.timePeriod = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesExpRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	seriesType *string
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesExpRequest) Interval(interval string) ApiGetTimeSeriesExpRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesExpRequest) Symbol(symbol string) ApiGetTimeSeriesExpRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesExpRequest) Isin(isin string) ApiGetTimeSeriesExpRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesExpRequest) Figi(figi string) ApiGetTimeSeriesExpRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesExpRequest) Cusip(cusip string) ApiGetTimeSeriesExpRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesExpRequest) Outputsize(outputsize int64) ApiGetTimeSeriesExpRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesExpRequest) Exchange(exchange string) ApiGetTimeSeriesExpRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesExpRequest) MicCode(micCode string) ApiGetTimeSeriesExpRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesExpRequest) Country(country string) ApiGetTimeSeriesExpRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesExpRequest) Type_(type_ string) ApiGetTimeSeriesExpRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesExpRequest) Timezone(timezone string) ApiGetTimeSeriesExpRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesExpRequest) StartDate(startDate string) ApiGetTimeSeriesExpRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesExpRequest) EndDate(endDate string) ApiGetTimeSeriesExpRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesExpRequest) Date(date string) ApiGetTimeSeriesExpRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesExpRequest) Order(order string) ApiGetTimeSeriesExpRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesExpRequest) Prepost(prepost bool) ApiGetTimeSeriesExpRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesExpRequest) Format(format string) ApiGetTimeSeriesExpRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesExpRequest) Delimiter(delimiter string) ApiGetTimeSeriesExpRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesExpRequest) Dp(dp int64) ApiGetTimeSeriesExpRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesExpRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesExpRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesExpRequest) Adjust(adjust string) ApiGetTimeSeriesExpRequest {
	r.adjust = &adjust
	return r
}

// Price type on which technical indicator is calculated
func (r ApiGetTimeSeriesExpRequest) SeriesType(seriesType string) ApiGetTimeSeriesExpRequest {
	r.seriesType = &seriesType
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesExpRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesExpRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesExpRequest) Execute() (*GetTimeSeriesExp200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesExpExecute(r)
}

/*
GetTimeSeriesExp Exponential

The Exponential (EXP) Indicator endpoint computes the exponential value of a specified input, providing a numerical result that is commonly applied in complex mathematical and financial computations.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesExpRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesExp(ctx context.Context) ApiGetTimeSeriesExpRequest {
	return ApiGetTimeSeriesExpRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesExp200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesExpExecute(r ApiGetTimeSeriesExpRequest) (*GetTimeSeriesExp200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesExp200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesExp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/exp"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.seriesType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", r.seriesType, "form", "")
	} else {
        var defaultValue string = "close"
        parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", defaultValue, "form", "")
        r.seriesType = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesFloorRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	seriesType *string
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesFloorRequest) Interval(interval string) ApiGetTimeSeriesFloorRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesFloorRequest) Symbol(symbol string) ApiGetTimeSeriesFloorRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesFloorRequest) Isin(isin string) ApiGetTimeSeriesFloorRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesFloorRequest) Figi(figi string) ApiGetTimeSeriesFloorRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesFloorRequest) Cusip(cusip string) ApiGetTimeSeriesFloorRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesFloorRequest) Outputsize(outputsize int64) ApiGetTimeSeriesFloorRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesFloorRequest) Exchange(exchange string) ApiGetTimeSeriesFloorRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesFloorRequest) MicCode(micCode string) ApiGetTimeSeriesFloorRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesFloorRequest) Country(country string) ApiGetTimeSeriesFloorRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesFloorRequest) Type_(type_ string) ApiGetTimeSeriesFloorRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesFloorRequest) Timezone(timezone string) ApiGetTimeSeriesFloorRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesFloorRequest) StartDate(startDate string) ApiGetTimeSeriesFloorRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesFloorRequest) EndDate(endDate string) ApiGetTimeSeriesFloorRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesFloorRequest) Date(date string) ApiGetTimeSeriesFloorRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesFloorRequest) Order(order string) ApiGetTimeSeriesFloorRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesFloorRequest) Prepost(prepost bool) ApiGetTimeSeriesFloorRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesFloorRequest) Format(format string) ApiGetTimeSeriesFloorRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesFloorRequest) Delimiter(delimiter string) ApiGetTimeSeriesFloorRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesFloorRequest) Dp(dp int64) ApiGetTimeSeriesFloorRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesFloorRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesFloorRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesFloorRequest) Adjust(adjust string) ApiGetTimeSeriesFloorRequest {
	r.adjust = &adjust
	return r
}

// Price type on which technical indicator is calculated
func (r ApiGetTimeSeriesFloorRequest) SeriesType(seriesType string) ApiGetTimeSeriesFloorRequest {
	r.seriesType = &seriesType
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesFloorRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesFloorRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesFloorRequest) Execute() (*GetTimeSeriesFloor200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesFloorExecute(r)
}

/*
GetTimeSeriesFloor Floor

The Floor (FLOOR) endpoint processes numerical input data by rounding each value down to the nearest integer. It returns a series of adjusted data points that can be used for further calculations or combined with other datasets. This endpoint is useful for users needing to simplify data by removing decimal precision, aiding in scenarios where integer values are required.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesFloorRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesFloor(ctx context.Context) ApiGetTimeSeriesFloorRequest {
	return ApiGetTimeSeriesFloorRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesFloor200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesFloorExecute(r ApiGetTimeSeriesFloorRequest) (*GetTimeSeriesFloor200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesFloor200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesFloor")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/floor"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.seriesType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", r.seriesType, "form", "")
	} else {
        var defaultValue string = "close"
        parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", defaultValue, "form", "")
        r.seriesType = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesHeikinashiCandlesRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesHeikinashiCandlesRequest) Interval(interval string) ApiGetTimeSeriesHeikinashiCandlesRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesHeikinashiCandlesRequest) Symbol(symbol string) ApiGetTimeSeriesHeikinashiCandlesRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesHeikinashiCandlesRequest) Isin(isin string) ApiGetTimeSeriesHeikinashiCandlesRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesHeikinashiCandlesRequest) Figi(figi string) ApiGetTimeSeriesHeikinashiCandlesRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesHeikinashiCandlesRequest) Cusip(cusip string) ApiGetTimeSeriesHeikinashiCandlesRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesHeikinashiCandlesRequest) Outputsize(outputsize int64) ApiGetTimeSeriesHeikinashiCandlesRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesHeikinashiCandlesRequest) Exchange(exchange string) ApiGetTimeSeriesHeikinashiCandlesRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesHeikinashiCandlesRequest) MicCode(micCode string) ApiGetTimeSeriesHeikinashiCandlesRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesHeikinashiCandlesRequest) Country(country string) ApiGetTimeSeriesHeikinashiCandlesRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesHeikinashiCandlesRequest) Type_(type_ string) ApiGetTimeSeriesHeikinashiCandlesRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesHeikinashiCandlesRequest) Timezone(timezone string) ApiGetTimeSeriesHeikinashiCandlesRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesHeikinashiCandlesRequest) StartDate(startDate string) ApiGetTimeSeriesHeikinashiCandlesRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesHeikinashiCandlesRequest) EndDate(endDate string) ApiGetTimeSeriesHeikinashiCandlesRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesHeikinashiCandlesRequest) Date(date string) ApiGetTimeSeriesHeikinashiCandlesRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesHeikinashiCandlesRequest) Order(order string) ApiGetTimeSeriesHeikinashiCandlesRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesHeikinashiCandlesRequest) Prepost(prepost bool) ApiGetTimeSeriesHeikinashiCandlesRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesHeikinashiCandlesRequest) Format(format string) ApiGetTimeSeriesHeikinashiCandlesRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesHeikinashiCandlesRequest) Delimiter(delimiter string) ApiGetTimeSeriesHeikinashiCandlesRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesHeikinashiCandlesRequest) Dp(dp int64) ApiGetTimeSeriesHeikinashiCandlesRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesHeikinashiCandlesRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesHeikinashiCandlesRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesHeikinashiCandlesRequest) Adjust(adjust string) ApiGetTimeSeriesHeikinashiCandlesRequest {
	r.adjust = &adjust
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesHeikinashiCandlesRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesHeikinashiCandlesRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesHeikinashiCandlesRequest) Execute() (*GetTimeSeriesHeikinashiCandles200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesHeikinashiCandlesExecute(r)
}

/*
GetTimeSeriesHeikinashiCandles Heikinashi candles

The heikinashi candles endpoint provides smoothed candlestick data by averaging price information to reduce market noise. It returns a series of Heikin Ashi candles, which include open, high, low, and close values, making it easier to identify trends and potential reversals in asset prices. This endpoint is useful for traders and analysts seeking a clearer view of market trends without the volatility present in traditional candlestick charts.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesHeikinashiCandlesRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesHeikinashiCandles(ctx context.Context) ApiGetTimeSeriesHeikinashiCandlesRequest {
	return ApiGetTimeSeriesHeikinashiCandlesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesHeikinashiCandles200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesHeikinashiCandlesExecute(r ApiGetTimeSeriesHeikinashiCandlesRequest) (*GetTimeSeriesHeikinashiCandles200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesHeikinashiCandles200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesHeikinashiCandles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/heikinashicandles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesHlc3Request struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesHlc3Request) Interval(interval string) ApiGetTimeSeriesHlc3Request {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesHlc3Request) Symbol(symbol string) ApiGetTimeSeriesHlc3Request {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesHlc3Request) Isin(isin string) ApiGetTimeSeriesHlc3Request {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesHlc3Request) Figi(figi string) ApiGetTimeSeriesHlc3Request {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesHlc3Request) Cusip(cusip string) ApiGetTimeSeriesHlc3Request {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesHlc3Request) Outputsize(outputsize int64) ApiGetTimeSeriesHlc3Request {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesHlc3Request) Exchange(exchange string) ApiGetTimeSeriesHlc3Request {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesHlc3Request) MicCode(micCode string) ApiGetTimeSeriesHlc3Request {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesHlc3Request) Country(country string) ApiGetTimeSeriesHlc3Request {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesHlc3Request) Type_(type_ string) ApiGetTimeSeriesHlc3Request {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesHlc3Request) Timezone(timezone string) ApiGetTimeSeriesHlc3Request {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesHlc3Request) StartDate(startDate string) ApiGetTimeSeriesHlc3Request {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesHlc3Request) EndDate(endDate string) ApiGetTimeSeriesHlc3Request {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesHlc3Request) Date(date string) ApiGetTimeSeriesHlc3Request {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesHlc3Request) Order(order string) ApiGetTimeSeriesHlc3Request {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesHlc3Request) Prepost(prepost bool) ApiGetTimeSeriesHlc3Request {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesHlc3Request) Format(format string) ApiGetTimeSeriesHlc3Request {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesHlc3Request) Delimiter(delimiter string) ApiGetTimeSeriesHlc3Request {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesHlc3Request) Dp(dp int64) ApiGetTimeSeriesHlc3Request {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesHlc3Request) PreviousClose(previousClose bool) ApiGetTimeSeriesHlc3Request {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesHlc3Request) Adjust(adjust string) ApiGetTimeSeriesHlc3Request {
	r.adjust = &adjust
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesHlc3Request) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesHlc3Request {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesHlc3Request) Execute() (*GetTimeSeriesHlc3200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesHlc3Execute(r)
}

/*
GetTimeSeriesHlc3 High, low, close average

The High, Low, Close Average (HLC3) endpoint calculates and returns the average of a security's high, low, and close prices for a specified period. This endpoint provides a straightforward metric to assess price trends, helping users quickly identify the average price level of a security over time.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesHlc3Request
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesHlc3(ctx context.Context) ApiGetTimeSeriesHlc3Request {
	return ApiGetTimeSeriesHlc3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesHlc3200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesHlc3Execute(r ApiGetTimeSeriesHlc3Request) (*GetTimeSeriesHlc3200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesHlc3200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesHlc3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hlc3"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesHtDcPeriodRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	seriesType *string
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesHtDcPeriodRequest) Interval(interval string) ApiGetTimeSeriesHtDcPeriodRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesHtDcPeriodRequest) Symbol(symbol string) ApiGetTimeSeriesHtDcPeriodRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesHtDcPeriodRequest) Isin(isin string) ApiGetTimeSeriesHtDcPeriodRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesHtDcPeriodRequest) Figi(figi string) ApiGetTimeSeriesHtDcPeriodRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesHtDcPeriodRequest) Cusip(cusip string) ApiGetTimeSeriesHtDcPeriodRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesHtDcPeriodRequest) Outputsize(outputsize int64) ApiGetTimeSeriesHtDcPeriodRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesHtDcPeriodRequest) Exchange(exchange string) ApiGetTimeSeriesHtDcPeriodRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesHtDcPeriodRequest) MicCode(micCode string) ApiGetTimeSeriesHtDcPeriodRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesHtDcPeriodRequest) Country(country string) ApiGetTimeSeriesHtDcPeriodRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesHtDcPeriodRequest) Type_(type_ string) ApiGetTimeSeriesHtDcPeriodRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesHtDcPeriodRequest) Timezone(timezone string) ApiGetTimeSeriesHtDcPeriodRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesHtDcPeriodRequest) StartDate(startDate string) ApiGetTimeSeriesHtDcPeriodRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesHtDcPeriodRequest) EndDate(endDate string) ApiGetTimeSeriesHtDcPeriodRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesHtDcPeriodRequest) Date(date string) ApiGetTimeSeriesHtDcPeriodRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesHtDcPeriodRequest) Order(order string) ApiGetTimeSeriesHtDcPeriodRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesHtDcPeriodRequest) Prepost(prepost bool) ApiGetTimeSeriesHtDcPeriodRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesHtDcPeriodRequest) Format(format string) ApiGetTimeSeriesHtDcPeriodRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesHtDcPeriodRequest) Delimiter(delimiter string) ApiGetTimeSeriesHtDcPeriodRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesHtDcPeriodRequest) Dp(dp int64) ApiGetTimeSeriesHtDcPeriodRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesHtDcPeriodRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesHtDcPeriodRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesHtDcPeriodRequest) Adjust(adjust string) ApiGetTimeSeriesHtDcPeriodRequest {
	r.adjust = &adjust
	return r
}

// Price type on which technical indicator is calculated
func (r ApiGetTimeSeriesHtDcPeriodRequest) SeriesType(seriesType string) ApiGetTimeSeriesHtDcPeriodRequest {
	r.seriesType = &seriesType
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesHtDcPeriodRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesHtDcPeriodRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesHtDcPeriodRequest) Execute() (*GetTimeSeriesHtDcPeriod200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesHtDcPeriodExecute(r)
}

/*
GetTimeSeriesHtDcPeriod Hilbert transform dominant cycle period

The Hilbert Transform Dominant Cycle Period (HT_DCPERIOD) endpoint calculates the dominant cycle length of a financial instrument's price data. It returns a numerical value representing the cycle period, which traders can use to identify prevailing market cycles and adjust their trading strategies accordingly.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesHtDcPeriodRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesHtDcPeriod(ctx context.Context) ApiGetTimeSeriesHtDcPeriodRequest {
	return ApiGetTimeSeriesHtDcPeriodRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesHtDcPeriod200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesHtDcPeriodExecute(r ApiGetTimeSeriesHtDcPeriodRequest) (*GetTimeSeriesHtDcPeriod200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesHtDcPeriod200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesHtDcPeriod")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ht_dcperiod"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.seriesType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", r.seriesType, "form", "")
	} else {
        var defaultValue string = "close"
        parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", defaultValue, "form", "")
        r.seriesType = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesHtDcPhaseRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	seriesType *string
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesHtDcPhaseRequest) Interval(interval string) ApiGetTimeSeriesHtDcPhaseRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesHtDcPhaseRequest) Symbol(symbol string) ApiGetTimeSeriesHtDcPhaseRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesHtDcPhaseRequest) Isin(isin string) ApiGetTimeSeriesHtDcPhaseRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesHtDcPhaseRequest) Figi(figi string) ApiGetTimeSeriesHtDcPhaseRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesHtDcPhaseRequest) Cusip(cusip string) ApiGetTimeSeriesHtDcPhaseRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesHtDcPhaseRequest) Outputsize(outputsize int64) ApiGetTimeSeriesHtDcPhaseRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesHtDcPhaseRequest) Exchange(exchange string) ApiGetTimeSeriesHtDcPhaseRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesHtDcPhaseRequest) MicCode(micCode string) ApiGetTimeSeriesHtDcPhaseRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesHtDcPhaseRequest) Country(country string) ApiGetTimeSeriesHtDcPhaseRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesHtDcPhaseRequest) Type_(type_ string) ApiGetTimeSeriesHtDcPhaseRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesHtDcPhaseRequest) Timezone(timezone string) ApiGetTimeSeriesHtDcPhaseRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesHtDcPhaseRequest) StartDate(startDate string) ApiGetTimeSeriesHtDcPhaseRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesHtDcPhaseRequest) EndDate(endDate string) ApiGetTimeSeriesHtDcPhaseRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesHtDcPhaseRequest) Date(date string) ApiGetTimeSeriesHtDcPhaseRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesHtDcPhaseRequest) Order(order string) ApiGetTimeSeriesHtDcPhaseRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesHtDcPhaseRequest) Prepost(prepost bool) ApiGetTimeSeriesHtDcPhaseRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesHtDcPhaseRequest) Format(format string) ApiGetTimeSeriesHtDcPhaseRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesHtDcPhaseRequest) Delimiter(delimiter string) ApiGetTimeSeriesHtDcPhaseRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesHtDcPhaseRequest) Dp(dp int64) ApiGetTimeSeriesHtDcPhaseRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesHtDcPhaseRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesHtDcPhaseRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesHtDcPhaseRequest) Adjust(adjust string) ApiGetTimeSeriesHtDcPhaseRequest {
	r.adjust = &adjust
	return r
}

// Price type on which technical indicator is calculated
func (r ApiGetTimeSeriesHtDcPhaseRequest) SeriesType(seriesType string) ApiGetTimeSeriesHtDcPhaseRequest {
	r.seriesType = &seriesType
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesHtDcPhaseRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesHtDcPhaseRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesHtDcPhaseRequest) Execute() (*GetTimeSeriesHtDcPhase200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesHtDcPhaseExecute(r)
}

/*
GetTimeSeriesHtDcPhase Hilbert transform dominant cycle phase

The Hilbert Transform Dominant Cycle Phase (HT_DCPHASE) endpoint provides the current phase of the dominant market cycle for a given financial instrument. It returns numerical data indicating the phase angle, which can be used by traders to identify potential market entry and exit points based on cyclical patterns.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesHtDcPhaseRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesHtDcPhase(ctx context.Context) ApiGetTimeSeriesHtDcPhaseRequest {
	return ApiGetTimeSeriesHtDcPhaseRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesHtDcPhase200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesHtDcPhaseExecute(r ApiGetTimeSeriesHtDcPhaseRequest) (*GetTimeSeriesHtDcPhase200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesHtDcPhase200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesHtDcPhase")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ht_dcphase"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.seriesType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", r.seriesType, "form", "")
	} else {
        var defaultValue string = "close"
        parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", defaultValue, "form", "")
        r.seriesType = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesHtPhasorRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	seriesType *string
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesHtPhasorRequest) Interval(interval string) ApiGetTimeSeriesHtPhasorRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesHtPhasorRequest) Symbol(symbol string) ApiGetTimeSeriesHtPhasorRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesHtPhasorRequest) Isin(isin string) ApiGetTimeSeriesHtPhasorRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesHtPhasorRequest) Figi(figi string) ApiGetTimeSeriesHtPhasorRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesHtPhasorRequest) Cusip(cusip string) ApiGetTimeSeriesHtPhasorRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesHtPhasorRequest) Outputsize(outputsize int64) ApiGetTimeSeriesHtPhasorRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesHtPhasorRequest) Exchange(exchange string) ApiGetTimeSeriesHtPhasorRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesHtPhasorRequest) MicCode(micCode string) ApiGetTimeSeriesHtPhasorRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesHtPhasorRequest) Country(country string) ApiGetTimeSeriesHtPhasorRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesHtPhasorRequest) Type_(type_ string) ApiGetTimeSeriesHtPhasorRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesHtPhasorRequest) Timezone(timezone string) ApiGetTimeSeriesHtPhasorRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesHtPhasorRequest) StartDate(startDate string) ApiGetTimeSeriesHtPhasorRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesHtPhasorRequest) EndDate(endDate string) ApiGetTimeSeriesHtPhasorRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesHtPhasorRequest) Date(date string) ApiGetTimeSeriesHtPhasorRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesHtPhasorRequest) Order(order string) ApiGetTimeSeriesHtPhasorRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesHtPhasorRequest) Prepost(prepost bool) ApiGetTimeSeriesHtPhasorRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesHtPhasorRequest) Format(format string) ApiGetTimeSeriesHtPhasorRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesHtPhasorRequest) Delimiter(delimiter string) ApiGetTimeSeriesHtPhasorRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesHtPhasorRequest) Dp(dp int64) ApiGetTimeSeriesHtPhasorRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesHtPhasorRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesHtPhasorRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesHtPhasorRequest) Adjust(adjust string) ApiGetTimeSeriesHtPhasorRequest {
	r.adjust = &adjust
	return r
}

// Price type on which technical indicator is calculated
func (r ApiGetTimeSeriesHtPhasorRequest) SeriesType(seriesType string) ApiGetTimeSeriesHtPhasorRequest {
	r.seriesType = &seriesType
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesHtPhasorRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesHtPhasorRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesHtPhasorRequest) Execute() (*GetTimeSeriesHtPhasor200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesHtPhasorExecute(r)
}

/*
GetTimeSeriesHtPhasor Hilbert transform phasor components

The Hilbert Transform Phasor Components (HT_PHASOR) endpoint analyzes a price series to return two key components: in-phase and quadrature. These components help identify cyclical patterns and the direction of trends in the data. Use this endpoint to gain precise insights into the timing and strength of market cycles, enhancing your ability to track and predict price movements.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesHtPhasorRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesHtPhasor(ctx context.Context) ApiGetTimeSeriesHtPhasorRequest {
	return ApiGetTimeSeriesHtPhasorRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesHtPhasor200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesHtPhasorExecute(r ApiGetTimeSeriesHtPhasorRequest) (*GetTimeSeriesHtPhasor200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesHtPhasor200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesHtPhasor")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ht_phasor"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.seriesType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", r.seriesType, "form", "")
	} else {
        var defaultValue string = "close"
        parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", defaultValue, "form", "")
        r.seriesType = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesHtSineRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	seriesType *string
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesHtSineRequest) Interval(interval string) ApiGetTimeSeriesHtSineRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesHtSineRequest) Symbol(symbol string) ApiGetTimeSeriesHtSineRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesHtSineRequest) Isin(isin string) ApiGetTimeSeriesHtSineRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesHtSineRequest) Figi(figi string) ApiGetTimeSeriesHtSineRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesHtSineRequest) Cusip(cusip string) ApiGetTimeSeriesHtSineRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesHtSineRequest) Outputsize(outputsize int64) ApiGetTimeSeriesHtSineRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesHtSineRequest) Exchange(exchange string) ApiGetTimeSeriesHtSineRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesHtSineRequest) MicCode(micCode string) ApiGetTimeSeriesHtSineRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesHtSineRequest) Country(country string) ApiGetTimeSeriesHtSineRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesHtSineRequest) Type_(type_ string) ApiGetTimeSeriesHtSineRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesHtSineRequest) Timezone(timezone string) ApiGetTimeSeriesHtSineRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesHtSineRequest) StartDate(startDate string) ApiGetTimeSeriesHtSineRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesHtSineRequest) EndDate(endDate string) ApiGetTimeSeriesHtSineRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesHtSineRequest) Date(date string) ApiGetTimeSeriesHtSineRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesHtSineRequest) Order(order string) ApiGetTimeSeriesHtSineRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesHtSineRequest) Prepost(prepost bool) ApiGetTimeSeriesHtSineRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesHtSineRequest) Format(format string) ApiGetTimeSeriesHtSineRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesHtSineRequest) Delimiter(delimiter string) ApiGetTimeSeriesHtSineRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesHtSineRequest) Dp(dp int64) ApiGetTimeSeriesHtSineRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesHtSineRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesHtSineRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesHtSineRequest) Adjust(adjust string) ApiGetTimeSeriesHtSineRequest {
	r.adjust = &adjust
	return r
}

// Price type on which technical indicator is calculated
func (r ApiGetTimeSeriesHtSineRequest) SeriesType(seriesType string) ApiGetTimeSeriesHtSineRequest {
	r.seriesType = &seriesType
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesHtSineRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesHtSineRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesHtSineRequest) Execute() (*GetTimeSeriesHtSine200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesHtSineExecute(r)
}

/*
GetTimeSeriesHtSine Hilbert transform sine wave

The Hilbert Transform Sine Wave (HT_SINE) endpoint provides sine and cosine wave components derived from the dominant market cycle. This data helps traders pinpoint potential market turning points and assess trend directions by analyzing cyclical patterns.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesHtSineRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesHtSine(ctx context.Context) ApiGetTimeSeriesHtSineRequest {
	return ApiGetTimeSeriesHtSineRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesHtSine200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesHtSineExecute(r ApiGetTimeSeriesHtSineRequest) (*GetTimeSeriesHtSine200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesHtSine200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesHtSine")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ht_sine"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.seriesType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", r.seriesType, "form", "")
	} else {
        var defaultValue string = "close"
        parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", defaultValue, "form", "")
        r.seriesType = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesHtTrendModeRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	seriesType *string
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesHtTrendModeRequest) Interval(interval string) ApiGetTimeSeriesHtTrendModeRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesHtTrendModeRequest) Symbol(symbol string) ApiGetTimeSeriesHtTrendModeRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesHtTrendModeRequest) Isin(isin string) ApiGetTimeSeriesHtTrendModeRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesHtTrendModeRequest) Figi(figi string) ApiGetTimeSeriesHtTrendModeRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesHtTrendModeRequest) Cusip(cusip string) ApiGetTimeSeriesHtTrendModeRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesHtTrendModeRequest) Outputsize(outputsize int64) ApiGetTimeSeriesHtTrendModeRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesHtTrendModeRequest) Exchange(exchange string) ApiGetTimeSeriesHtTrendModeRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesHtTrendModeRequest) MicCode(micCode string) ApiGetTimeSeriesHtTrendModeRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesHtTrendModeRequest) Country(country string) ApiGetTimeSeriesHtTrendModeRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesHtTrendModeRequest) Type_(type_ string) ApiGetTimeSeriesHtTrendModeRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesHtTrendModeRequest) Timezone(timezone string) ApiGetTimeSeriesHtTrendModeRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesHtTrendModeRequest) StartDate(startDate string) ApiGetTimeSeriesHtTrendModeRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesHtTrendModeRequest) EndDate(endDate string) ApiGetTimeSeriesHtTrendModeRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesHtTrendModeRequest) Date(date string) ApiGetTimeSeriesHtTrendModeRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesHtTrendModeRequest) Order(order string) ApiGetTimeSeriesHtTrendModeRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesHtTrendModeRequest) Prepost(prepost bool) ApiGetTimeSeriesHtTrendModeRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesHtTrendModeRequest) Format(format string) ApiGetTimeSeriesHtTrendModeRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesHtTrendModeRequest) Delimiter(delimiter string) ApiGetTimeSeriesHtTrendModeRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesHtTrendModeRequest) Dp(dp int64) ApiGetTimeSeriesHtTrendModeRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesHtTrendModeRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesHtTrendModeRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesHtTrendModeRequest) Adjust(adjust string) ApiGetTimeSeriesHtTrendModeRequest {
	r.adjust = &adjust
	return r
}

// Price type on which technical indicator is calculated
func (r ApiGetTimeSeriesHtTrendModeRequest) SeriesType(seriesType string) ApiGetTimeSeriesHtTrendModeRequest {
	r.seriesType = &seriesType
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesHtTrendModeRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesHtTrendModeRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesHtTrendModeRequest) Execute() (*GetTimeSeriesHtTrendMode200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesHtTrendModeExecute(r)
}

/*
GetTimeSeriesHtTrendMode Hilbert transform trend vs cycle mode

The Hilbert Transform Trend vs Cycle Mode (HT_TRENDMODE) endpoint identifies whether a market is in a trending or cyclical phase. It returns data indicating the current market phase, allowing users to adjust their trading strategies based on the prevailing conditions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesHtTrendModeRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesHtTrendMode(ctx context.Context) ApiGetTimeSeriesHtTrendModeRequest {
	return ApiGetTimeSeriesHtTrendModeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesHtTrendMode200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesHtTrendModeExecute(r ApiGetTimeSeriesHtTrendModeRequest) (*GetTimeSeriesHtTrendMode200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesHtTrendMode200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesHtTrendMode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ht_trendmode"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.seriesType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", r.seriesType, "form", "")
	} else {
        var defaultValue string = "close"
        parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", defaultValue, "form", "")
        r.seriesType = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesHtTrendlineRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	seriesType *string
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesHtTrendlineRequest) Interval(interval string) ApiGetTimeSeriesHtTrendlineRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesHtTrendlineRequest) Symbol(symbol string) ApiGetTimeSeriesHtTrendlineRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesHtTrendlineRequest) Isin(isin string) ApiGetTimeSeriesHtTrendlineRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesHtTrendlineRequest) Figi(figi string) ApiGetTimeSeriesHtTrendlineRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesHtTrendlineRequest) Cusip(cusip string) ApiGetTimeSeriesHtTrendlineRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesHtTrendlineRequest) Outputsize(outputsize int64) ApiGetTimeSeriesHtTrendlineRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesHtTrendlineRequest) Exchange(exchange string) ApiGetTimeSeriesHtTrendlineRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesHtTrendlineRequest) MicCode(micCode string) ApiGetTimeSeriesHtTrendlineRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesHtTrendlineRequest) Country(country string) ApiGetTimeSeriesHtTrendlineRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesHtTrendlineRequest) Type_(type_ string) ApiGetTimeSeriesHtTrendlineRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesHtTrendlineRequest) Timezone(timezone string) ApiGetTimeSeriesHtTrendlineRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesHtTrendlineRequest) StartDate(startDate string) ApiGetTimeSeriesHtTrendlineRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesHtTrendlineRequest) EndDate(endDate string) ApiGetTimeSeriesHtTrendlineRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesHtTrendlineRequest) Date(date string) ApiGetTimeSeriesHtTrendlineRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesHtTrendlineRequest) Order(order string) ApiGetTimeSeriesHtTrendlineRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesHtTrendlineRequest) Prepost(prepost bool) ApiGetTimeSeriesHtTrendlineRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesHtTrendlineRequest) Format(format string) ApiGetTimeSeriesHtTrendlineRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesHtTrendlineRequest) Delimiter(delimiter string) ApiGetTimeSeriesHtTrendlineRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesHtTrendlineRequest) Dp(dp int64) ApiGetTimeSeriesHtTrendlineRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesHtTrendlineRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesHtTrendlineRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesHtTrendlineRequest) Adjust(adjust string) ApiGetTimeSeriesHtTrendlineRequest {
	r.adjust = &adjust
	return r
}

// Price type on which technical indicator is calculated
func (r ApiGetTimeSeriesHtTrendlineRequest) SeriesType(seriesType string) ApiGetTimeSeriesHtTrendlineRequest {
	r.seriesType = &seriesType
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesHtTrendlineRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesHtTrendlineRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesHtTrendlineRequest) Execute() (*GetTimeSeriesHtTrendline200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesHtTrendlineExecute(r)
}

/*
GetTimeSeriesHtTrendline Hilbert transform instantaneous trendline

The Hilbert Transform Instantaneous Trendline (HT_TRENDLINE) endpoint provides a smoothed moving average that aligns with the dominant market cycle. It returns data points that help traders identify current market trends and determine potential entry or exit points in trading.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesHtTrendlineRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesHtTrendline(ctx context.Context) ApiGetTimeSeriesHtTrendlineRequest {
	return ApiGetTimeSeriesHtTrendlineRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesHtTrendline200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesHtTrendlineExecute(r ApiGetTimeSeriesHtTrendlineRequest) (*GetTimeSeriesHtTrendline200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesHtTrendline200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesHtTrendline")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ht_trendline"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.seriesType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", r.seriesType, "form", "")
	} else {
        var defaultValue string = "close"
        parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", defaultValue, "form", "")
        r.seriesType = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesIchimokuRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	conversionLinePeriod *int64
	baseLinePeriod *int64
	leadingSpanBPeriod *int64
	laggingSpanPeriod *int64
	includeAheadSpanPeriod *bool
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesIchimokuRequest) Interval(interval string) ApiGetTimeSeriesIchimokuRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesIchimokuRequest) Symbol(symbol string) ApiGetTimeSeriesIchimokuRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesIchimokuRequest) Isin(isin string) ApiGetTimeSeriesIchimokuRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesIchimokuRequest) Figi(figi string) ApiGetTimeSeriesIchimokuRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesIchimokuRequest) Cusip(cusip string) ApiGetTimeSeriesIchimokuRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesIchimokuRequest) Outputsize(outputsize int64) ApiGetTimeSeriesIchimokuRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesIchimokuRequest) Exchange(exchange string) ApiGetTimeSeriesIchimokuRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesIchimokuRequest) MicCode(micCode string) ApiGetTimeSeriesIchimokuRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesIchimokuRequest) Country(country string) ApiGetTimeSeriesIchimokuRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesIchimokuRequest) Type_(type_ string) ApiGetTimeSeriesIchimokuRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesIchimokuRequest) Timezone(timezone string) ApiGetTimeSeriesIchimokuRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesIchimokuRequest) StartDate(startDate string) ApiGetTimeSeriesIchimokuRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesIchimokuRequest) EndDate(endDate string) ApiGetTimeSeriesIchimokuRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesIchimokuRequest) Date(date string) ApiGetTimeSeriesIchimokuRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesIchimokuRequest) Order(order string) ApiGetTimeSeriesIchimokuRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesIchimokuRequest) Prepost(prepost bool) ApiGetTimeSeriesIchimokuRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesIchimokuRequest) Format(format string) ApiGetTimeSeriesIchimokuRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesIchimokuRequest) Delimiter(delimiter string) ApiGetTimeSeriesIchimokuRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesIchimokuRequest) Dp(dp int64) ApiGetTimeSeriesIchimokuRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesIchimokuRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesIchimokuRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesIchimokuRequest) Adjust(adjust string) ApiGetTimeSeriesIchimokuRequest {
	r.adjust = &adjust
	return r
}

// The time period used for generating the conversation line. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesIchimokuRequest) ConversionLinePeriod(conversionLinePeriod int64) ApiGetTimeSeriesIchimokuRequest {
	r.conversionLinePeriod = &conversionLinePeriod
	return r
}

// The time period used for generating the base line. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesIchimokuRequest) BaseLinePeriod(baseLinePeriod int64) ApiGetTimeSeriesIchimokuRequest {
	r.baseLinePeriod = &baseLinePeriod
	return r
}

// The time period used for generating the leading span B line. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesIchimokuRequest) LeadingSpanBPeriod(leadingSpanBPeriod int64) ApiGetTimeSeriesIchimokuRequest {
	r.leadingSpanBPeriod = &leadingSpanBPeriod
	return r
}

// The time period used for generating the lagging span line. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesIchimokuRequest) LaggingSpanPeriod(laggingSpanPeriod int64) ApiGetTimeSeriesIchimokuRequest {
	r.laggingSpanPeriod = &laggingSpanPeriod
	return r
}

// Indicates whether to include ahead span period
func (r ApiGetTimeSeriesIchimokuRequest) IncludeAheadSpanPeriod(includeAheadSpanPeriod bool) ApiGetTimeSeriesIchimokuRequest {
	r.includeAheadSpanPeriod = &includeAheadSpanPeriod
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesIchimokuRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesIchimokuRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesIchimokuRequest) Execute() (*GetTimeSeriesIchimoku200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesIchimokuExecute(r)
}

/*
GetTimeSeriesIchimoku Ichimoku cloud

The Ichimoku Cloud endpoint provides data on the Ichimoku Kinko Hyo indicator, offering insights into trend direction, support and resistance levels, and potential entry and exit points. It returns key components such as the Tenkan-sen, Kijun-sen, Senkou Span A, Senkou Span B, and Chikou Span. This data helps users evaluate market trends and identify strategic trading opportunities.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesIchimokuRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesIchimoku(ctx context.Context) ApiGetTimeSeriesIchimokuRequest {
	return ApiGetTimeSeriesIchimokuRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesIchimoku200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesIchimokuExecute(r ApiGetTimeSeriesIchimokuRequest) (*GetTimeSeriesIchimoku200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesIchimoku200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesIchimoku")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ichimoku"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.conversionLinePeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "conversion_line_period", r.conversionLinePeriod, "form", "")
	} else {
        var defaultValue int64 = 9
        parameterAddToHeaderOrQuery(localVarQueryParams, "conversion_line_period", defaultValue, "form", "")
        r.conversionLinePeriod = &defaultValue
	}
	if r.baseLinePeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "base_line_period", r.baseLinePeriod, "form", "")
	} else {
        var defaultValue int64 = 26
        parameterAddToHeaderOrQuery(localVarQueryParams, "base_line_period", defaultValue, "form", "")
        r.baseLinePeriod = &defaultValue
	}
	if r.leadingSpanBPeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "leading_span_b_period", r.leadingSpanBPeriod, "form", "")
	} else {
        var defaultValue int64 = 52
        parameterAddToHeaderOrQuery(localVarQueryParams, "leading_span_b_period", defaultValue, "form", "")
        r.leadingSpanBPeriod = &defaultValue
	}
	if r.laggingSpanPeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lagging_span_period", r.laggingSpanPeriod, "form", "")
	} else {
        var defaultValue int64 = 26
        parameterAddToHeaderOrQuery(localVarQueryParams, "lagging_span_period", defaultValue, "form", "")
        r.laggingSpanPeriod = &defaultValue
	}
	if r.includeAheadSpanPeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ahead_span_period", r.includeAheadSpanPeriod, "form", "")
	} else {
        var defaultValue bool = true
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ahead_span_period", defaultValue, "form", "")
        r.includeAheadSpanPeriod = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesKamaRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	seriesType *string
	timePeriod *int64
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesKamaRequest) Interval(interval string) ApiGetTimeSeriesKamaRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesKamaRequest) Symbol(symbol string) ApiGetTimeSeriesKamaRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesKamaRequest) Isin(isin string) ApiGetTimeSeriesKamaRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesKamaRequest) Figi(figi string) ApiGetTimeSeriesKamaRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesKamaRequest) Cusip(cusip string) ApiGetTimeSeriesKamaRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesKamaRequest) Outputsize(outputsize int64) ApiGetTimeSeriesKamaRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesKamaRequest) Exchange(exchange string) ApiGetTimeSeriesKamaRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesKamaRequest) MicCode(micCode string) ApiGetTimeSeriesKamaRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesKamaRequest) Country(country string) ApiGetTimeSeriesKamaRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesKamaRequest) Type_(type_ string) ApiGetTimeSeriesKamaRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesKamaRequest) Timezone(timezone string) ApiGetTimeSeriesKamaRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesKamaRequest) StartDate(startDate string) ApiGetTimeSeriesKamaRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesKamaRequest) EndDate(endDate string) ApiGetTimeSeriesKamaRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesKamaRequest) Date(date string) ApiGetTimeSeriesKamaRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesKamaRequest) Order(order string) ApiGetTimeSeriesKamaRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesKamaRequest) Prepost(prepost bool) ApiGetTimeSeriesKamaRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesKamaRequest) Format(format string) ApiGetTimeSeriesKamaRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesKamaRequest) Delimiter(delimiter string) ApiGetTimeSeriesKamaRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesKamaRequest) Dp(dp int64) ApiGetTimeSeriesKamaRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesKamaRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesKamaRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesKamaRequest) Adjust(adjust string) ApiGetTimeSeriesKamaRequest {
	r.adjust = &adjust
	return r
}

// Price type on which technical indicator is calculated
func (r ApiGetTimeSeriesKamaRequest) SeriesType(seriesType string) ApiGetTimeSeriesKamaRequest {
	r.seriesType = &seriesType
	return r
}

// Number of periods to average over. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesKamaRequest) TimePeriod(timePeriod int64) ApiGetTimeSeriesKamaRequest {
	r.timePeriod = &timePeriod
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesKamaRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesKamaRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesKamaRequest) Execute() (*GetTimeSeriesKama200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesKamaExecute(r)
}

/*
GetTimeSeriesKama Kaufman adaptive moving average

The Kaufman Adaptive Moving Average (KAMA) endpoint calculates the KAMA for a specified financial instrument, returning a time series of values that reflect the average price adjusted for market volatility. This endpoint helps users identify trends by smoothing out price fluctuations while remaining sensitive to significant price movements.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesKamaRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesKama(ctx context.Context) ApiGetTimeSeriesKamaRequest {
	return ApiGetTimeSeriesKamaRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesKama200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesKamaExecute(r ApiGetTimeSeriesKamaRequest) (*GetTimeSeriesKama200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesKama200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesKama")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kama"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.seriesType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", r.seriesType, "form", "")
	} else {
        var defaultValue string = "close"
        parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", defaultValue, "form", "")
        r.seriesType = &defaultValue
	}
	if r.timePeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", r.timePeriod, "form", "")
	} else {
        var defaultValue int64 = 9
        parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", defaultValue, "form", "")
        r.timePeriod = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesKeltnerRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	timePeriod *int64
	atrTimePeriod *int64
	multiplier *int64
	seriesType *string
	maType *string
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesKeltnerRequest) Interval(interval string) ApiGetTimeSeriesKeltnerRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesKeltnerRequest) Symbol(symbol string) ApiGetTimeSeriesKeltnerRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesKeltnerRequest) Isin(isin string) ApiGetTimeSeriesKeltnerRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesKeltnerRequest) Figi(figi string) ApiGetTimeSeriesKeltnerRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesKeltnerRequest) Cusip(cusip string) ApiGetTimeSeriesKeltnerRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesKeltnerRequest) Outputsize(outputsize int64) ApiGetTimeSeriesKeltnerRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesKeltnerRequest) Exchange(exchange string) ApiGetTimeSeriesKeltnerRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesKeltnerRequest) MicCode(micCode string) ApiGetTimeSeriesKeltnerRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesKeltnerRequest) Country(country string) ApiGetTimeSeriesKeltnerRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesKeltnerRequest) Type_(type_ string) ApiGetTimeSeriesKeltnerRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesKeltnerRequest) Timezone(timezone string) ApiGetTimeSeriesKeltnerRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesKeltnerRequest) StartDate(startDate string) ApiGetTimeSeriesKeltnerRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesKeltnerRequest) EndDate(endDate string) ApiGetTimeSeriesKeltnerRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesKeltnerRequest) Date(date string) ApiGetTimeSeriesKeltnerRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesKeltnerRequest) Order(order string) ApiGetTimeSeriesKeltnerRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesKeltnerRequest) Prepost(prepost bool) ApiGetTimeSeriesKeltnerRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesKeltnerRequest) Format(format string) ApiGetTimeSeriesKeltnerRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesKeltnerRequest) Delimiter(delimiter string) ApiGetTimeSeriesKeltnerRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesKeltnerRequest) Dp(dp int64) ApiGetTimeSeriesKeltnerRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesKeltnerRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesKeltnerRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesKeltnerRequest) Adjust(adjust string) ApiGetTimeSeriesKeltnerRequest {
	r.adjust = &adjust
	return r
}

// Number of periods to average over. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesKeltnerRequest) TimePeriod(timePeriod int64) ApiGetTimeSeriesKeltnerRequest {
	r.timePeriod = &timePeriod
	return r
}

// The time period used for calculating the Average True Range. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesKeltnerRequest) AtrTimePeriod(atrTimePeriod int64) ApiGetTimeSeriesKeltnerRequest {
	r.atrTimePeriod = &atrTimePeriod
	return r
}

// The factor used to adjust the indicator&#39;s sensitivity
func (r ApiGetTimeSeriesKeltnerRequest) Multiplier(multiplier int64) ApiGetTimeSeriesKeltnerRequest {
	r.multiplier = &multiplier
	return r
}

// Price type on which technical indicator is calculated
func (r ApiGetTimeSeriesKeltnerRequest) SeriesType(seriesType string) ApiGetTimeSeriesKeltnerRequest {
	r.seriesType = &seriesType
	return r
}

// The type of moving average used
func (r ApiGetTimeSeriesKeltnerRequest) MaType(maType string) ApiGetTimeSeriesKeltnerRequest {
	r.maType = &maType
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesKeltnerRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesKeltnerRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesKeltnerRequest) Execute() (*GetTimeSeriesKeltner200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesKeltnerExecute(r)
}

/*
GetTimeSeriesKeltner Keltner channel

The Keltner Channel endpoint provides data for a volatility-based technical indicator that combines the Exponential Moving Average (EMA) and the Average True Range (ATR) to form a channel around a security's price. This endpoint returns the upper, middle, and lower bands of the channel, which can be used to identify potential overbought or oversold conditions, assess trend direction, and detect possible price breakouts.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesKeltnerRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesKeltner(ctx context.Context) ApiGetTimeSeriesKeltnerRequest {
	return ApiGetTimeSeriesKeltnerRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesKeltner200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesKeltnerExecute(r ApiGetTimeSeriesKeltnerRequest) (*GetTimeSeriesKeltner200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesKeltner200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesKeltner")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/keltner"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.timePeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", r.timePeriod, "form", "")
	} else {
        var defaultValue int64 = 20
        parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", defaultValue, "form", "")
        r.timePeriod = &defaultValue
	}
	if r.atrTimePeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atr_time_period", r.atrTimePeriod, "form", "")
	} else {
        var defaultValue int64 = 10
        parameterAddToHeaderOrQuery(localVarQueryParams, "atr_time_period", defaultValue, "form", "")
        r.atrTimePeriod = &defaultValue
	}
	if r.multiplier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "multiplier", r.multiplier, "form", "")
	} else {
        var defaultValue int64 = 2
        parameterAddToHeaderOrQuery(localVarQueryParams, "multiplier", defaultValue, "form", "")
        r.multiplier = &defaultValue
	}
	if r.seriesType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", r.seriesType, "form", "")
	} else {
        var defaultValue string = "close"
        parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", defaultValue, "form", "")
        r.seriesType = &defaultValue
	}
	if r.maType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ma_type", r.maType, "form", "")
	} else {
        var defaultValue string = "SMA"
        parameterAddToHeaderOrQuery(localVarQueryParams, "ma_type", defaultValue, "form", "")
        r.maType = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesKstRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	rocPeriod1 *int64
	rocPeriod2 *int64
	rocPeriod3 *int64
	rocPeriod4 *int64
	smaPeriod1 *int64
	smaPeriod2 *int64
	smaPeriod3 *int64
	smaPeriod4 *int64
	signalPeriod *int64
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesKstRequest) Interval(interval string) ApiGetTimeSeriesKstRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesKstRequest) Symbol(symbol string) ApiGetTimeSeriesKstRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesKstRequest) Isin(isin string) ApiGetTimeSeriesKstRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesKstRequest) Figi(figi string) ApiGetTimeSeriesKstRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesKstRequest) Cusip(cusip string) ApiGetTimeSeriesKstRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesKstRequest) Outputsize(outputsize int64) ApiGetTimeSeriesKstRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesKstRequest) Exchange(exchange string) ApiGetTimeSeriesKstRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesKstRequest) MicCode(micCode string) ApiGetTimeSeriesKstRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesKstRequest) Country(country string) ApiGetTimeSeriesKstRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesKstRequest) Type_(type_ string) ApiGetTimeSeriesKstRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesKstRequest) Timezone(timezone string) ApiGetTimeSeriesKstRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesKstRequest) StartDate(startDate string) ApiGetTimeSeriesKstRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesKstRequest) EndDate(endDate string) ApiGetTimeSeriesKstRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesKstRequest) Date(date string) ApiGetTimeSeriesKstRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesKstRequest) Order(order string) ApiGetTimeSeriesKstRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesKstRequest) Prepost(prepost bool) ApiGetTimeSeriesKstRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesKstRequest) Format(format string) ApiGetTimeSeriesKstRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesKstRequest) Delimiter(delimiter string) ApiGetTimeSeriesKstRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesKstRequest) Dp(dp int64) ApiGetTimeSeriesKstRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesKstRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesKstRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesKstRequest) Adjust(adjust string) ApiGetTimeSeriesKstRequest {
	r.adjust = &adjust
	return r
}

// The time period for the first Rate of Change calculation.
func (r ApiGetTimeSeriesKstRequest) RocPeriod1(rocPeriod1 int64) ApiGetTimeSeriesKstRequest {
	r.rocPeriod1 = &rocPeriod1
	return r
}

// The time period for the second Rate of Change calculation.
func (r ApiGetTimeSeriesKstRequest) RocPeriod2(rocPeriod2 int64) ApiGetTimeSeriesKstRequest {
	r.rocPeriod2 = &rocPeriod2
	return r
}

// The time period for the third Rate of Change calculation.
func (r ApiGetTimeSeriesKstRequest) RocPeriod3(rocPeriod3 int64) ApiGetTimeSeriesKstRequest {
	r.rocPeriod3 = &rocPeriod3
	return r
}

// The time period for the forth Rate of Change calculation.
func (r ApiGetTimeSeriesKstRequest) RocPeriod4(rocPeriod4 int64) ApiGetTimeSeriesKstRequest {
	r.rocPeriod4 = &rocPeriod4
	return r
}

// The time period for the first Simple Moving Average.
func (r ApiGetTimeSeriesKstRequest) SmaPeriod1(smaPeriod1 int64) ApiGetTimeSeriesKstRequest {
	r.smaPeriod1 = &smaPeriod1
	return r
}

// The time period for the second Simple Moving Average.
func (r ApiGetTimeSeriesKstRequest) SmaPeriod2(smaPeriod2 int64) ApiGetTimeSeriesKstRequest {
	r.smaPeriod2 = &smaPeriod2
	return r
}

// The time period for the third Simple Moving Average.
func (r ApiGetTimeSeriesKstRequest) SmaPeriod3(smaPeriod3 int64) ApiGetTimeSeriesKstRequest {
	r.smaPeriod3 = &smaPeriod3
	return r
}

// The time period for the forth Simple Moving Average.
func (r ApiGetTimeSeriesKstRequest) SmaPeriod4(smaPeriod4 int64) ApiGetTimeSeriesKstRequest {
	r.smaPeriod4 = &smaPeriod4
	return r
}

// The time period used for generating the signal line.
func (r ApiGetTimeSeriesKstRequest) SignalPeriod(signalPeriod int64) ApiGetTimeSeriesKstRequest {
	r.signalPeriod = &signalPeriod
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesKstRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesKstRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesKstRequest) Execute() (*GetTimeSeriesKst200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesKstExecute(r)
}

/*
GetTimeSeriesKst Know sure thing

The Know Sure Thing (KST) endpoint provides a momentum oscillator that combines four smoothed rates of change into a single trend-following indicator. This endpoint returns data that helps users identify potential trend reversals, as well as overbought or oversold conditions in the market.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesKstRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesKst(ctx context.Context) ApiGetTimeSeriesKstRequest {
	return ApiGetTimeSeriesKstRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesKst200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesKstExecute(r ApiGetTimeSeriesKstRequest) (*GetTimeSeriesKst200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesKst200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesKst")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kst"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.rocPeriod1 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roc_period_1", r.rocPeriod1, "form", "")
	} else {
        var defaultValue int64 = 10
        parameterAddToHeaderOrQuery(localVarQueryParams, "roc_period_1", defaultValue, "form", "")
        r.rocPeriod1 = &defaultValue
	}
	if r.rocPeriod2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roc_period_2", r.rocPeriod2, "form", "")
	} else {
        var defaultValue int64 = 15
        parameterAddToHeaderOrQuery(localVarQueryParams, "roc_period_2", defaultValue, "form", "")
        r.rocPeriod2 = &defaultValue
	}
	if r.rocPeriod3 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roc_period_3", r.rocPeriod3, "form", "")
	} else {
        var defaultValue int64 = 20
        parameterAddToHeaderOrQuery(localVarQueryParams, "roc_period_3", defaultValue, "form", "")
        r.rocPeriod3 = &defaultValue
	}
	if r.rocPeriod4 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roc_period_4", r.rocPeriod4, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "roc_period_4", defaultValue, "form", "")
        r.rocPeriod4 = &defaultValue
	}
	if r.smaPeriod1 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sma_period_1", r.smaPeriod1, "form", "")
	} else {
        var defaultValue int64 = 10
        parameterAddToHeaderOrQuery(localVarQueryParams, "sma_period_1", defaultValue, "form", "")
        r.smaPeriod1 = &defaultValue
	}
	if r.smaPeriod2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sma_period_2", r.smaPeriod2, "form", "")
	} else {
        var defaultValue int64 = 10
        parameterAddToHeaderOrQuery(localVarQueryParams, "sma_period_2", defaultValue, "form", "")
        r.smaPeriod2 = &defaultValue
	}
	if r.smaPeriod3 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sma_period_3", r.smaPeriod3, "form", "")
	} else {
        var defaultValue int64 = 10
        parameterAddToHeaderOrQuery(localVarQueryParams, "sma_period_3", defaultValue, "form", "")
        r.smaPeriod3 = &defaultValue
	}
	if r.smaPeriod4 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sma_period_4", r.smaPeriod4, "form", "")
	} else {
        var defaultValue int64 = 15
        parameterAddToHeaderOrQuery(localVarQueryParams, "sma_period_4", defaultValue, "form", "")
        r.smaPeriod4 = &defaultValue
	}
	if r.signalPeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "signal_period", r.signalPeriod, "form", "")
	} else {
        var defaultValue int64 = 9
        parameterAddToHeaderOrQuery(localVarQueryParams, "signal_period", defaultValue, "form", "")
        r.signalPeriod = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesLinearRegRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	seriesType *string
	timePeriod *int64
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesLinearRegRequest) Interval(interval string) ApiGetTimeSeriesLinearRegRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesLinearRegRequest) Symbol(symbol string) ApiGetTimeSeriesLinearRegRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesLinearRegRequest) Isin(isin string) ApiGetTimeSeriesLinearRegRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesLinearRegRequest) Figi(figi string) ApiGetTimeSeriesLinearRegRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesLinearRegRequest) Cusip(cusip string) ApiGetTimeSeriesLinearRegRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesLinearRegRequest) Outputsize(outputsize int64) ApiGetTimeSeriesLinearRegRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesLinearRegRequest) Exchange(exchange string) ApiGetTimeSeriesLinearRegRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesLinearRegRequest) MicCode(micCode string) ApiGetTimeSeriesLinearRegRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesLinearRegRequest) Country(country string) ApiGetTimeSeriesLinearRegRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesLinearRegRequest) Type_(type_ string) ApiGetTimeSeriesLinearRegRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesLinearRegRequest) Timezone(timezone string) ApiGetTimeSeriesLinearRegRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesLinearRegRequest) StartDate(startDate string) ApiGetTimeSeriesLinearRegRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesLinearRegRequest) EndDate(endDate string) ApiGetTimeSeriesLinearRegRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesLinearRegRequest) Date(date string) ApiGetTimeSeriesLinearRegRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesLinearRegRequest) Order(order string) ApiGetTimeSeriesLinearRegRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesLinearRegRequest) Prepost(prepost bool) ApiGetTimeSeriesLinearRegRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesLinearRegRequest) Format(format string) ApiGetTimeSeriesLinearRegRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesLinearRegRequest) Delimiter(delimiter string) ApiGetTimeSeriesLinearRegRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesLinearRegRequest) Dp(dp int64) ApiGetTimeSeriesLinearRegRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesLinearRegRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesLinearRegRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesLinearRegRequest) Adjust(adjust string) ApiGetTimeSeriesLinearRegRequest {
	r.adjust = &adjust
	return r
}

// Price type on which technical indicator is calculated
func (r ApiGetTimeSeriesLinearRegRequest) SeriesType(seriesType string) ApiGetTimeSeriesLinearRegRequest {
	r.seriesType = &seriesType
	return r
}

// Number of periods to average over. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesLinearRegRequest) TimePeriod(timePeriod int64) ApiGetTimeSeriesLinearRegRequest {
	r.timePeriod = &timePeriod
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesLinearRegRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesLinearRegRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesLinearRegRequest) Execute() (*GetTimeSeriesLinearReg200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesLinearRegExecute(r)
}

/*
GetTimeSeriesLinearReg Linear regression

The Linear Regression endpoint (LINEARREG) calculates the best-fit straight line through a series of financial data points. It returns the slope and intercept values of this line, allowing users to determine the overall direction of a market trend and identify potential support or resistance levels.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesLinearRegRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesLinearReg(ctx context.Context) ApiGetTimeSeriesLinearRegRequest {
	return ApiGetTimeSeriesLinearRegRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesLinearReg200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesLinearRegExecute(r ApiGetTimeSeriesLinearRegRequest) (*GetTimeSeriesLinearReg200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesLinearReg200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesLinearReg")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/linearreg"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.seriesType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", r.seriesType, "form", "")
	} else {
        var defaultValue string = "close"
        parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", defaultValue, "form", "")
        r.seriesType = &defaultValue
	}
	if r.timePeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", r.timePeriod, "form", "")
	} else {
        var defaultValue int64 = 9
        parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", defaultValue, "form", "")
        r.timePeriod = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesLinearRegAngleRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	seriesType *string
	timePeriod *int64
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesLinearRegAngleRequest) Interval(interval string) ApiGetTimeSeriesLinearRegAngleRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesLinearRegAngleRequest) Symbol(symbol string) ApiGetTimeSeriesLinearRegAngleRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesLinearRegAngleRequest) Isin(isin string) ApiGetTimeSeriesLinearRegAngleRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesLinearRegAngleRequest) Figi(figi string) ApiGetTimeSeriesLinearRegAngleRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesLinearRegAngleRequest) Cusip(cusip string) ApiGetTimeSeriesLinearRegAngleRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesLinearRegAngleRequest) Outputsize(outputsize int64) ApiGetTimeSeriesLinearRegAngleRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesLinearRegAngleRequest) Exchange(exchange string) ApiGetTimeSeriesLinearRegAngleRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesLinearRegAngleRequest) MicCode(micCode string) ApiGetTimeSeriesLinearRegAngleRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesLinearRegAngleRequest) Country(country string) ApiGetTimeSeriesLinearRegAngleRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesLinearRegAngleRequest) Type_(type_ string) ApiGetTimeSeriesLinearRegAngleRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesLinearRegAngleRequest) Timezone(timezone string) ApiGetTimeSeriesLinearRegAngleRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesLinearRegAngleRequest) StartDate(startDate string) ApiGetTimeSeriesLinearRegAngleRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesLinearRegAngleRequest) EndDate(endDate string) ApiGetTimeSeriesLinearRegAngleRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesLinearRegAngleRequest) Date(date string) ApiGetTimeSeriesLinearRegAngleRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesLinearRegAngleRequest) Order(order string) ApiGetTimeSeriesLinearRegAngleRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesLinearRegAngleRequest) Prepost(prepost bool) ApiGetTimeSeriesLinearRegAngleRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesLinearRegAngleRequest) Format(format string) ApiGetTimeSeriesLinearRegAngleRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesLinearRegAngleRequest) Delimiter(delimiter string) ApiGetTimeSeriesLinearRegAngleRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesLinearRegAngleRequest) Dp(dp int64) ApiGetTimeSeriesLinearRegAngleRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesLinearRegAngleRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesLinearRegAngleRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesLinearRegAngleRequest) Adjust(adjust string) ApiGetTimeSeriesLinearRegAngleRequest {
	r.adjust = &adjust
	return r
}

// Price type on which technical indicator is calculated
func (r ApiGetTimeSeriesLinearRegAngleRequest) SeriesType(seriesType string) ApiGetTimeSeriesLinearRegAngleRequest {
	r.seriesType = &seriesType
	return r
}

// Number of periods to average over. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesLinearRegAngleRequest) TimePeriod(timePeriod int64) ApiGetTimeSeriesLinearRegAngleRequest {
	r.timePeriod = &timePeriod
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesLinearRegAngleRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesLinearRegAngleRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesLinearRegAngleRequest) Execute() (*GetTimeSeriesLinearRegAngle200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesLinearRegAngleExecute(r)
}

/*
GetTimeSeriesLinearRegAngle Linear regression angle

The Linear Regression Angle endpoint (LINEARREGANGLE) calculates the angle of the linear regression line for a given time series of stock prices. It returns the slope of the trend line, expressed in degrees, which helps users identify the direction and steepness of a trend over a specified period. This data is useful for detecting upward or downward trends in asset prices.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesLinearRegAngleRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesLinearRegAngle(ctx context.Context) ApiGetTimeSeriesLinearRegAngleRequest {
	return ApiGetTimeSeriesLinearRegAngleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesLinearRegAngle200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesLinearRegAngleExecute(r ApiGetTimeSeriesLinearRegAngleRequest) (*GetTimeSeriesLinearRegAngle200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesLinearRegAngle200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesLinearRegAngle")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/linearregangle"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.seriesType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", r.seriesType, "form", "")
	} else {
        var defaultValue string = "close"
        parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", defaultValue, "form", "")
        r.seriesType = &defaultValue
	}
	if r.timePeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", r.timePeriod, "form", "")
	} else {
        var defaultValue int64 = 9
        parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", defaultValue, "form", "")
        r.timePeriod = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesLinearRegInterceptRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	seriesType *string
	timePeriod *int64
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesLinearRegInterceptRequest) Interval(interval string) ApiGetTimeSeriesLinearRegInterceptRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesLinearRegInterceptRequest) Symbol(symbol string) ApiGetTimeSeriesLinearRegInterceptRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesLinearRegInterceptRequest) Isin(isin string) ApiGetTimeSeriesLinearRegInterceptRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesLinearRegInterceptRequest) Figi(figi string) ApiGetTimeSeriesLinearRegInterceptRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesLinearRegInterceptRequest) Cusip(cusip string) ApiGetTimeSeriesLinearRegInterceptRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesLinearRegInterceptRequest) Outputsize(outputsize int64) ApiGetTimeSeriesLinearRegInterceptRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesLinearRegInterceptRequest) Exchange(exchange string) ApiGetTimeSeriesLinearRegInterceptRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesLinearRegInterceptRequest) MicCode(micCode string) ApiGetTimeSeriesLinearRegInterceptRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesLinearRegInterceptRequest) Country(country string) ApiGetTimeSeriesLinearRegInterceptRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesLinearRegInterceptRequest) Type_(type_ string) ApiGetTimeSeriesLinearRegInterceptRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesLinearRegInterceptRequest) Timezone(timezone string) ApiGetTimeSeriesLinearRegInterceptRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesLinearRegInterceptRequest) StartDate(startDate string) ApiGetTimeSeriesLinearRegInterceptRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesLinearRegInterceptRequest) EndDate(endDate string) ApiGetTimeSeriesLinearRegInterceptRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesLinearRegInterceptRequest) Date(date string) ApiGetTimeSeriesLinearRegInterceptRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesLinearRegInterceptRequest) Order(order string) ApiGetTimeSeriesLinearRegInterceptRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesLinearRegInterceptRequest) Prepost(prepost bool) ApiGetTimeSeriesLinearRegInterceptRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesLinearRegInterceptRequest) Format(format string) ApiGetTimeSeriesLinearRegInterceptRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesLinearRegInterceptRequest) Delimiter(delimiter string) ApiGetTimeSeriesLinearRegInterceptRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesLinearRegInterceptRequest) Dp(dp int64) ApiGetTimeSeriesLinearRegInterceptRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesLinearRegInterceptRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesLinearRegInterceptRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesLinearRegInterceptRequest) Adjust(adjust string) ApiGetTimeSeriesLinearRegInterceptRequest {
	r.adjust = &adjust
	return r
}

// Price type on which technical indicator is calculated
func (r ApiGetTimeSeriesLinearRegInterceptRequest) SeriesType(seriesType string) ApiGetTimeSeriesLinearRegInterceptRequest {
	r.seriesType = &seriesType
	return r
}

// Number of periods to average over. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesLinearRegInterceptRequest) TimePeriod(timePeriod int64) ApiGetTimeSeriesLinearRegInterceptRequest {
	r.timePeriod = &timePeriod
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesLinearRegInterceptRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesLinearRegInterceptRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesLinearRegInterceptRequest) Execute() (*GetTimeSeriesLinearRegIntercept200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesLinearRegInterceptExecute(r)
}

/*
GetTimeSeriesLinearRegIntercept Linear regression intercept

The Linear Regression Intercept endpoint (LINEARREGINTERCEPT) calculates the y-intercept of a linear regression line for a given dataset. It returns the value where the regression line crosses the y-axis, providing a numerical reference point for understanding the starting position of a trend over a specified period. This can be useful for users needing to establish baseline values in their data analysis.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesLinearRegInterceptRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesLinearRegIntercept(ctx context.Context) ApiGetTimeSeriesLinearRegInterceptRequest {
	return ApiGetTimeSeriesLinearRegInterceptRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesLinearRegIntercept200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesLinearRegInterceptExecute(r ApiGetTimeSeriesLinearRegInterceptRequest) (*GetTimeSeriesLinearRegIntercept200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesLinearRegIntercept200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesLinearRegIntercept")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/linearregintercept"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.seriesType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", r.seriesType, "form", "")
	} else {
        var defaultValue string = "close"
        parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", defaultValue, "form", "")
        r.seriesType = &defaultValue
	}
	if r.timePeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", r.timePeriod, "form", "")
	} else {
        var defaultValue int64 = 9
        parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", defaultValue, "form", "")
        r.timePeriod = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesLinearRegSlopeRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	seriesType *string
	timePeriod *int64
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesLinearRegSlopeRequest) Interval(interval string) ApiGetTimeSeriesLinearRegSlopeRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesLinearRegSlopeRequest) Symbol(symbol string) ApiGetTimeSeriesLinearRegSlopeRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesLinearRegSlopeRequest) Isin(isin string) ApiGetTimeSeriesLinearRegSlopeRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesLinearRegSlopeRequest) Figi(figi string) ApiGetTimeSeriesLinearRegSlopeRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesLinearRegSlopeRequest) Cusip(cusip string) ApiGetTimeSeriesLinearRegSlopeRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesLinearRegSlopeRequest) Outputsize(outputsize int64) ApiGetTimeSeriesLinearRegSlopeRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesLinearRegSlopeRequest) Exchange(exchange string) ApiGetTimeSeriesLinearRegSlopeRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesLinearRegSlopeRequest) MicCode(micCode string) ApiGetTimeSeriesLinearRegSlopeRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesLinearRegSlopeRequest) Country(country string) ApiGetTimeSeriesLinearRegSlopeRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesLinearRegSlopeRequest) Type_(type_ string) ApiGetTimeSeriesLinearRegSlopeRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesLinearRegSlopeRequest) Timezone(timezone string) ApiGetTimeSeriesLinearRegSlopeRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesLinearRegSlopeRequest) StartDate(startDate string) ApiGetTimeSeriesLinearRegSlopeRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesLinearRegSlopeRequest) EndDate(endDate string) ApiGetTimeSeriesLinearRegSlopeRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesLinearRegSlopeRequest) Date(date string) ApiGetTimeSeriesLinearRegSlopeRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesLinearRegSlopeRequest) Order(order string) ApiGetTimeSeriesLinearRegSlopeRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesLinearRegSlopeRequest) Prepost(prepost bool) ApiGetTimeSeriesLinearRegSlopeRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesLinearRegSlopeRequest) Format(format string) ApiGetTimeSeriesLinearRegSlopeRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesLinearRegSlopeRequest) Delimiter(delimiter string) ApiGetTimeSeriesLinearRegSlopeRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesLinearRegSlopeRequest) Dp(dp int64) ApiGetTimeSeriesLinearRegSlopeRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesLinearRegSlopeRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesLinearRegSlopeRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesLinearRegSlopeRequest) Adjust(adjust string) ApiGetTimeSeriesLinearRegSlopeRequest {
	r.adjust = &adjust
	return r
}

// Price type on which technical indicator is calculated
func (r ApiGetTimeSeriesLinearRegSlopeRequest) SeriesType(seriesType string) ApiGetTimeSeriesLinearRegSlopeRequest {
	r.seriesType = &seriesType
	return r
}

// Number of periods to average over. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesLinearRegSlopeRequest) TimePeriod(timePeriod int64) ApiGetTimeSeriesLinearRegSlopeRequest {
	r.timePeriod = &timePeriod
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesLinearRegSlopeRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesLinearRegSlopeRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesLinearRegSlopeRequest) Execute() (*GetTimeSeriesLinearRegSlope200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesLinearRegSlopeExecute(r)
}

/*
GetTimeSeriesLinearRegSlope Linear regression slope

The Linear Regression Slope endpoint (LINEARREGSLOPE) calculates the slope of a linear regression line for a given dataset, reflecting the rate of change in the data trend over a specified period. It returns a numerical value representing this slope, which can be used to assess the direction and strength of the trend in the dataset.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesLinearRegSlopeRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesLinearRegSlope(ctx context.Context) ApiGetTimeSeriesLinearRegSlopeRequest {
	return ApiGetTimeSeriesLinearRegSlopeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesLinearRegSlope200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesLinearRegSlopeExecute(r ApiGetTimeSeriesLinearRegSlopeRequest) (*GetTimeSeriesLinearRegSlope200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesLinearRegSlope200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesLinearRegSlope")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/linearregslope"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.seriesType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", r.seriesType, "form", "")
	} else {
        var defaultValue string = "close"
        parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", defaultValue, "form", "")
        r.seriesType = &defaultValue
	}
	if r.timePeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", r.timePeriod, "form", "")
	} else {
        var defaultValue int64 = 9
        parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", defaultValue, "form", "")
        r.timePeriod = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesLnRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	seriesType *string
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesLnRequest) Interval(interval string) ApiGetTimeSeriesLnRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesLnRequest) Symbol(symbol string) ApiGetTimeSeriesLnRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesLnRequest) Isin(isin string) ApiGetTimeSeriesLnRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesLnRequest) Figi(figi string) ApiGetTimeSeriesLnRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesLnRequest) Cusip(cusip string) ApiGetTimeSeriesLnRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesLnRequest) Outputsize(outputsize int64) ApiGetTimeSeriesLnRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesLnRequest) Exchange(exchange string) ApiGetTimeSeriesLnRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesLnRequest) MicCode(micCode string) ApiGetTimeSeriesLnRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesLnRequest) Country(country string) ApiGetTimeSeriesLnRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesLnRequest) Type_(type_ string) ApiGetTimeSeriesLnRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesLnRequest) Timezone(timezone string) ApiGetTimeSeriesLnRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesLnRequest) StartDate(startDate string) ApiGetTimeSeriesLnRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesLnRequest) EndDate(endDate string) ApiGetTimeSeriesLnRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesLnRequest) Date(date string) ApiGetTimeSeriesLnRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesLnRequest) Order(order string) ApiGetTimeSeriesLnRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesLnRequest) Prepost(prepost bool) ApiGetTimeSeriesLnRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesLnRequest) Format(format string) ApiGetTimeSeriesLnRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesLnRequest) Delimiter(delimiter string) ApiGetTimeSeriesLnRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesLnRequest) Dp(dp int64) ApiGetTimeSeriesLnRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesLnRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesLnRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesLnRequest) Adjust(adjust string) ApiGetTimeSeriesLnRequest {
	r.adjust = &adjust
	return r
}

// Price type on which technical indicator is calculated
func (r ApiGetTimeSeriesLnRequest) SeriesType(seriesType string) ApiGetTimeSeriesLnRequest {
	r.seriesType = &seriesType
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesLnRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesLnRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesLnRequest) Execute() (*GetTimeSeriesLn200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesLnExecute(r)
}

/*
GetTimeSeriesLn Natural logarithm

The Natural Logarithm (LN) endpoint computes the natural logarithm of a specified input value, returning a numerical result. This endpoint is useful for users needing to perform logarithmic transformations on data, which can be applied in various financial calculations and advanced mathematical analyses.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesLnRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesLn(ctx context.Context) ApiGetTimeSeriesLnRequest {
	return ApiGetTimeSeriesLnRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesLn200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesLnExecute(r ApiGetTimeSeriesLnRequest) (*GetTimeSeriesLn200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesLn200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesLn")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ln"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.seriesType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", r.seriesType, "form", "")
	} else {
        var defaultValue string = "close"
        parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", defaultValue, "form", "")
        r.seriesType = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesLog10Request struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	seriesType *string
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesLog10Request) Interval(interval string) ApiGetTimeSeriesLog10Request {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesLog10Request) Symbol(symbol string) ApiGetTimeSeriesLog10Request {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesLog10Request) Isin(isin string) ApiGetTimeSeriesLog10Request {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesLog10Request) Figi(figi string) ApiGetTimeSeriesLog10Request {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesLog10Request) Cusip(cusip string) ApiGetTimeSeriesLog10Request {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesLog10Request) Outputsize(outputsize int64) ApiGetTimeSeriesLog10Request {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesLog10Request) Exchange(exchange string) ApiGetTimeSeriesLog10Request {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesLog10Request) MicCode(micCode string) ApiGetTimeSeriesLog10Request {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesLog10Request) Country(country string) ApiGetTimeSeriesLog10Request {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesLog10Request) Type_(type_ string) ApiGetTimeSeriesLog10Request {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesLog10Request) Timezone(timezone string) ApiGetTimeSeriesLog10Request {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesLog10Request) StartDate(startDate string) ApiGetTimeSeriesLog10Request {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesLog10Request) EndDate(endDate string) ApiGetTimeSeriesLog10Request {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesLog10Request) Date(date string) ApiGetTimeSeriesLog10Request {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesLog10Request) Order(order string) ApiGetTimeSeriesLog10Request {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesLog10Request) Prepost(prepost bool) ApiGetTimeSeriesLog10Request {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesLog10Request) Format(format string) ApiGetTimeSeriesLog10Request {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesLog10Request) Delimiter(delimiter string) ApiGetTimeSeriesLog10Request {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesLog10Request) Dp(dp int64) ApiGetTimeSeriesLog10Request {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesLog10Request) PreviousClose(previousClose bool) ApiGetTimeSeriesLog10Request {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesLog10Request) Adjust(adjust string) ApiGetTimeSeriesLog10Request {
	r.adjust = &adjust
	return r
}

// Price type on which technical indicator is calculated
func (r ApiGetTimeSeriesLog10Request) SeriesType(seriesType string) ApiGetTimeSeriesLog10Request {
	r.seriesType = &seriesType
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesLog10Request) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesLog10Request {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesLog10Request) Execute() (*GetTimeSeriesLog10200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesLog10Execute(r)
}

/*
GetTimeSeriesLog10 Base-10 logarithm

The Base-10 Logarithm (LOG10) endpoint computes the base-10 logarithm of a specified input value. It returns a numerical result that represents the power to which the number 10 must be raised to obtain the input value. This endpoint is useful for transforming data into a logarithmic scale, which can simplify the analysis of exponential growth patterns or compress large ranges of data in financial calculations.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesLog10Request
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesLog10(ctx context.Context) ApiGetTimeSeriesLog10Request {
	return ApiGetTimeSeriesLog10Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesLog10200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesLog10Execute(r ApiGetTimeSeriesLog10Request) (*GetTimeSeriesLog10200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesLog10200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesLog10")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/log10"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.seriesType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", r.seriesType, "form", "")
	} else {
        var defaultValue string = "close"
        parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", defaultValue, "form", "")
        r.seriesType = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesMaRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	seriesType *string
	timePeriod *int64
	maType *string
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesMaRequest) Interval(interval string) ApiGetTimeSeriesMaRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesMaRequest) Symbol(symbol string) ApiGetTimeSeriesMaRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesMaRequest) Isin(isin string) ApiGetTimeSeriesMaRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesMaRequest) Figi(figi string) ApiGetTimeSeriesMaRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesMaRequest) Cusip(cusip string) ApiGetTimeSeriesMaRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesMaRequest) Outputsize(outputsize int64) ApiGetTimeSeriesMaRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesMaRequest) Exchange(exchange string) ApiGetTimeSeriesMaRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesMaRequest) MicCode(micCode string) ApiGetTimeSeriesMaRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesMaRequest) Country(country string) ApiGetTimeSeriesMaRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesMaRequest) Type_(type_ string) ApiGetTimeSeriesMaRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesMaRequest) Timezone(timezone string) ApiGetTimeSeriesMaRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesMaRequest) StartDate(startDate string) ApiGetTimeSeriesMaRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesMaRequest) EndDate(endDate string) ApiGetTimeSeriesMaRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesMaRequest) Date(date string) ApiGetTimeSeriesMaRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesMaRequest) Order(order string) ApiGetTimeSeriesMaRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesMaRequest) Prepost(prepost bool) ApiGetTimeSeriesMaRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesMaRequest) Format(format string) ApiGetTimeSeriesMaRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesMaRequest) Delimiter(delimiter string) ApiGetTimeSeriesMaRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesMaRequest) Dp(dp int64) ApiGetTimeSeriesMaRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesMaRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesMaRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesMaRequest) Adjust(adjust string) ApiGetTimeSeriesMaRequest {
	r.adjust = &adjust
	return r
}

// Price type on which technical indicator is calculated
func (r ApiGetTimeSeriesMaRequest) SeriesType(seriesType string) ApiGetTimeSeriesMaRequest {
	r.seriesType = &seriesType
	return r
}

// Number of periods to average over. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesMaRequest) TimePeriod(timePeriod int64) ApiGetTimeSeriesMaRequest {
	r.timePeriod = &timePeriod
	return r
}

// The type of moving average used
func (r ApiGetTimeSeriesMaRequest) MaType(maType string) ApiGetTimeSeriesMaRequest {
	r.maType = &maType
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesMaRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesMaRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesMaRequest) Execute() (*GetTimeSeriesMa200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesMaExecute(r)
}

/*
GetTimeSeriesMa Moving average

The Moving Average (MA) endpoint provides the average price of a security over a specified time frame, offering a smoothed representation of price data. This endpoint returns the calculated moving average values, which can assist users in identifying price trends and potential support or resistance levels in the market.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesMaRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesMa(ctx context.Context) ApiGetTimeSeriesMaRequest {
	return ApiGetTimeSeriesMaRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesMa200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesMaExecute(r ApiGetTimeSeriesMaRequest) (*GetTimeSeriesMa200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesMa200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesMa")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ma"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.seriesType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", r.seriesType, "form", "")
	} else {
        var defaultValue string = "close"
        parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", defaultValue, "form", "")
        r.seriesType = &defaultValue
	}
	if r.timePeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", r.timePeriod, "form", "")
	} else {
        var defaultValue int64 = 9
        parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", defaultValue, "form", "")
        r.timePeriod = &defaultValue
	}
	if r.maType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ma_type", r.maType, "form", "")
	} else {
        var defaultValue string = "SMA"
        parameterAddToHeaderOrQuery(localVarQueryParams, "ma_type", defaultValue, "form", "")
        r.maType = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesMacdRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	seriesType *string
	fastPeriod *int64
	slowPeriod *int64
	signalPeriod *int64
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesMacdRequest) Interval(interval string) ApiGetTimeSeriesMacdRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesMacdRequest) Symbol(symbol string) ApiGetTimeSeriesMacdRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesMacdRequest) Isin(isin string) ApiGetTimeSeriesMacdRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesMacdRequest) Figi(figi string) ApiGetTimeSeriesMacdRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesMacdRequest) Cusip(cusip string) ApiGetTimeSeriesMacdRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesMacdRequest) Outputsize(outputsize int64) ApiGetTimeSeriesMacdRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesMacdRequest) Exchange(exchange string) ApiGetTimeSeriesMacdRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesMacdRequest) MicCode(micCode string) ApiGetTimeSeriesMacdRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesMacdRequest) Country(country string) ApiGetTimeSeriesMacdRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesMacdRequest) Type_(type_ string) ApiGetTimeSeriesMacdRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesMacdRequest) Timezone(timezone string) ApiGetTimeSeriesMacdRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesMacdRequest) StartDate(startDate string) ApiGetTimeSeriesMacdRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesMacdRequest) EndDate(endDate string) ApiGetTimeSeriesMacdRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesMacdRequest) Date(date string) ApiGetTimeSeriesMacdRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesMacdRequest) Order(order string) ApiGetTimeSeriesMacdRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesMacdRequest) Prepost(prepost bool) ApiGetTimeSeriesMacdRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesMacdRequest) Format(format string) ApiGetTimeSeriesMacdRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesMacdRequest) Delimiter(delimiter string) ApiGetTimeSeriesMacdRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesMacdRequest) Dp(dp int64) ApiGetTimeSeriesMacdRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesMacdRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesMacdRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesMacdRequest) Adjust(adjust string) ApiGetTimeSeriesMacdRequest {
	r.adjust = &adjust
	return r
}

// Price type on which technical indicator is calculated
func (r ApiGetTimeSeriesMacdRequest) SeriesType(seriesType string) ApiGetTimeSeriesMacdRequest {
	r.seriesType = &seriesType
	return r
}

// Number of periods for fast moving average. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesMacdRequest) FastPeriod(fastPeriod int64) ApiGetTimeSeriesMacdRequest {
	r.fastPeriod = &fastPeriod
	return r
}

// Number of periods for slow moving average. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesMacdRequest) SlowPeriod(slowPeriod int64) ApiGetTimeSeriesMacdRequest {
	r.slowPeriod = &slowPeriod
	return r
}

// The time period used for generating the signal line.
func (r ApiGetTimeSeriesMacdRequest) SignalPeriod(signalPeriod int64) ApiGetTimeSeriesMacdRequest {
	r.signalPeriod = &signalPeriod
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesMacdRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesMacdRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesMacdRequest) Execute() (*GetTimeSeriesMacd200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesMacdExecute(r)
}

/*
GetTimeSeriesMacd Moving average convergence divergence

This endpoint calculates the Moving Average Convergence Divergence (MACD) for a specified financial instrument. It returns the MACD line, signal line, and histogram values, which help users identify potential trend reversals and trading opportunities by analyzing the relationship between two moving averages.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesMacdRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesMacd(ctx context.Context) ApiGetTimeSeriesMacdRequest {
	return ApiGetTimeSeriesMacdRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesMacd200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesMacdExecute(r ApiGetTimeSeriesMacdRequest) (*GetTimeSeriesMacd200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesMacd200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesMacd")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/macd"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.seriesType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", r.seriesType, "form", "")
	} else {
        var defaultValue string = "close"
        parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", defaultValue, "form", "")
        r.seriesType = &defaultValue
	}
	if r.fastPeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fast_period", r.fastPeriod, "form", "")
	} else {
        var defaultValue int64 = 12
        parameterAddToHeaderOrQuery(localVarQueryParams, "fast_period", defaultValue, "form", "")
        r.fastPeriod = &defaultValue
	}
	if r.slowPeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "slow_period", r.slowPeriod, "form", "")
	} else {
        var defaultValue int64 = 26
        parameterAddToHeaderOrQuery(localVarQueryParams, "slow_period", defaultValue, "form", "")
        r.slowPeriod = &defaultValue
	}
	if r.signalPeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "signal_period", r.signalPeriod, "form", "")
	} else {
        var defaultValue int64 = 9
        parameterAddToHeaderOrQuery(localVarQueryParams, "signal_period", defaultValue, "form", "")
        r.signalPeriod = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesMacdExtRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	seriesType *string
	fastPeriod *int64
	fastMaType *string
	slowPeriod *int64
	slowMaType *string
	signalPeriod *int64
	signalMaType *string
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesMacdExtRequest) Interval(interval string) ApiGetTimeSeriesMacdExtRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesMacdExtRequest) Symbol(symbol string) ApiGetTimeSeriesMacdExtRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesMacdExtRequest) Isin(isin string) ApiGetTimeSeriesMacdExtRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesMacdExtRequest) Figi(figi string) ApiGetTimeSeriesMacdExtRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesMacdExtRequest) Cusip(cusip string) ApiGetTimeSeriesMacdExtRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesMacdExtRequest) Outputsize(outputsize int64) ApiGetTimeSeriesMacdExtRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesMacdExtRequest) Exchange(exchange string) ApiGetTimeSeriesMacdExtRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesMacdExtRequest) MicCode(micCode string) ApiGetTimeSeriesMacdExtRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesMacdExtRequest) Country(country string) ApiGetTimeSeriesMacdExtRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesMacdExtRequest) Type_(type_ string) ApiGetTimeSeriesMacdExtRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesMacdExtRequest) Timezone(timezone string) ApiGetTimeSeriesMacdExtRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesMacdExtRequest) StartDate(startDate string) ApiGetTimeSeriesMacdExtRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesMacdExtRequest) EndDate(endDate string) ApiGetTimeSeriesMacdExtRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesMacdExtRequest) Date(date string) ApiGetTimeSeriesMacdExtRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesMacdExtRequest) Order(order string) ApiGetTimeSeriesMacdExtRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesMacdExtRequest) Prepost(prepost bool) ApiGetTimeSeriesMacdExtRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesMacdExtRequest) Format(format string) ApiGetTimeSeriesMacdExtRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesMacdExtRequest) Delimiter(delimiter string) ApiGetTimeSeriesMacdExtRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesMacdExtRequest) Dp(dp int64) ApiGetTimeSeriesMacdExtRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesMacdExtRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesMacdExtRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesMacdExtRequest) Adjust(adjust string) ApiGetTimeSeriesMacdExtRequest {
	r.adjust = &adjust
	return r
}

// Price type on which technical indicator is calculated
func (r ApiGetTimeSeriesMacdExtRequest) SeriesType(seriesType string) ApiGetTimeSeriesMacdExtRequest {
	r.seriesType = &seriesType
	return r
}

// Number of periods for fast moving average. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesMacdExtRequest) FastPeriod(fastPeriod int64) ApiGetTimeSeriesMacdExtRequest {
	r.fastPeriod = &fastPeriod
	return r
}

// The type of fast moving average used in the calculation.
func (r ApiGetTimeSeriesMacdExtRequest) FastMaType(fastMaType string) ApiGetTimeSeriesMacdExtRequest {
	r.fastMaType = &fastMaType
	return r
}

// Number of periods for slow moving average. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesMacdExtRequest) SlowPeriod(slowPeriod int64) ApiGetTimeSeriesMacdExtRequest {
	r.slowPeriod = &slowPeriod
	return r
}

// The type of slow moving average used in the calculation.
func (r ApiGetTimeSeriesMacdExtRequest) SlowMaType(slowMaType string) ApiGetTimeSeriesMacdExtRequest {
	r.slowMaType = &slowMaType
	return r
}

// The time period used for generating the signal line.
func (r ApiGetTimeSeriesMacdExtRequest) SignalPeriod(signalPeriod int64) ApiGetTimeSeriesMacdExtRequest {
	r.signalPeriod = &signalPeriod
	return r
}

// The type of fast moving average used for generating the signal line.
func (r ApiGetTimeSeriesMacdExtRequest) SignalMaType(signalMaType string) ApiGetTimeSeriesMacdExtRequest {
	r.signalMaType = &signalMaType
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesMacdExtRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesMacdExtRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesMacdExtRequest) Execute() (*GetTimeSeriesMacdExt200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesMacdExtExecute(r)
}

/*
GetTimeSeriesMacdExt Moving average convergence divergence extension

The Moving Average Convergence Divergence Extension (MACDEXT) endpoint provides a customizable version of the MACD indicator, allowing users to specify different moving average types and parameters. It returns data that includes the MACD line, signal line, and histogram values, tailored to the user's chosen settings. This endpoint is useful for traders who require flexibility in analyzing price trends and momentum by adjusting the calculation methods to fit their specific trading strategies.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesMacdExtRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesMacdExt(ctx context.Context) ApiGetTimeSeriesMacdExtRequest {
	return ApiGetTimeSeriesMacdExtRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesMacdExt200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesMacdExtExecute(r ApiGetTimeSeriesMacdExtRequest) (*GetTimeSeriesMacdExt200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesMacdExt200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesMacdExt")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/macdext"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.seriesType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", r.seriesType, "form", "")
	} else {
        var defaultValue string = "close"
        parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", defaultValue, "form", "")
        r.seriesType = &defaultValue
	}
	if r.fastPeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fast_period", r.fastPeriod, "form", "")
	} else {
        var defaultValue int64 = 12
        parameterAddToHeaderOrQuery(localVarQueryParams, "fast_period", defaultValue, "form", "")
        r.fastPeriod = &defaultValue
	}
	if r.fastMaType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fast_ma_type", r.fastMaType, "form", "")
	} else {
        var defaultValue string = "SMA"
        parameterAddToHeaderOrQuery(localVarQueryParams, "fast_ma_type", defaultValue, "form", "")
        r.fastMaType = &defaultValue
	}
	if r.slowPeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "slow_period", r.slowPeriod, "form", "")
	} else {
        var defaultValue int64 = 26
        parameterAddToHeaderOrQuery(localVarQueryParams, "slow_period", defaultValue, "form", "")
        r.slowPeriod = &defaultValue
	}
	if r.slowMaType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "slow_ma_type", r.slowMaType, "form", "")
	} else {
        var defaultValue string = "SMA"
        parameterAddToHeaderOrQuery(localVarQueryParams, "slow_ma_type", defaultValue, "form", "")
        r.slowMaType = &defaultValue
	}
	if r.signalPeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "signal_period", r.signalPeriod, "form", "")
	} else {
        var defaultValue int64 = 9
        parameterAddToHeaderOrQuery(localVarQueryParams, "signal_period", defaultValue, "form", "")
        r.signalPeriod = &defaultValue
	}
	if r.signalMaType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "signal_ma_type", r.signalMaType, "form", "")
	} else {
        var defaultValue string = "SMA"
        parameterAddToHeaderOrQuery(localVarQueryParams, "signal_ma_type", defaultValue, "form", "")
        r.signalMaType = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesMacdSlopeRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	seriesType *string
	fastPeriod *int64
	slowPeriod *int64
	signalPeriod *int64
	timePeriod *int64
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesMacdSlopeRequest) Interval(interval string) ApiGetTimeSeriesMacdSlopeRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesMacdSlopeRequest) Symbol(symbol string) ApiGetTimeSeriesMacdSlopeRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesMacdSlopeRequest) Isin(isin string) ApiGetTimeSeriesMacdSlopeRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesMacdSlopeRequest) Figi(figi string) ApiGetTimeSeriesMacdSlopeRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesMacdSlopeRequest) Cusip(cusip string) ApiGetTimeSeriesMacdSlopeRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesMacdSlopeRequest) Outputsize(outputsize int64) ApiGetTimeSeriesMacdSlopeRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesMacdSlopeRequest) Exchange(exchange string) ApiGetTimeSeriesMacdSlopeRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesMacdSlopeRequest) MicCode(micCode string) ApiGetTimeSeriesMacdSlopeRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesMacdSlopeRequest) Country(country string) ApiGetTimeSeriesMacdSlopeRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesMacdSlopeRequest) Type_(type_ string) ApiGetTimeSeriesMacdSlopeRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesMacdSlopeRequest) Timezone(timezone string) ApiGetTimeSeriesMacdSlopeRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesMacdSlopeRequest) StartDate(startDate string) ApiGetTimeSeriesMacdSlopeRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesMacdSlopeRequest) EndDate(endDate string) ApiGetTimeSeriesMacdSlopeRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesMacdSlopeRequest) Date(date string) ApiGetTimeSeriesMacdSlopeRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesMacdSlopeRequest) Order(order string) ApiGetTimeSeriesMacdSlopeRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesMacdSlopeRequest) Prepost(prepost bool) ApiGetTimeSeriesMacdSlopeRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesMacdSlopeRequest) Format(format string) ApiGetTimeSeriesMacdSlopeRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesMacdSlopeRequest) Delimiter(delimiter string) ApiGetTimeSeriesMacdSlopeRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesMacdSlopeRequest) Dp(dp int64) ApiGetTimeSeriesMacdSlopeRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesMacdSlopeRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesMacdSlopeRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesMacdSlopeRequest) Adjust(adjust string) ApiGetTimeSeriesMacdSlopeRequest {
	r.adjust = &adjust
	return r
}

// Price type on which technical indicator is calculated
func (r ApiGetTimeSeriesMacdSlopeRequest) SeriesType(seriesType string) ApiGetTimeSeriesMacdSlopeRequest {
	r.seriesType = &seriesType
	return r
}

// Number of periods for fast moving average. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesMacdSlopeRequest) FastPeriod(fastPeriod int64) ApiGetTimeSeriesMacdSlopeRequest {
	r.fastPeriod = &fastPeriod
	return r
}

// Number of periods for slow moving average. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesMacdSlopeRequest) SlowPeriod(slowPeriod int64) ApiGetTimeSeriesMacdSlopeRequest {
	r.slowPeriod = &slowPeriod
	return r
}

// The time period used for generating the signal line.
func (r ApiGetTimeSeriesMacdSlopeRequest) SignalPeriod(signalPeriod int64) ApiGetTimeSeriesMacdSlopeRequest {
	r.signalPeriod = &signalPeriod
	return r
}

// Number of periods to average over. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesMacdSlopeRequest) TimePeriod(timePeriod int64) ApiGetTimeSeriesMacdSlopeRequest {
	r.timePeriod = &timePeriod
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesMacdSlopeRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesMacdSlopeRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesMacdSlopeRequest) Execute() (*GetTimeSeriesMacdSlope200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesMacdSlopeExecute(r)
}

/*
GetTimeSeriesMacdSlope Moving average convergence divergence slope

The Moving Average Convergence Divergence (MACD) Slope endpoint provides the rate of change of the MACD line for a given security. It returns data on how quickly the MACD line is rising or falling, offering insights into the momentum shifts in the security's price. This information is useful for traders looking to gauge the speed of price movements and potential trend reversals.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesMacdSlopeRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesMacdSlope(ctx context.Context) ApiGetTimeSeriesMacdSlopeRequest {
	return ApiGetTimeSeriesMacdSlopeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesMacdSlope200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesMacdSlopeExecute(r ApiGetTimeSeriesMacdSlopeRequest) (*GetTimeSeriesMacdSlope200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesMacdSlope200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesMacdSlope")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/macd_slope"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.seriesType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", r.seriesType, "form", "")
	} else {
        var defaultValue string = "close"
        parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", defaultValue, "form", "")
        r.seriesType = &defaultValue
	}
	if r.fastPeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fast_period", r.fastPeriod, "form", "")
	} else {
        var defaultValue int64 = 12
        parameterAddToHeaderOrQuery(localVarQueryParams, "fast_period", defaultValue, "form", "")
        r.fastPeriod = &defaultValue
	}
	if r.slowPeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "slow_period", r.slowPeriod, "form", "")
	} else {
        var defaultValue int64 = 26
        parameterAddToHeaderOrQuery(localVarQueryParams, "slow_period", defaultValue, "form", "")
        r.slowPeriod = &defaultValue
	}
	if r.signalPeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "signal_period", r.signalPeriod, "form", "")
	} else {
        var defaultValue int64 = 9
        parameterAddToHeaderOrQuery(localVarQueryParams, "signal_period", defaultValue, "form", "")
        r.signalPeriod = &defaultValue
	}
	if r.timePeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", r.timePeriod, "form", "")
	} else {
        var defaultValue int64 = 9
        parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", defaultValue, "form", "")
        r.timePeriod = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesMamaRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	seriesType *string
	fastLimit *float64
	slowLimit *float64
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesMamaRequest) Interval(interval string) ApiGetTimeSeriesMamaRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesMamaRequest) Symbol(symbol string) ApiGetTimeSeriesMamaRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesMamaRequest) Isin(isin string) ApiGetTimeSeriesMamaRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesMamaRequest) Figi(figi string) ApiGetTimeSeriesMamaRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesMamaRequest) Cusip(cusip string) ApiGetTimeSeriesMamaRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesMamaRequest) Outputsize(outputsize int64) ApiGetTimeSeriesMamaRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesMamaRequest) Exchange(exchange string) ApiGetTimeSeriesMamaRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesMamaRequest) MicCode(micCode string) ApiGetTimeSeriesMamaRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesMamaRequest) Country(country string) ApiGetTimeSeriesMamaRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesMamaRequest) Type_(type_ string) ApiGetTimeSeriesMamaRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesMamaRequest) Timezone(timezone string) ApiGetTimeSeriesMamaRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesMamaRequest) StartDate(startDate string) ApiGetTimeSeriesMamaRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesMamaRequest) EndDate(endDate string) ApiGetTimeSeriesMamaRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesMamaRequest) Date(date string) ApiGetTimeSeriesMamaRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesMamaRequest) Order(order string) ApiGetTimeSeriesMamaRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesMamaRequest) Prepost(prepost bool) ApiGetTimeSeriesMamaRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesMamaRequest) Format(format string) ApiGetTimeSeriesMamaRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesMamaRequest) Delimiter(delimiter string) ApiGetTimeSeriesMamaRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesMamaRequest) Dp(dp int64) ApiGetTimeSeriesMamaRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesMamaRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesMamaRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesMamaRequest) Adjust(adjust string) ApiGetTimeSeriesMamaRequest {
	r.adjust = &adjust
	return r
}

// Price type on which technical indicator is calculated
func (r ApiGetTimeSeriesMamaRequest) SeriesType(seriesType string) ApiGetTimeSeriesMamaRequest {
	r.seriesType = &seriesType
	return r
}

// The limit for the fast moving average.
func (r ApiGetTimeSeriesMamaRequest) FastLimit(fastLimit float64) ApiGetTimeSeriesMamaRequest {
	r.fastLimit = &fastLimit
	return r
}

// The limit for the slow moving average.
func (r ApiGetTimeSeriesMamaRequest) SlowLimit(slowLimit float64) ApiGetTimeSeriesMamaRequest {
	r.slowLimit = &slowLimit
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesMamaRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesMamaRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesMamaRequest) Execute() (*GetTimeSeriesMama200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesMamaExecute(r)
}

/*
GetTimeSeriesMama MESA adaptive moving average

The MESA Adaptive Moving Average (MAMA) endpoint calculates a moving average that adjusts to the dominant market cycle, offering a balance between quick response to price changes and noise reduction. It returns data that includes the adaptive moving average values, which can be used to identify trends and potential reversal points.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesMamaRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesMama(ctx context.Context) ApiGetTimeSeriesMamaRequest {
	return ApiGetTimeSeriesMamaRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesMama200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesMamaExecute(r ApiGetTimeSeriesMamaRequest) (*GetTimeSeriesMama200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesMama200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesMama")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mama"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.seriesType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", r.seriesType, "form", "")
	} else {
        var defaultValue string = "close"
        parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", defaultValue, "form", "")
        r.seriesType = &defaultValue
	}
	if r.fastLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fast_limit", r.fastLimit, "form", "")
	} else {
        var defaultValue float64 = 0.5
        parameterAddToHeaderOrQuery(localVarQueryParams, "fast_limit", defaultValue, "form", "")
        r.fastLimit = &defaultValue
	}
	if r.slowLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "slow_limit", r.slowLimit, "form", "")
	} else {
        var defaultValue float64 = 0.05
        parameterAddToHeaderOrQuery(localVarQueryParams, "slow_limit", defaultValue, "form", "")
        r.slowLimit = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesMaxRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	seriesType *string
	timePeriod *int64
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesMaxRequest) Interval(interval string) ApiGetTimeSeriesMaxRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesMaxRequest) Symbol(symbol string) ApiGetTimeSeriesMaxRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesMaxRequest) Isin(isin string) ApiGetTimeSeriesMaxRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesMaxRequest) Figi(figi string) ApiGetTimeSeriesMaxRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesMaxRequest) Cusip(cusip string) ApiGetTimeSeriesMaxRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesMaxRequest) Outputsize(outputsize int64) ApiGetTimeSeriesMaxRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesMaxRequest) Exchange(exchange string) ApiGetTimeSeriesMaxRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesMaxRequest) MicCode(micCode string) ApiGetTimeSeriesMaxRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesMaxRequest) Country(country string) ApiGetTimeSeriesMaxRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesMaxRequest) Type_(type_ string) ApiGetTimeSeriesMaxRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesMaxRequest) Timezone(timezone string) ApiGetTimeSeriesMaxRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesMaxRequest) StartDate(startDate string) ApiGetTimeSeriesMaxRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesMaxRequest) EndDate(endDate string) ApiGetTimeSeriesMaxRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesMaxRequest) Date(date string) ApiGetTimeSeriesMaxRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesMaxRequest) Order(order string) ApiGetTimeSeriesMaxRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesMaxRequest) Prepost(prepost bool) ApiGetTimeSeriesMaxRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesMaxRequest) Format(format string) ApiGetTimeSeriesMaxRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesMaxRequest) Delimiter(delimiter string) ApiGetTimeSeriesMaxRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesMaxRequest) Dp(dp int64) ApiGetTimeSeriesMaxRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesMaxRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesMaxRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesMaxRequest) Adjust(adjust string) ApiGetTimeSeriesMaxRequest {
	r.adjust = &adjust
	return r
}

// Price type on which technical indicator is calculated
func (r ApiGetTimeSeriesMaxRequest) SeriesType(seriesType string) ApiGetTimeSeriesMaxRequest {
	r.seriesType = &seriesType
	return r
}

// Number of periods to average over. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesMaxRequest) TimePeriod(timePeriod int64) ApiGetTimeSeriesMaxRequest {
	r.timePeriod = &timePeriod
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesMaxRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesMaxRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesMaxRequest) Execute() (*GetTimeSeriesMax200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesMaxExecute(r)
}

/*
GetTimeSeriesMax Maximum

The Maximum (MAX) endpoint calculates and returns the highest value within a specified data series over a given period. This endpoint is useful for identifying potential resistance levels or detecting extreme price movements in financial data.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesMaxRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesMax(ctx context.Context) ApiGetTimeSeriesMaxRequest {
	return ApiGetTimeSeriesMaxRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesMax200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesMaxExecute(r ApiGetTimeSeriesMaxRequest) (*GetTimeSeriesMax200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesMax200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesMax")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/max"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.seriesType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", r.seriesType, "form", "")
	} else {
        var defaultValue string = "close"
        parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", defaultValue, "form", "")
        r.seriesType = &defaultValue
	}
	if r.timePeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", r.timePeriod, "form", "")
	} else {
        var defaultValue int64 = 9
        parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", defaultValue, "form", "")
        r.timePeriod = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesMaxIndexRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	seriesType *string
	timePeriod *int64
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesMaxIndexRequest) Interval(interval string) ApiGetTimeSeriesMaxIndexRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesMaxIndexRequest) Symbol(symbol string) ApiGetTimeSeriesMaxIndexRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesMaxIndexRequest) Isin(isin string) ApiGetTimeSeriesMaxIndexRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesMaxIndexRequest) Figi(figi string) ApiGetTimeSeriesMaxIndexRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesMaxIndexRequest) Cusip(cusip string) ApiGetTimeSeriesMaxIndexRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesMaxIndexRequest) Outputsize(outputsize int64) ApiGetTimeSeriesMaxIndexRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesMaxIndexRequest) Exchange(exchange string) ApiGetTimeSeriesMaxIndexRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesMaxIndexRequest) MicCode(micCode string) ApiGetTimeSeriesMaxIndexRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesMaxIndexRequest) Country(country string) ApiGetTimeSeriesMaxIndexRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesMaxIndexRequest) Type_(type_ string) ApiGetTimeSeriesMaxIndexRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesMaxIndexRequest) Timezone(timezone string) ApiGetTimeSeriesMaxIndexRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesMaxIndexRequest) StartDate(startDate string) ApiGetTimeSeriesMaxIndexRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesMaxIndexRequest) EndDate(endDate string) ApiGetTimeSeriesMaxIndexRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesMaxIndexRequest) Date(date string) ApiGetTimeSeriesMaxIndexRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesMaxIndexRequest) Order(order string) ApiGetTimeSeriesMaxIndexRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesMaxIndexRequest) Prepost(prepost bool) ApiGetTimeSeriesMaxIndexRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesMaxIndexRequest) Format(format string) ApiGetTimeSeriesMaxIndexRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesMaxIndexRequest) Delimiter(delimiter string) ApiGetTimeSeriesMaxIndexRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesMaxIndexRequest) Dp(dp int64) ApiGetTimeSeriesMaxIndexRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesMaxIndexRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesMaxIndexRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesMaxIndexRequest) Adjust(adjust string) ApiGetTimeSeriesMaxIndexRequest {
	r.adjust = &adjust
	return r
}

// Price type on which technical indicator is calculated
func (r ApiGetTimeSeriesMaxIndexRequest) SeriesType(seriesType string) ApiGetTimeSeriesMaxIndexRequest {
	r.seriesType = &seriesType
	return r
}

// Number of periods to average over. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesMaxIndexRequest) TimePeriod(timePeriod int64) ApiGetTimeSeriesMaxIndexRequest {
	r.timePeriod = &timePeriod
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesMaxIndexRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesMaxIndexRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesMaxIndexRequest) Execute() (*GetTimeSeriesMaxIndex200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesMaxIndexExecute(r)
}

/*
GetTimeSeriesMaxIndex Maximum Index

The Maximum Index (MAXINDEX) endpoint identifies the position of the highest value within a specified data series over a given time frame. It returns the index where the peak value occurs, allowing users to pinpoint when the maximum price or value was reached in the series. This is useful for tracking the timing of significant peaks in financial data.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesMaxIndexRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesMaxIndex(ctx context.Context) ApiGetTimeSeriesMaxIndexRequest {
	return ApiGetTimeSeriesMaxIndexRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesMaxIndex200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesMaxIndexExecute(r ApiGetTimeSeriesMaxIndexRequest) (*GetTimeSeriesMaxIndex200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesMaxIndex200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesMaxIndex")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/maxindex"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.seriesType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", r.seriesType, "form", "")
	} else {
        var defaultValue string = "close"
        parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", defaultValue, "form", "")
        r.seriesType = &defaultValue
	}
	if r.timePeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", r.timePeriod, "form", "")
	} else {
        var defaultValue int64 = 9
        parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", defaultValue, "form", "")
        r.timePeriod = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesMcGinleyDynamicRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	timePeriod *int64
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesMcGinleyDynamicRequest) Interval(interval string) ApiGetTimeSeriesMcGinleyDynamicRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesMcGinleyDynamicRequest) Symbol(symbol string) ApiGetTimeSeriesMcGinleyDynamicRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesMcGinleyDynamicRequest) Isin(isin string) ApiGetTimeSeriesMcGinleyDynamicRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesMcGinleyDynamicRequest) Figi(figi string) ApiGetTimeSeriesMcGinleyDynamicRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesMcGinleyDynamicRequest) Cusip(cusip string) ApiGetTimeSeriesMcGinleyDynamicRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesMcGinleyDynamicRequest) Outputsize(outputsize int64) ApiGetTimeSeriesMcGinleyDynamicRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesMcGinleyDynamicRequest) Exchange(exchange string) ApiGetTimeSeriesMcGinleyDynamicRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesMcGinleyDynamicRequest) MicCode(micCode string) ApiGetTimeSeriesMcGinleyDynamicRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesMcGinleyDynamicRequest) Country(country string) ApiGetTimeSeriesMcGinleyDynamicRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesMcGinleyDynamicRequest) Type_(type_ string) ApiGetTimeSeriesMcGinleyDynamicRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesMcGinleyDynamicRequest) Timezone(timezone string) ApiGetTimeSeriesMcGinleyDynamicRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesMcGinleyDynamicRequest) StartDate(startDate string) ApiGetTimeSeriesMcGinleyDynamicRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesMcGinleyDynamicRequest) EndDate(endDate string) ApiGetTimeSeriesMcGinleyDynamicRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesMcGinleyDynamicRequest) Date(date string) ApiGetTimeSeriesMcGinleyDynamicRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesMcGinleyDynamicRequest) Order(order string) ApiGetTimeSeriesMcGinleyDynamicRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesMcGinleyDynamicRequest) Prepost(prepost bool) ApiGetTimeSeriesMcGinleyDynamicRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesMcGinleyDynamicRequest) Format(format string) ApiGetTimeSeriesMcGinleyDynamicRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesMcGinleyDynamicRequest) Delimiter(delimiter string) ApiGetTimeSeriesMcGinleyDynamicRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesMcGinleyDynamicRequest) Dp(dp int64) ApiGetTimeSeriesMcGinleyDynamicRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesMcGinleyDynamicRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesMcGinleyDynamicRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesMcGinleyDynamicRequest) Adjust(adjust string) ApiGetTimeSeriesMcGinleyDynamicRequest {
	r.adjust = &adjust
	return r
}

// Number of periods to average over. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesMcGinleyDynamicRequest) TimePeriod(timePeriod int64) ApiGetTimeSeriesMcGinleyDynamicRequest {
	r.timePeriod = &timePeriod
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesMcGinleyDynamicRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesMcGinleyDynamicRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesMcGinleyDynamicRequest) Execute() (*GetTimeSeriesMcGinleyDynamic200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesMcGinleyDynamicExecute(r)
}

/*
GetTimeSeriesMcGinleyDynamic McGinley dynamic indicator

This endpoint calculates the McGinley Dynamic (MCGINLEY_DYNAMIC) indicator, which provides a refined moving average that adapts to market volatility. This endpoint returns data that reflects smoother price trends and identifies potential support or resistance levels more accurately than traditional moving averages. It is useful for users seeking to track price movements with reduced lag and enhanced responsiveness to market changes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesMcGinleyDynamicRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesMcGinleyDynamic(ctx context.Context) ApiGetTimeSeriesMcGinleyDynamicRequest {
	return ApiGetTimeSeriesMcGinleyDynamicRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesMcGinleyDynamic200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesMcGinleyDynamicExecute(r ApiGetTimeSeriesMcGinleyDynamicRequest) (*GetTimeSeriesMcGinleyDynamic200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesMcGinleyDynamic200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesMcGinleyDynamic")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mcginley_dynamic"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.timePeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", r.timePeriod, "form", "")
	} else {
        var defaultValue int64 = 14
        parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", defaultValue, "form", "")
        r.timePeriod = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesMedPriceRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesMedPriceRequest) Interval(interval string) ApiGetTimeSeriesMedPriceRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesMedPriceRequest) Symbol(symbol string) ApiGetTimeSeriesMedPriceRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesMedPriceRequest) Isin(isin string) ApiGetTimeSeriesMedPriceRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesMedPriceRequest) Figi(figi string) ApiGetTimeSeriesMedPriceRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesMedPriceRequest) Cusip(cusip string) ApiGetTimeSeriesMedPriceRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesMedPriceRequest) Outputsize(outputsize int64) ApiGetTimeSeriesMedPriceRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesMedPriceRequest) Exchange(exchange string) ApiGetTimeSeriesMedPriceRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesMedPriceRequest) MicCode(micCode string) ApiGetTimeSeriesMedPriceRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesMedPriceRequest) Country(country string) ApiGetTimeSeriesMedPriceRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesMedPriceRequest) Type_(type_ string) ApiGetTimeSeriesMedPriceRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesMedPriceRequest) Timezone(timezone string) ApiGetTimeSeriesMedPriceRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesMedPriceRequest) StartDate(startDate string) ApiGetTimeSeriesMedPriceRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesMedPriceRequest) EndDate(endDate string) ApiGetTimeSeriesMedPriceRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesMedPriceRequest) Date(date string) ApiGetTimeSeriesMedPriceRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesMedPriceRequest) Order(order string) ApiGetTimeSeriesMedPriceRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesMedPriceRequest) Prepost(prepost bool) ApiGetTimeSeriesMedPriceRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesMedPriceRequest) Format(format string) ApiGetTimeSeriesMedPriceRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesMedPriceRequest) Delimiter(delimiter string) ApiGetTimeSeriesMedPriceRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesMedPriceRequest) Dp(dp int64) ApiGetTimeSeriesMedPriceRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesMedPriceRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesMedPriceRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesMedPriceRequest) Adjust(adjust string) ApiGetTimeSeriesMedPriceRequest {
	r.adjust = &adjust
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesMedPriceRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesMedPriceRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesMedPriceRequest) Execute() (*GetTimeSeriesMedPrice200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesMedPriceExecute(r)
}

/*
GetTimeSeriesMedPrice Median price

The Median Price (MEDPRICE) endpoint calculates and returns the average of the high and low prices of a security for a specified period. This endpoint provides a simplified view of price movements, helping users quickly assess price trends by focusing on the midpoint of price action.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesMedPriceRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesMedPrice(ctx context.Context) ApiGetTimeSeriesMedPriceRequest {
	return ApiGetTimeSeriesMedPriceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesMedPrice200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesMedPriceExecute(r ApiGetTimeSeriesMedPriceRequest) (*GetTimeSeriesMedPrice200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesMedPrice200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesMedPrice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/medprice"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesMfiRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	timePeriod *int64
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesMfiRequest) Interval(interval string) ApiGetTimeSeriesMfiRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesMfiRequest) Symbol(symbol string) ApiGetTimeSeriesMfiRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesMfiRequest) Isin(isin string) ApiGetTimeSeriesMfiRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesMfiRequest) Figi(figi string) ApiGetTimeSeriesMfiRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesMfiRequest) Cusip(cusip string) ApiGetTimeSeriesMfiRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesMfiRequest) Outputsize(outputsize int64) ApiGetTimeSeriesMfiRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesMfiRequest) Exchange(exchange string) ApiGetTimeSeriesMfiRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesMfiRequest) MicCode(micCode string) ApiGetTimeSeriesMfiRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesMfiRequest) Country(country string) ApiGetTimeSeriesMfiRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesMfiRequest) Type_(type_ string) ApiGetTimeSeriesMfiRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesMfiRequest) Timezone(timezone string) ApiGetTimeSeriesMfiRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesMfiRequest) StartDate(startDate string) ApiGetTimeSeriesMfiRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesMfiRequest) EndDate(endDate string) ApiGetTimeSeriesMfiRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesMfiRequest) Date(date string) ApiGetTimeSeriesMfiRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesMfiRequest) Order(order string) ApiGetTimeSeriesMfiRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesMfiRequest) Prepost(prepost bool) ApiGetTimeSeriesMfiRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesMfiRequest) Format(format string) ApiGetTimeSeriesMfiRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesMfiRequest) Delimiter(delimiter string) ApiGetTimeSeriesMfiRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesMfiRequest) Dp(dp int64) ApiGetTimeSeriesMfiRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesMfiRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesMfiRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesMfiRequest) Adjust(adjust string) ApiGetTimeSeriesMfiRequest {
	r.adjust = &adjust
	return r
}

// Number of periods to average over. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesMfiRequest) TimePeriod(timePeriod int64) ApiGetTimeSeriesMfiRequest {
	r.timePeriod = &timePeriod
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesMfiRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesMfiRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesMfiRequest) Execute() (*GetTimeSeriesMfi200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesMfiExecute(r)
}

/*
GetTimeSeriesMfi Money flow index

The Money Flow Index (MFI) endpoint provides a volume-weighted momentum oscillator that quantifies buying and selling pressure by analyzing positive and negative money flow. It returns data indicating potential overbought or oversold conditions in a financial asset, aiding users in understanding market trends and price movements.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesMfiRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesMfi(ctx context.Context) ApiGetTimeSeriesMfiRequest {
	return ApiGetTimeSeriesMfiRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesMfi200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesMfiExecute(r ApiGetTimeSeriesMfiRequest) (*GetTimeSeriesMfi200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesMfi200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesMfi")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mfi"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.timePeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", r.timePeriod, "form", "")
	} else {
        var defaultValue int64 = 14
        parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", defaultValue, "form", "")
        r.timePeriod = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesMidPointRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	seriesType *string
	timePeriod *int64
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesMidPointRequest) Interval(interval string) ApiGetTimeSeriesMidPointRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesMidPointRequest) Symbol(symbol string) ApiGetTimeSeriesMidPointRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesMidPointRequest) Isin(isin string) ApiGetTimeSeriesMidPointRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesMidPointRequest) Figi(figi string) ApiGetTimeSeriesMidPointRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesMidPointRequest) Cusip(cusip string) ApiGetTimeSeriesMidPointRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesMidPointRequest) Outputsize(outputsize int64) ApiGetTimeSeriesMidPointRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesMidPointRequest) Exchange(exchange string) ApiGetTimeSeriesMidPointRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesMidPointRequest) MicCode(micCode string) ApiGetTimeSeriesMidPointRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesMidPointRequest) Country(country string) ApiGetTimeSeriesMidPointRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesMidPointRequest) Type_(type_ string) ApiGetTimeSeriesMidPointRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesMidPointRequest) Timezone(timezone string) ApiGetTimeSeriesMidPointRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesMidPointRequest) StartDate(startDate string) ApiGetTimeSeriesMidPointRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesMidPointRequest) EndDate(endDate string) ApiGetTimeSeriesMidPointRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesMidPointRequest) Date(date string) ApiGetTimeSeriesMidPointRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesMidPointRequest) Order(order string) ApiGetTimeSeriesMidPointRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesMidPointRequest) Prepost(prepost bool) ApiGetTimeSeriesMidPointRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesMidPointRequest) Format(format string) ApiGetTimeSeriesMidPointRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesMidPointRequest) Delimiter(delimiter string) ApiGetTimeSeriesMidPointRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesMidPointRequest) Dp(dp int64) ApiGetTimeSeriesMidPointRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesMidPointRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesMidPointRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesMidPointRequest) Adjust(adjust string) ApiGetTimeSeriesMidPointRequest {
	r.adjust = &adjust
	return r
}

// Price type on which technical indicator is calculated
func (r ApiGetTimeSeriesMidPointRequest) SeriesType(seriesType string) ApiGetTimeSeriesMidPointRequest {
	r.seriesType = &seriesType
	return r
}

// Number of periods to average over. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesMidPointRequest) TimePeriod(timePeriod int64) ApiGetTimeSeriesMidPointRequest {
	r.timePeriod = &timePeriod
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesMidPointRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesMidPointRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesMidPointRequest) Execute() (*GetTimeSeriesMidPoint200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesMidPointExecute(r)
}

/*
GetTimeSeriesMidPoint Midpoint

The Midpoint (MIDPOINT) endpoint calculates the average value between the highest and lowest prices of a financial instrument over a specified period. It returns a time series of midpoint values, which can help users identify price trends and smooth out short-term fluctuations in the data.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesMidPointRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesMidPoint(ctx context.Context) ApiGetTimeSeriesMidPointRequest {
	return ApiGetTimeSeriesMidPointRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesMidPoint200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesMidPointExecute(r ApiGetTimeSeriesMidPointRequest) (*GetTimeSeriesMidPoint200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesMidPoint200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesMidPoint")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/midpoint"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.seriesType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", r.seriesType, "form", "")
	} else {
        var defaultValue string = "close"
        parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", defaultValue, "form", "")
        r.seriesType = &defaultValue
	}
	if r.timePeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", r.timePeriod, "form", "")
	} else {
        var defaultValue int64 = 9
        parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", defaultValue, "form", "")
        r.timePeriod = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesMidPriceRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	timePeriod *int64
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesMidPriceRequest) Interval(interval string) ApiGetTimeSeriesMidPriceRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesMidPriceRequest) Symbol(symbol string) ApiGetTimeSeriesMidPriceRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesMidPriceRequest) Isin(isin string) ApiGetTimeSeriesMidPriceRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesMidPriceRequest) Figi(figi string) ApiGetTimeSeriesMidPriceRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesMidPriceRequest) Cusip(cusip string) ApiGetTimeSeriesMidPriceRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesMidPriceRequest) Outputsize(outputsize int64) ApiGetTimeSeriesMidPriceRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesMidPriceRequest) Exchange(exchange string) ApiGetTimeSeriesMidPriceRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesMidPriceRequest) MicCode(micCode string) ApiGetTimeSeriesMidPriceRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesMidPriceRequest) Country(country string) ApiGetTimeSeriesMidPriceRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesMidPriceRequest) Type_(type_ string) ApiGetTimeSeriesMidPriceRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesMidPriceRequest) Timezone(timezone string) ApiGetTimeSeriesMidPriceRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesMidPriceRequest) StartDate(startDate string) ApiGetTimeSeriesMidPriceRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesMidPriceRequest) EndDate(endDate string) ApiGetTimeSeriesMidPriceRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesMidPriceRequest) Date(date string) ApiGetTimeSeriesMidPriceRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesMidPriceRequest) Order(order string) ApiGetTimeSeriesMidPriceRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesMidPriceRequest) Prepost(prepost bool) ApiGetTimeSeriesMidPriceRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesMidPriceRequest) Format(format string) ApiGetTimeSeriesMidPriceRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesMidPriceRequest) Delimiter(delimiter string) ApiGetTimeSeriesMidPriceRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesMidPriceRequest) Dp(dp int64) ApiGetTimeSeriesMidPriceRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesMidPriceRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesMidPriceRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesMidPriceRequest) Adjust(adjust string) ApiGetTimeSeriesMidPriceRequest {
	r.adjust = &adjust
	return r
}

// Number of periods to average over. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesMidPriceRequest) TimePeriod(timePeriod int64) ApiGetTimeSeriesMidPriceRequest {
	r.timePeriod = &timePeriod
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesMidPriceRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesMidPriceRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesMidPriceRequest) Execute() (*GetTimeSeriesMidPrice200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesMidPriceExecute(r)
}

/*
GetTimeSeriesMidPrice Midprice

The Midprice (MIDPRICE) endpoint calculates and returns the average of a financial instrument's highest and lowest prices over a specified time period. This data provides a smoothed representation of price movements, helping users identify potential support or resistance levels in the market.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesMidPriceRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesMidPrice(ctx context.Context) ApiGetTimeSeriesMidPriceRequest {
	return ApiGetTimeSeriesMidPriceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesMidPrice200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesMidPriceExecute(r ApiGetTimeSeriesMidPriceRequest) (*GetTimeSeriesMidPrice200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesMidPrice200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesMidPrice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/midprice"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.timePeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", r.timePeriod, "form", "")
	} else {
        var defaultValue int64 = 9
        parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", defaultValue, "form", "")
        r.timePeriod = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesMinRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	seriesType *string
	timePeriod *int64
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesMinRequest) Interval(interval string) ApiGetTimeSeriesMinRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesMinRequest) Symbol(symbol string) ApiGetTimeSeriesMinRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesMinRequest) Isin(isin string) ApiGetTimeSeriesMinRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesMinRequest) Figi(figi string) ApiGetTimeSeriesMinRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesMinRequest) Cusip(cusip string) ApiGetTimeSeriesMinRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesMinRequest) Outputsize(outputsize int64) ApiGetTimeSeriesMinRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesMinRequest) Exchange(exchange string) ApiGetTimeSeriesMinRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesMinRequest) MicCode(micCode string) ApiGetTimeSeriesMinRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesMinRequest) Country(country string) ApiGetTimeSeriesMinRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesMinRequest) Type_(type_ string) ApiGetTimeSeriesMinRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesMinRequest) Timezone(timezone string) ApiGetTimeSeriesMinRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesMinRequest) StartDate(startDate string) ApiGetTimeSeriesMinRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesMinRequest) EndDate(endDate string) ApiGetTimeSeriesMinRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesMinRequest) Date(date string) ApiGetTimeSeriesMinRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesMinRequest) Order(order string) ApiGetTimeSeriesMinRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesMinRequest) Prepost(prepost bool) ApiGetTimeSeriesMinRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesMinRequest) Format(format string) ApiGetTimeSeriesMinRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesMinRequest) Delimiter(delimiter string) ApiGetTimeSeriesMinRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesMinRequest) Dp(dp int64) ApiGetTimeSeriesMinRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesMinRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesMinRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesMinRequest) Adjust(adjust string) ApiGetTimeSeriesMinRequest {
	r.adjust = &adjust
	return r
}

// Price type on which technical indicator is calculated
func (r ApiGetTimeSeriesMinRequest) SeriesType(seriesType string) ApiGetTimeSeriesMinRequest {
	r.seriesType = &seriesType
	return r
}

// Number of periods to average over. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesMinRequest) TimePeriod(timePeriod int64) ApiGetTimeSeriesMinRequest {
	r.timePeriod = &timePeriod
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesMinRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesMinRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesMinRequest) Execute() (*GetTimeSeriesMin200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesMinExecute(r)
}

/*
GetTimeSeriesMin Minimum

The Minimum (MIN) Indicator endpoint provides the lowest value of a specified data series over a chosen time period. This endpoint is useful for identifying potential support levels or detecting extreme price movements in financial data.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesMinRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesMin(ctx context.Context) ApiGetTimeSeriesMinRequest {
	return ApiGetTimeSeriesMinRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesMin200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesMinExecute(r ApiGetTimeSeriesMinRequest) (*GetTimeSeriesMin200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesMin200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesMin")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/min"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.seriesType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", r.seriesType, "form", "")
	} else {
        var defaultValue string = "close"
        parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", defaultValue, "form", "")
        r.seriesType = &defaultValue
	}
	if r.timePeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", r.timePeriod, "form", "")
	} else {
        var defaultValue int64 = 9
        parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", defaultValue, "form", "")
        r.timePeriod = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesMinIndexRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	seriesType *string
	timePeriod *int64
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesMinIndexRequest) Interval(interval string) ApiGetTimeSeriesMinIndexRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesMinIndexRequest) Symbol(symbol string) ApiGetTimeSeriesMinIndexRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesMinIndexRequest) Isin(isin string) ApiGetTimeSeriesMinIndexRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesMinIndexRequest) Figi(figi string) ApiGetTimeSeriesMinIndexRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesMinIndexRequest) Cusip(cusip string) ApiGetTimeSeriesMinIndexRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesMinIndexRequest) Outputsize(outputsize int64) ApiGetTimeSeriesMinIndexRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesMinIndexRequest) Exchange(exchange string) ApiGetTimeSeriesMinIndexRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesMinIndexRequest) MicCode(micCode string) ApiGetTimeSeriesMinIndexRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesMinIndexRequest) Country(country string) ApiGetTimeSeriesMinIndexRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesMinIndexRequest) Type_(type_ string) ApiGetTimeSeriesMinIndexRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesMinIndexRequest) Timezone(timezone string) ApiGetTimeSeriesMinIndexRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesMinIndexRequest) StartDate(startDate string) ApiGetTimeSeriesMinIndexRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesMinIndexRequest) EndDate(endDate string) ApiGetTimeSeriesMinIndexRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesMinIndexRequest) Date(date string) ApiGetTimeSeriesMinIndexRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesMinIndexRequest) Order(order string) ApiGetTimeSeriesMinIndexRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesMinIndexRequest) Prepost(prepost bool) ApiGetTimeSeriesMinIndexRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesMinIndexRequest) Format(format string) ApiGetTimeSeriesMinIndexRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesMinIndexRequest) Delimiter(delimiter string) ApiGetTimeSeriesMinIndexRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesMinIndexRequest) Dp(dp int64) ApiGetTimeSeriesMinIndexRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesMinIndexRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesMinIndexRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesMinIndexRequest) Adjust(adjust string) ApiGetTimeSeriesMinIndexRequest {
	r.adjust = &adjust
	return r
}

// Price type on which technical indicator is calculated
func (r ApiGetTimeSeriesMinIndexRequest) SeriesType(seriesType string) ApiGetTimeSeriesMinIndexRequest {
	r.seriesType = &seriesType
	return r
}

// Number of periods to average over. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesMinIndexRequest) TimePeriod(timePeriod int64) ApiGetTimeSeriesMinIndexRequest {
	r.timePeriod = &timePeriod
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesMinIndexRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesMinIndexRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesMinIndexRequest) Execute() (*GetTimeSeriesMinIndex200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesMinIndexExecute(r)
}

/*
GetTimeSeriesMinIndex Minimum index

The Minimum Index (MININDEX) endpoint identifies the position of the lowest value within a specified data series over a given time frame. It returns the index number corresponding to the earliest occurrence of this minimum value. This is useful for pinpointing when the lowest price or value occurred in a dataset, aiding in time-based analysis of data trends.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesMinIndexRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesMinIndex(ctx context.Context) ApiGetTimeSeriesMinIndexRequest {
	return ApiGetTimeSeriesMinIndexRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesMinIndex200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesMinIndexExecute(r ApiGetTimeSeriesMinIndexRequest) (*GetTimeSeriesMinIndex200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesMinIndex200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesMinIndex")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/minindex"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.seriesType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", r.seriesType, "form", "")
	} else {
        var defaultValue string = "close"
        parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", defaultValue, "form", "")
        r.seriesType = &defaultValue
	}
	if r.timePeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", r.timePeriod, "form", "")
	} else {
        var defaultValue int64 = 9
        parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", defaultValue, "form", "")
        r.timePeriod = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesMinMaxRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	seriesType *string
	timePeriod *int64
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesMinMaxRequest) Interval(interval string) ApiGetTimeSeriesMinMaxRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesMinMaxRequest) Symbol(symbol string) ApiGetTimeSeriesMinMaxRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesMinMaxRequest) Isin(isin string) ApiGetTimeSeriesMinMaxRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesMinMaxRequest) Figi(figi string) ApiGetTimeSeriesMinMaxRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesMinMaxRequest) Cusip(cusip string) ApiGetTimeSeriesMinMaxRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesMinMaxRequest) Outputsize(outputsize int64) ApiGetTimeSeriesMinMaxRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesMinMaxRequest) Exchange(exchange string) ApiGetTimeSeriesMinMaxRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesMinMaxRequest) MicCode(micCode string) ApiGetTimeSeriesMinMaxRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesMinMaxRequest) Country(country string) ApiGetTimeSeriesMinMaxRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesMinMaxRequest) Type_(type_ string) ApiGetTimeSeriesMinMaxRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesMinMaxRequest) Timezone(timezone string) ApiGetTimeSeriesMinMaxRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesMinMaxRequest) StartDate(startDate string) ApiGetTimeSeriesMinMaxRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesMinMaxRequest) EndDate(endDate string) ApiGetTimeSeriesMinMaxRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesMinMaxRequest) Date(date string) ApiGetTimeSeriesMinMaxRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesMinMaxRequest) Order(order string) ApiGetTimeSeriesMinMaxRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesMinMaxRequest) Prepost(prepost bool) ApiGetTimeSeriesMinMaxRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesMinMaxRequest) Format(format string) ApiGetTimeSeriesMinMaxRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesMinMaxRequest) Delimiter(delimiter string) ApiGetTimeSeriesMinMaxRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesMinMaxRequest) Dp(dp int64) ApiGetTimeSeriesMinMaxRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesMinMaxRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesMinMaxRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesMinMaxRequest) Adjust(adjust string) ApiGetTimeSeriesMinMaxRequest {
	r.adjust = &adjust
	return r
}

// Price type on which technical indicator is calculated
func (r ApiGetTimeSeriesMinMaxRequest) SeriesType(seriesType string) ApiGetTimeSeriesMinMaxRequest {
	r.seriesType = &seriesType
	return r
}

// Number of periods to average over. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesMinMaxRequest) TimePeriod(timePeriod int64) ApiGetTimeSeriesMinMaxRequest {
	r.timePeriod = &timePeriod
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesMinMaxRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesMinMaxRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesMinMaxRequest) Execute() (*GetTimeSeriesMinMax200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesMinMaxExecute(r)
}

/*
GetTimeSeriesMinMax Minimum and maximum

The Minimum and Maximum (MINMAX) endpoint identifies the lowest and highest values within a specified time frame for a given data series. It returns these extreme values, which can be used to detect potential support and resistance levels or significant price fluctuations in the data.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesMinMaxRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesMinMax(ctx context.Context) ApiGetTimeSeriesMinMaxRequest {
	return ApiGetTimeSeriesMinMaxRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesMinMax200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesMinMaxExecute(r ApiGetTimeSeriesMinMaxRequest) (*GetTimeSeriesMinMax200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesMinMax200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesMinMax")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/minmax"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.seriesType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", r.seriesType, "form", "")
	} else {
        var defaultValue string = "close"
        parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", defaultValue, "form", "")
        r.seriesType = &defaultValue
	}
	if r.timePeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", r.timePeriod, "form", "")
	} else {
        var defaultValue int64 = 9
        parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", defaultValue, "form", "")
        r.timePeriod = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesMinMaxIndexRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	seriesType *string
	timePeriod *int64
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesMinMaxIndexRequest) Interval(interval string) ApiGetTimeSeriesMinMaxIndexRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesMinMaxIndexRequest) Symbol(symbol string) ApiGetTimeSeriesMinMaxIndexRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesMinMaxIndexRequest) Isin(isin string) ApiGetTimeSeriesMinMaxIndexRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesMinMaxIndexRequest) Figi(figi string) ApiGetTimeSeriesMinMaxIndexRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesMinMaxIndexRequest) Cusip(cusip string) ApiGetTimeSeriesMinMaxIndexRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesMinMaxIndexRequest) Outputsize(outputsize int64) ApiGetTimeSeriesMinMaxIndexRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesMinMaxIndexRequest) Exchange(exchange string) ApiGetTimeSeriesMinMaxIndexRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesMinMaxIndexRequest) MicCode(micCode string) ApiGetTimeSeriesMinMaxIndexRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesMinMaxIndexRequest) Country(country string) ApiGetTimeSeriesMinMaxIndexRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesMinMaxIndexRequest) Type_(type_ string) ApiGetTimeSeriesMinMaxIndexRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesMinMaxIndexRequest) Timezone(timezone string) ApiGetTimeSeriesMinMaxIndexRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesMinMaxIndexRequest) StartDate(startDate string) ApiGetTimeSeriesMinMaxIndexRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesMinMaxIndexRequest) EndDate(endDate string) ApiGetTimeSeriesMinMaxIndexRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesMinMaxIndexRequest) Date(date string) ApiGetTimeSeriesMinMaxIndexRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesMinMaxIndexRequest) Order(order string) ApiGetTimeSeriesMinMaxIndexRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesMinMaxIndexRequest) Prepost(prepost bool) ApiGetTimeSeriesMinMaxIndexRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesMinMaxIndexRequest) Format(format string) ApiGetTimeSeriesMinMaxIndexRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesMinMaxIndexRequest) Delimiter(delimiter string) ApiGetTimeSeriesMinMaxIndexRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesMinMaxIndexRequest) Dp(dp int64) ApiGetTimeSeriesMinMaxIndexRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesMinMaxIndexRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesMinMaxIndexRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesMinMaxIndexRequest) Adjust(adjust string) ApiGetTimeSeriesMinMaxIndexRequest {
	r.adjust = &adjust
	return r
}

// Price type on which technical indicator is calculated
func (r ApiGetTimeSeriesMinMaxIndexRequest) SeriesType(seriesType string) ApiGetTimeSeriesMinMaxIndexRequest {
	r.seriesType = &seriesType
	return r
}

// Number of periods to average over. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesMinMaxIndexRequest) TimePeriod(timePeriod int64) ApiGetTimeSeriesMinMaxIndexRequest {
	r.timePeriod = &timePeriod
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesMinMaxIndexRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesMinMaxIndexRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesMinMaxIndexRequest) Execute() (*GetTimeSeriesMinMaxIndex200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesMinMaxIndexExecute(r)
}

/*
GetTimeSeriesMinMaxIndex Minimum and maximum index

The Minimum and Maximum Index (MINMAXINDEX) endpoint identifies the positions of the lowest and highest values within a specified data series period. It returns indices that indicate when these extreme values occur, allowing users to pinpoint significant price changes over time.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesMinMaxIndexRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesMinMaxIndex(ctx context.Context) ApiGetTimeSeriesMinMaxIndexRequest {
	return ApiGetTimeSeriesMinMaxIndexRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesMinMaxIndex200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesMinMaxIndexExecute(r ApiGetTimeSeriesMinMaxIndexRequest) (*GetTimeSeriesMinMaxIndex200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesMinMaxIndex200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesMinMaxIndex")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/minmaxindex"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.seriesType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", r.seriesType, "form", "")
	} else {
        var defaultValue string = "close"
        parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", defaultValue, "form", "")
        r.seriesType = &defaultValue
	}
	if r.timePeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", r.timePeriod, "form", "")
	} else {
        var defaultValue int64 = 9
        parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", defaultValue, "form", "")
        r.timePeriod = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesMinusDIRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	timePeriod *int64
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesMinusDIRequest) Interval(interval string) ApiGetTimeSeriesMinusDIRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesMinusDIRequest) Symbol(symbol string) ApiGetTimeSeriesMinusDIRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesMinusDIRequest) Isin(isin string) ApiGetTimeSeriesMinusDIRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesMinusDIRequest) Figi(figi string) ApiGetTimeSeriesMinusDIRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesMinusDIRequest) Cusip(cusip string) ApiGetTimeSeriesMinusDIRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesMinusDIRequest) Outputsize(outputsize int64) ApiGetTimeSeriesMinusDIRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesMinusDIRequest) Exchange(exchange string) ApiGetTimeSeriesMinusDIRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesMinusDIRequest) MicCode(micCode string) ApiGetTimeSeriesMinusDIRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesMinusDIRequest) Country(country string) ApiGetTimeSeriesMinusDIRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesMinusDIRequest) Type_(type_ string) ApiGetTimeSeriesMinusDIRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesMinusDIRequest) Timezone(timezone string) ApiGetTimeSeriesMinusDIRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesMinusDIRequest) StartDate(startDate string) ApiGetTimeSeriesMinusDIRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesMinusDIRequest) EndDate(endDate string) ApiGetTimeSeriesMinusDIRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesMinusDIRequest) Date(date string) ApiGetTimeSeriesMinusDIRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesMinusDIRequest) Order(order string) ApiGetTimeSeriesMinusDIRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesMinusDIRequest) Prepost(prepost bool) ApiGetTimeSeriesMinusDIRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesMinusDIRequest) Format(format string) ApiGetTimeSeriesMinusDIRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesMinusDIRequest) Delimiter(delimiter string) ApiGetTimeSeriesMinusDIRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesMinusDIRequest) Dp(dp int64) ApiGetTimeSeriesMinusDIRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesMinusDIRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesMinusDIRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesMinusDIRequest) Adjust(adjust string) ApiGetTimeSeriesMinusDIRequest {
	r.adjust = &adjust
	return r
}

// Number of periods to average over. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesMinusDIRequest) TimePeriod(timePeriod int64) ApiGetTimeSeriesMinusDIRequest {
	r.timePeriod = &timePeriod
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesMinusDIRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesMinusDIRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesMinusDIRequest) Execute() (*GetTimeSeriesMinusDI200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesMinusDIExecute(r)
}

/*
GetTimeSeriesMinusDI Minus directional indicator

The Minus Directional Indicator (MINUS_DI) endpoint calculates and returns the strength of a security's downward price movement over a specified period. This data is useful for traders and analysts looking to identify bearish trends and assess the intensity of price declines in financial markets.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesMinusDIRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesMinusDI(ctx context.Context) ApiGetTimeSeriesMinusDIRequest {
	return ApiGetTimeSeriesMinusDIRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesMinusDI200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesMinusDIExecute(r ApiGetTimeSeriesMinusDIRequest) (*GetTimeSeriesMinusDI200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesMinusDI200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesMinusDI")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/minus_di"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.timePeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", r.timePeriod, "form", "")
	} else {
        var defaultValue int64 = 9
        parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", defaultValue, "form", "")
        r.timePeriod = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesMinusDMRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	timePeriod *int64
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesMinusDMRequest) Interval(interval string) ApiGetTimeSeriesMinusDMRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesMinusDMRequest) Symbol(symbol string) ApiGetTimeSeriesMinusDMRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesMinusDMRequest) Isin(isin string) ApiGetTimeSeriesMinusDMRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesMinusDMRequest) Figi(figi string) ApiGetTimeSeriesMinusDMRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesMinusDMRequest) Cusip(cusip string) ApiGetTimeSeriesMinusDMRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesMinusDMRequest) Outputsize(outputsize int64) ApiGetTimeSeriesMinusDMRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesMinusDMRequest) Exchange(exchange string) ApiGetTimeSeriesMinusDMRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesMinusDMRequest) MicCode(micCode string) ApiGetTimeSeriesMinusDMRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesMinusDMRequest) Country(country string) ApiGetTimeSeriesMinusDMRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesMinusDMRequest) Type_(type_ string) ApiGetTimeSeriesMinusDMRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesMinusDMRequest) Timezone(timezone string) ApiGetTimeSeriesMinusDMRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesMinusDMRequest) StartDate(startDate string) ApiGetTimeSeriesMinusDMRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesMinusDMRequest) EndDate(endDate string) ApiGetTimeSeriesMinusDMRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesMinusDMRequest) Date(date string) ApiGetTimeSeriesMinusDMRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesMinusDMRequest) Order(order string) ApiGetTimeSeriesMinusDMRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesMinusDMRequest) Prepost(prepost bool) ApiGetTimeSeriesMinusDMRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesMinusDMRequest) Format(format string) ApiGetTimeSeriesMinusDMRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesMinusDMRequest) Delimiter(delimiter string) ApiGetTimeSeriesMinusDMRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesMinusDMRequest) Dp(dp int64) ApiGetTimeSeriesMinusDMRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesMinusDMRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesMinusDMRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesMinusDMRequest) Adjust(adjust string) ApiGetTimeSeriesMinusDMRequest {
	r.adjust = &adjust
	return r
}

// Number of periods to average over. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesMinusDMRequest) TimePeriod(timePeriod int64) ApiGetTimeSeriesMinusDMRequest {
	r.timePeriod = &timePeriod
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesMinusDMRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesMinusDMRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesMinusDMRequest) Execute() (*GetTimeSeriesMinusDM200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesMinusDMExecute(r)
}

/*
GetTimeSeriesMinusDM Minus directional movement

The Minus Directional Movement endpoint (MINUS_DM) calculates the downward price movement of a security over a specified period. It returns a series of values indicating the strength of downward trends, useful for traders to identify potential selling opportunities or confirm bearish market conditions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesMinusDMRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesMinusDM(ctx context.Context) ApiGetTimeSeriesMinusDMRequest {
	return ApiGetTimeSeriesMinusDMRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesMinusDM200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesMinusDMExecute(r ApiGetTimeSeriesMinusDMRequest) (*GetTimeSeriesMinusDM200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesMinusDM200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesMinusDM")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/minus_dm"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.timePeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", r.timePeriod, "form", "")
	} else {
        var defaultValue int64 = 9
        parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", defaultValue, "form", "")
        r.timePeriod = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesMomRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	seriesType *string
	timePeriod *int64
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesMomRequest) Interval(interval string) ApiGetTimeSeriesMomRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesMomRequest) Symbol(symbol string) ApiGetTimeSeriesMomRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesMomRequest) Isin(isin string) ApiGetTimeSeriesMomRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesMomRequest) Figi(figi string) ApiGetTimeSeriesMomRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesMomRequest) Cusip(cusip string) ApiGetTimeSeriesMomRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesMomRequest) Outputsize(outputsize int64) ApiGetTimeSeriesMomRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesMomRequest) Exchange(exchange string) ApiGetTimeSeriesMomRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesMomRequest) MicCode(micCode string) ApiGetTimeSeriesMomRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesMomRequest) Country(country string) ApiGetTimeSeriesMomRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesMomRequest) Type_(type_ string) ApiGetTimeSeriesMomRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesMomRequest) Timezone(timezone string) ApiGetTimeSeriesMomRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesMomRequest) StartDate(startDate string) ApiGetTimeSeriesMomRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesMomRequest) EndDate(endDate string) ApiGetTimeSeriesMomRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesMomRequest) Date(date string) ApiGetTimeSeriesMomRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesMomRequest) Order(order string) ApiGetTimeSeriesMomRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesMomRequest) Prepost(prepost bool) ApiGetTimeSeriesMomRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesMomRequest) Format(format string) ApiGetTimeSeriesMomRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesMomRequest) Delimiter(delimiter string) ApiGetTimeSeriesMomRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesMomRequest) Dp(dp int64) ApiGetTimeSeriesMomRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesMomRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesMomRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesMomRequest) Adjust(adjust string) ApiGetTimeSeriesMomRequest {
	r.adjust = &adjust
	return r
}

// Price type on which technical indicator is calculated
func (r ApiGetTimeSeriesMomRequest) SeriesType(seriesType string) ApiGetTimeSeriesMomRequest {
	r.seriesType = &seriesType
	return r
}

// Number of periods to average over. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesMomRequest) TimePeriod(timePeriod int64) ApiGetTimeSeriesMomRequest {
	r.timePeriod = &timePeriod
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesMomRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesMomRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesMomRequest) Execute() (*GetTimeSeriesMom200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesMomExecute(r)
}

/*
GetTimeSeriesMom Momentum

The Momentum (MOM) endpoint provides data on the rate of change in a security's price over a user-defined period. It returns a series of numerical values indicating the speed and direction of the price movement, which can help users detect emerging trends or potential reversals in the market.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesMomRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesMom(ctx context.Context) ApiGetTimeSeriesMomRequest {
	return ApiGetTimeSeriesMomRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesMom200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesMomExecute(r ApiGetTimeSeriesMomRequest) (*GetTimeSeriesMom200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesMom200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesMom")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mom"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.seriesType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", r.seriesType, "form", "")
	} else {
        var defaultValue string = "close"
        parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", defaultValue, "form", "")
        r.seriesType = &defaultValue
	}
	if r.timePeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", r.timePeriod, "form", "")
	} else {
        var defaultValue int64 = 9
        parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", defaultValue, "form", "")
        r.timePeriod = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesMultRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	seriesType1 *string
	seriesType2 *string
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesMultRequest) Interval(interval string) ApiGetTimeSeriesMultRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesMultRequest) Symbol(symbol string) ApiGetTimeSeriesMultRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesMultRequest) Isin(isin string) ApiGetTimeSeriesMultRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesMultRequest) Figi(figi string) ApiGetTimeSeriesMultRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesMultRequest) Cusip(cusip string) ApiGetTimeSeriesMultRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesMultRequest) Outputsize(outputsize int64) ApiGetTimeSeriesMultRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesMultRequest) Exchange(exchange string) ApiGetTimeSeriesMultRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesMultRequest) MicCode(micCode string) ApiGetTimeSeriesMultRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesMultRequest) Country(country string) ApiGetTimeSeriesMultRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesMultRequest) Type_(type_ string) ApiGetTimeSeriesMultRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesMultRequest) Timezone(timezone string) ApiGetTimeSeriesMultRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesMultRequest) StartDate(startDate string) ApiGetTimeSeriesMultRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesMultRequest) EndDate(endDate string) ApiGetTimeSeriesMultRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesMultRequest) Date(date string) ApiGetTimeSeriesMultRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesMultRequest) Order(order string) ApiGetTimeSeriesMultRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesMultRequest) Prepost(prepost bool) ApiGetTimeSeriesMultRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesMultRequest) Format(format string) ApiGetTimeSeriesMultRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesMultRequest) Delimiter(delimiter string) ApiGetTimeSeriesMultRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesMultRequest) Dp(dp int64) ApiGetTimeSeriesMultRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesMultRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesMultRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesMultRequest) Adjust(adjust string) ApiGetTimeSeriesMultRequest {
	r.adjust = &adjust
	return r
}

// Price type used as the first part of technical indicator
func (r ApiGetTimeSeriesMultRequest) SeriesType1(seriesType1 string) ApiGetTimeSeriesMultRequest {
	r.seriesType1 = &seriesType1
	return r
}

// Price type used as the second part of technical indicator
func (r ApiGetTimeSeriesMultRequest) SeriesType2(seriesType2 string) ApiGetTimeSeriesMultRequest {
	r.seriesType2 = &seriesType2
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesMultRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesMultRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesMultRequest) Execute() (*GetTimeSeriesMult200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesMultExecute(r)
}

/*
GetTimeSeriesMult Multiplication

The Multiplication (MULT) endpoint calculates the product of two input data series, returning a new data series that represents the element-wise multiplication of the inputs. This is useful for combining or adjusting technical indicators or price data to create custom metrics or to normalize values across different scales.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesMultRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesMult(ctx context.Context) ApiGetTimeSeriesMultRequest {
	return ApiGetTimeSeriesMultRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesMult200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesMultExecute(r ApiGetTimeSeriesMultRequest) (*GetTimeSeriesMult200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesMult200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesMult")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mult"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.seriesType1 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "series_type_1", r.seriesType1, "form", "")
	} else {
        var defaultValue string = "open"
        parameterAddToHeaderOrQuery(localVarQueryParams, "series_type_1", defaultValue, "form", "")
        r.seriesType1 = &defaultValue
	}
	if r.seriesType2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "series_type_2", r.seriesType2, "form", "")
	} else {
        var defaultValue string = "close"
        parameterAddToHeaderOrQuery(localVarQueryParams, "series_type_2", defaultValue, "form", "")
        r.seriesType2 = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesNatrRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	timePeriod *int64
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesNatrRequest) Interval(interval string) ApiGetTimeSeriesNatrRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesNatrRequest) Symbol(symbol string) ApiGetTimeSeriesNatrRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesNatrRequest) Isin(isin string) ApiGetTimeSeriesNatrRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesNatrRequest) Figi(figi string) ApiGetTimeSeriesNatrRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesNatrRequest) Cusip(cusip string) ApiGetTimeSeriesNatrRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesNatrRequest) Outputsize(outputsize int64) ApiGetTimeSeriesNatrRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesNatrRequest) Exchange(exchange string) ApiGetTimeSeriesNatrRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesNatrRequest) MicCode(micCode string) ApiGetTimeSeriesNatrRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesNatrRequest) Country(country string) ApiGetTimeSeriesNatrRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesNatrRequest) Type_(type_ string) ApiGetTimeSeriesNatrRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesNatrRequest) Timezone(timezone string) ApiGetTimeSeriesNatrRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesNatrRequest) StartDate(startDate string) ApiGetTimeSeriesNatrRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesNatrRequest) EndDate(endDate string) ApiGetTimeSeriesNatrRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesNatrRequest) Date(date string) ApiGetTimeSeriesNatrRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesNatrRequest) Order(order string) ApiGetTimeSeriesNatrRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesNatrRequest) Prepost(prepost bool) ApiGetTimeSeriesNatrRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesNatrRequest) Format(format string) ApiGetTimeSeriesNatrRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesNatrRequest) Delimiter(delimiter string) ApiGetTimeSeriesNatrRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesNatrRequest) Dp(dp int64) ApiGetTimeSeriesNatrRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesNatrRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesNatrRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesNatrRequest) Adjust(adjust string) ApiGetTimeSeriesNatrRequest {
	r.adjust = &adjust
	return r
}

// Number of periods to average over. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesNatrRequest) TimePeriod(timePeriod int64) ApiGetTimeSeriesNatrRequest {
	r.timePeriod = &timePeriod
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesNatrRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesNatrRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesNatrRequest) Execute() (*GetTimeSeriesNatr200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesNatrExecute(r)
}

/*
GetTimeSeriesNatr Normalized average true range

The Normalized Average True Range (NATR) endpoint provides a volatility indicator that calculates the average range of price movement over a specified period, expressed as a percentage of the security's price. This data allows users to compare volatility levels across different securities easily. The endpoint returns a time series of NATR values, which can be used to assess and compare the price volatility of various financial instruments.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesNatrRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesNatr(ctx context.Context) ApiGetTimeSeriesNatrRequest {
	return ApiGetTimeSeriesNatrRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesNatr200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesNatrExecute(r ApiGetTimeSeriesNatrRequest) (*GetTimeSeriesNatr200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesNatr200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesNatr")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/natr"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.timePeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", r.timePeriod, "form", "")
	} else {
        var defaultValue int64 = 14
        parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", defaultValue, "form", "")
        r.timePeriod = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesObvRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	seriesType *string
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesObvRequest) Interval(interval string) ApiGetTimeSeriesObvRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesObvRequest) Symbol(symbol string) ApiGetTimeSeriesObvRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesObvRequest) Isin(isin string) ApiGetTimeSeriesObvRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesObvRequest) Figi(figi string) ApiGetTimeSeriesObvRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesObvRequest) Cusip(cusip string) ApiGetTimeSeriesObvRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesObvRequest) Outputsize(outputsize int64) ApiGetTimeSeriesObvRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesObvRequest) Exchange(exchange string) ApiGetTimeSeriesObvRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesObvRequest) MicCode(micCode string) ApiGetTimeSeriesObvRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesObvRequest) Country(country string) ApiGetTimeSeriesObvRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesObvRequest) Type_(type_ string) ApiGetTimeSeriesObvRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesObvRequest) Timezone(timezone string) ApiGetTimeSeriesObvRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesObvRequest) StartDate(startDate string) ApiGetTimeSeriesObvRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesObvRequest) EndDate(endDate string) ApiGetTimeSeriesObvRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesObvRequest) Date(date string) ApiGetTimeSeriesObvRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesObvRequest) Order(order string) ApiGetTimeSeriesObvRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesObvRequest) Prepost(prepost bool) ApiGetTimeSeriesObvRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesObvRequest) Format(format string) ApiGetTimeSeriesObvRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesObvRequest) Delimiter(delimiter string) ApiGetTimeSeriesObvRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesObvRequest) Dp(dp int64) ApiGetTimeSeriesObvRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesObvRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesObvRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesObvRequest) Adjust(adjust string) ApiGetTimeSeriesObvRequest {
	r.adjust = &adjust
	return r
}

// Price type on which technical indicator is calculated
func (r ApiGetTimeSeriesObvRequest) SeriesType(seriesType string) ApiGetTimeSeriesObvRequest {
	r.seriesType = &seriesType
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesObvRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesObvRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesObvRequest) Execute() (*GetTimeSeriesObv200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesObvExecute(r)
}

/*
GetTimeSeriesObv On balance volume

The On Balance Volume (OBV) endpoint provides a time series of the OBV indicator, which calculates cumulative volume to reflect buying and selling pressure over time. This endpoint returns data that helps users track volume trends in relation to price movements, aiding in the identification of potential trend continuations or reversals in a security's price.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesObvRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesObv(ctx context.Context) ApiGetTimeSeriesObvRequest {
	return ApiGetTimeSeriesObvRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesObv200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesObvExecute(r ApiGetTimeSeriesObvRequest) (*GetTimeSeriesObv200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesObv200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesObv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/obv"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.seriesType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", r.seriesType, "form", "")
	} else {
        var defaultValue string = "close"
        parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", defaultValue, "form", "")
        r.seriesType = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesPercentBRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	seriesType *string
	timePeriod *int64
	sd *float64
	maType *string
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesPercentBRequest) Interval(interval string) ApiGetTimeSeriesPercentBRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesPercentBRequest) Symbol(symbol string) ApiGetTimeSeriesPercentBRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesPercentBRequest) Isin(isin string) ApiGetTimeSeriesPercentBRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesPercentBRequest) Figi(figi string) ApiGetTimeSeriesPercentBRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesPercentBRequest) Cusip(cusip string) ApiGetTimeSeriesPercentBRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesPercentBRequest) Outputsize(outputsize int64) ApiGetTimeSeriesPercentBRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesPercentBRequest) Exchange(exchange string) ApiGetTimeSeriesPercentBRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesPercentBRequest) MicCode(micCode string) ApiGetTimeSeriesPercentBRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesPercentBRequest) Country(country string) ApiGetTimeSeriesPercentBRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesPercentBRequest) Type_(type_ string) ApiGetTimeSeriesPercentBRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesPercentBRequest) Timezone(timezone string) ApiGetTimeSeriesPercentBRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesPercentBRequest) StartDate(startDate string) ApiGetTimeSeriesPercentBRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesPercentBRequest) EndDate(endDate string) ApiGetTimeSeriesPercentBRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesPercentBRequest) Date(date string) ApiGetTimeSeriesPercentBRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesPercentBRequest) Order(order string) ApiGetTimeSeriesPercentBRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesPercentBRequest) Prepost(prepost bool) ApiGetTimeSeriesPercentBRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesPercentBRequest) Format(format string) ApiGetTimeSeriesPercentBRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesPercentBRequest) Delimiter(delimiter string) ApiGetTimeSeriesPercentBRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesPercentBRequest) Dp(dp int64) ApiGetTimeSeriesPercentBRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesPercentBRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesPercentBRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesPercentBRequest) Adjust(adjust string) ApiGetTimeSeriesPercentBRequest {
	r.adjust = &adjust
	return r
}

// Price type on which technical indicator is calculated
func (r ApiGetTimeSeriesPercentBRequest) SeriesType(seriesType string) ApiGetTimeSeriesPercentBRequest {
	r.seriesType = &seriesType
	return r
}

// Number of periods to average over. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesPercentBRequest) TimePeriod(timePeriod int64) ApiGetTimeSeriesPercentBRequest {
	r.timePeriod = &timePeriod
	return r
}

// The standard deviation applied in the calculation.  Must be at least &#x60;1&#x60;
func (r ApiGetTimeSeriesPercentBRequest) Sd(sd float64) ApiGetTimeSeriesPercentBRequest {
	r.sd = &sd
	return r
}

// The type of moving average used
func (r ApiGetTimeSeriesPercentBRequest) MaType(maType string) ApiGetTimeSeriesPercentBRequest {
	r.maType = &maType
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesPercentBRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesPercentBRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesPercentBRequest) Execute() (*GetTimeSeriesPercentB200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesPercentBExecute(r)
}

/*
GetTimeSeriesPercentB Percent B

The Percent B (%B) endpoint calculates and returns the %B value, which indicates the position of a security's price relative to its Bollinger Bands. This data helps users determine if a security is near the upper or lower band, potentially signaling overbought or oversold conditions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesPercentBRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesPercentB(ctx context.Context) ApiGetTimeSeriesPercentBRequest {
	return ApiGetTimeSeriesPercentBRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesPercentB200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesPercentBExecute(r ApiGetTimeSeriesPercentBRequest) (*GetTimeSeriesPercentB200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesPercentB200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesPercentB")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/percent_b"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.seriesType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", r.seriesType, "form", "")
	} else {
        var defaultValue string = "close"
        parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", defaultValue, "form", "")
        r.seriesType = &defaultValue
	}
	if r.timePeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", r.timePeriod, "form", "")
	} else {
        var defaultValue int64 = 9
        parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", defaultValue, "form", "")
        r.timePeriod = &defaultValue
	}
	if r.sd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sd", r.sd, "form", "")
	} else {
        var defaultValue float64 = 2
        parameterAddToHeaderOrQuery(localVarQueryParams, "sd", defaultValue, "form", "")
        r.sd = &defaultValue
	}
	if r.maType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ma_type", r.maType, "form", "")
	} else {
        var defaultValue string = "SMA"
        parameterAddToHeaderOrQuery(localVarQueryParams, "ma_type", defaultValue, "form", "")
        r.maType = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesPivotPointsHLRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	timePeriod *int64
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesPivotPointsHLRequest) Interval(interval string) ApiGetTimeSeriesPivotPointsHLRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesPivotPointsHLRequest) Symbol(symbol string) ApiGetTimeSeriesPivotPointsHLRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesPivotPointsHLRequest) Isin(isin string) ApiGetTimeSeriesPivotPointsHLRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesPivotPointsHLRequest) Figi(figi string) ApiGetTimeSeriesPivotPointsHLRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesPivotPointsHLRequest) Cusip(cusip string) ApiGetTimeSeriesPivotPointsHLRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesPivotPointsHLRequest) Outputsize(outputsize int64) ApiGetTimeSeriesPivotPointsHLRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesPivotPointsHLRequest) Exchange(exchange string) ApiGetTimeSeriesPivotPointsHLRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesPivotPointsHLRequest) MicCode(micCode string) ApiGetTimeSeriesPivotPointsHLRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesPivotPointsHLRequest) Country(country string) ApiGetTimeSeriesPivotPointsHLRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesPivotPointsHLRequest) Type_(type_ string) ApiGetTimeSeriesPivotPointsHLRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesPivotPointsHLRequest) Timezone(timezone string) ApiGetTimeSeriesPivotPointsHLRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesPivotPointsHLRequest) StartDate(startDate string) ApiGetTimeSeriesPivotPointsHLRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesPivotPointsHLRequest) EndDate(endDate string) ApiGetTimeSeriesPivotPointsHLRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesPivotPointsHLRequest) Date(date string) ApiGetTimeSeriesPivotPointsHLRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesPivotPointsHLRequest) Order(order string) ApiGetTimeSeriesPivotPointsHLRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesPivotPointsHLRequest) Prepost(prepost bool) ApiGetTimeSeriesPivotPointsHLRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesPivotPointsHLRequest) Format(format string) ApiGetTimeSeriesPivotPointsHLRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesPivotPointsHLRequest) Delimiter(delimiter string) ApiGetTimeSeriesPivotPointsHLRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesPivotPointsHLRequest) Dp(dp int64) ApiGetTimeSeriesPivotPointsHLRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesPivotPointsHLRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesPivotPointsHLRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesPivotPointsHLRequest) Adjust(adjust string) ApiGetTimeSeriesPivotPointsHLRequest {
	r.adjust = &adjust
	return r
}

// Number of periods to average over. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesPivotPointsHLRequest) TimePeriod(timePeriod int64) ApiGetTimeSeriesPivotPointsHLRequest {
	r.timePeriod = &timePeriod
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesPivotPointsHLRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesPivotPointsHLRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesPivotPointsHLRequest) Execute() (*GetTimeSeriesPivotPointsHL200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesPivotPointsHLExecute(r)
}

/*
GetTimeSeriesPivotPointsHL Pivot points high low

The Pivot Points High Low (PIVOT_POINTS_HL) endpoint calculates key support and resistance levels for a security by analyzing its highest and lowest prices over a specified period. This endpoint returns data that includes pivot points, support levels, and resistance levels, which can be used to identify potential price reversal zones and optimize trade entry and exit strategies.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesPivotPointsHLRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesPivotPointsHL(ctx context.Context) ApiGetTimeSeriesPivotPointsHLRequest {
	return ApiGetTimeSeriesPivotPointsHLRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesPivotPointsHL200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesPivotPointsHLExecute(r ApiGetTimeSeriesPivotPointsHLRequest) (*GetTimeSeriesPivotPointsHL200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesPivotPointsHL200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesPivotPointsHL")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pivot_points_hl"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.timePeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", r.timePeriod, "form", "")
	} else {
        var defaultValue int64 = 10
        parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", defaultValue, "form", "")
        r.timePeriod = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesPlusDIRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	timePeriod *int64
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesPlusDIRequest) Interval(interval string) ApiGetTimeSeriesPlusDIRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesPlusDIRequest) Symbol(symbol string) ApiGetTimeSeriesPlusDIRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesPlusDIRequest) Isin(isin string) ApiGetTimeSeriesPlusDIRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesPlusDIRequest) Figi(figi string) ApiGetTimeSeriesPlusDIRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesPlusDIRequest) Cusip(cusip string) ApiGetTimeSeriesPlusDIRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesPlusDIRequest) Outputsize(outputsize int64) ApiGetTimeSeriesPlusDIRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesPlusDIRequest) Exchange(exchange string) ApiGetTimeSeriesPlusDIRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesPlusDIRequest) MicCode(micCode string) ApiGetTimeSeriesPlusDIRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesPlusDIRequest) Country(country string) ApiGetTimeSeriesPlusDIRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesPlusDIRequest) Type_(type_ string) ApiGetTimeSeriesPlusDIRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesPlusDIRequest) Timezone(timezone string) ApiGetTimeSeriesPlusDIRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesPlusDIRequest) StartDate(startDate string) ApiGetTimeSeriesPlusDIRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesPlusDIRequest) EndDate(endDate string) ApiGetTimeSeriesPlusDIRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesPlusDIRequest) Date(date string) ApiGetTimeSeriesPlusDIRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesPlusDIRequest) Order(order string) ApiGetTimeSeriesPlusDIRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesPlusDIRequest) Prepost(prepost bool) ApiGetTimeSeriesPlusDIRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesPlusDIRequest) Format(format string) ApiGetTimeSeriesPlusDIRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesPlusDIRequest) Delimiter(delimiter string) ApiGetTimeSeriesPlusDIRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesPlusDIRequest) Dp(dp int64) ApiGetTimeSeriesPlusDIRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesPlusDIRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesPlusDIRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesPlusDIRequest) Adjust(adjust string) ApiGetTimeSeriesPlusDIRequest {
	r.adjust = &adjust
	return r
}

// Number of periods to average over. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesPlusDIRequest) TimePeriod(timePeriod int64) ApiGetTimeSeriesPlusDIRequest {
	r.timePeriod = &timePeriod
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesPlusDIRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesPlusDIRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesPlusDIRequest) Execute() (*GetTimeSeriesPlusDI200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesPlusDIExecute(r)
}

/*
GetTimeSeriesPlusDI Plus directional indicator

The Plus Directional Indicator endpoint (/plus_di) provides data on the strength of a security's upward price movement by calculating the Plus Directional Indicator (PLUS_DI). It returns a time series of PLUS_DI values, which can be used to assess the intensity of upward trends in a security's price over a specified period.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesPlusDIRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesPlusDI(ctx context.Context) ApiGetTimeSeriesPlusDIRequest {
	return ApiGetTimeSeriesPlusDIRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesPlusDI200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesPlusDIExecute(r ApiGetTimeSeriesPlusDIRequest) (*GetTimeSeriesPlusDI200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesPlusDI200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesPlusDI")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/plus_di"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.timePeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", r.timePeriod, "form", "")
	} else {
        var defaultValue int64 = 9
        parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", defaultValue, "form", "")
        r.timePeriod = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesPlusDMRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	timePeriod *int64
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesPlusDMRequest) Interval(interval string) ApiGetTimeSeriesPlusDMRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesPlusDMRequest) Symbol(symbol string) ApiGetTimeSeriesPlusDMRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesPlusDMRequest) Isin(isin string) ApiGetTimeSeriesPlusDMRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesPlusDMRequest) Figi(figi string) ApiGetTimeSeriesPlusDMRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesPlusDMRequest) Cusip(cusip string) ApiGetTimeSeriesPlusDMRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesPlusDMRequest) Outputsize(outputsize int64) ApiGetTimeSeriesPlusDMRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesPlusDMRequest) Exchange(exchange string) ApiGetTimeSeriesPlusDMRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesPlusDMRequest) MicCode(micCode string) ApiGetTimeSeriesPlusDMRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesPlusDMRequest) Country(country string) ApiGetTimeSeriesPlusDMRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesPlusDMRequest) Type_(type_ string) ApiGetTimeSeriesPlusDMRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesPlusDMRequest) Timezone(timezone string) ApiGetTimeSeriesPlusDMRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesPlusDMRequest) StartDate(startDate string) ApiGetTimeSeriesPlusDMRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesPlusDMRequest) EndDate(endDate string) ApiGetTimeSeriesPlusDMRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesPlusDMRequest) Date(date string) ApiGetTimeSeriesPlusDMRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesPlusDMRequest) Order(order string) ApiGetTimeSeriesPlusDMRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesPlusDMRequest) Prepost(prepost bool) ApiGetTimeSeriesPlusDMRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesPlusDMRequest) Format(format string) ApiGetTimeSeriesPlusDMRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesPlusDMRequest) Delimiter(delimiter string) ApiGetTimeSeriesPlusDMRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesPlusDMRequest) Dp(dp int64) ApiGetTimeSeriesPlusDMRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesPlusDMRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesPlusDMRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesPlusDMRequest) Adjust(adjust string) ApiGetTimeSeriesPlusDMRequest {
	r.adjust = &adjust
	return r
}

// Number of periods to average over. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesPlusDMRequest) TimePeriod(timePeriod int64) ApiGetTimeSeriesPlusDMRequest {
	r.timePeriod = &timePeriod
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesPlusDMRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesPlusDMRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesPlusDMRequest) Execute() (*GetTimeSeriesPlusDM200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesPlusDMExecute(r)
}

/*
GetTimeSeriesPlusDM Plus directional movement

The Plus Directional Movement (PLUS_DM) endpoint calculates the upward price movement of a financial security over a specified period. It returns numerical values representing the magnitude of upward price changes, which can be used to assess the strength of an uptrend. This data is essential for traders and analysts who need to evaluate the bullish momentum of a security.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesPlusDMRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesPlusDM(ctx context.Context) ApiGetTimeSeriesPlusDMRequest {
	return ApiGetTimeSeriesPlusDMRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesPlusDM200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesPlusDMExecute(r ApiGetTimeSeriesPlusDMRequest) (*GetTimeSeriesPlusDM200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesPlusDM200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesPlusDM")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/plus_dm"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.timePeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", r.timePeriod, "form", "")
	} else {
        var defaultValue int64 = 9
        parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", defaultValue, "form", "")
        r.timePeriod = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesPpoRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	seriesType *string
	fastPeriod *int64
	slowPeriod *int64
	maType *string
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesPpoRequest) Interval(interval string) ApiGetTimeSeriesPpoRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesPpoRequest) Symbol(symbol string) ApiGetTimeSeriesPpoRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesPpoRequest) Isin(isin string) ApiGetTimeSeriesPpoRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesPpoRequest) Figi(figi string) ApiGetTimeSeriesPpoRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesPpoRequest) Cusip(cusip string) ApiGetTimeSeriesPpoRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesPpoRequest) Outputsize(outputsize int64) ApiGetTimeSeriesPpoRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesPpoRequest) Exchange(exchange string) ApiGetTimeSeriesPpoRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesPpoRequest) MicCode(micCode string) ApiGetTimeSeriesPpoRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesPpoRequest) Country(country string) ApiGetTimeSeriesPpoRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesPpoRequest) Type_(type_ string) ApiGetTimeSeriesPpoRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesPpoRequest) Timezone(timezone string) ApiGetTimeSeriesPpoRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesPpoRequest) StartDate(startDate string) ApiGetTimeSeriesPpoRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesPpoRequest) EndDate(endDate string) ApiGetTimeSeriesPpoRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesPpoRequest) Date(date string) ApiGetTimeSeriesPpoRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesPpoRequest) Order(order string) ApiGetTimeSeriesPpoRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesPpoRequest) Prepost(prepost bool) ApiGetTimeSeriesPpoRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesPpoRequest) Format(format string) ApiGetTimeSeriesPpoRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesPpoRequest) Delimiter(delimiter string) ApiGetTimeSeriesPpoRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesPpoRequest) Dp(dp int64) ApiGetTimeSeriesPpoRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesPpoRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesPpoRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesPpoRequest) Adjust(adjust string) ApiGetTimeSeriesPpoRequest {
	r.adjust = &adjust
	return r
}

// Price type on which technical indicator is calculated
func (r ApiGetTimeSeriesPpoRequest) SeriesType(seriesType string) ApiGetTimeSeriesPpoRequest {
	r.seriesType = &seriesType
	return r
}

// Number of periods for fast moving average. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesPpoRequest) FastPeriod(fastPeriod int64) ApiGetTimeSeriesPpoRequest {
	r.fastPeriod = &fastPeriod
	return r
}

// Number of periods for slow moving average. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesPpoRequest) SlowPeriod(slowPeriod int64) ApiGetTimeSeriesPpoRequest {
	r.slowPeriod = &slowPeriod
	return r
}

// The type of moving average used
func (r ApiGetTimeSeriesPpoRequest) MaType(maType string) ApiGetTimeSeriesPpoRequest {
	r.maType = &maType
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesPpoRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesPpoRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesPpoRequest) Execute() (*GetTimeSeriesPpo200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesPpoExecute(r)
}

/*
GetTimeSeriesPpo Percentage price oscillator

The Percentage Price Oscillator (PPO) endpoint calculates the percentage difference between two specified moving averages of a financial instrument's price. It returns data that includes the PPO values, which traders can use to identify potential trend reversals and generate trading signals.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesPpoRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesPpo(ctx context.Context) ApiGetTimeSeriesPpoRequest {
	return ApiGetTimeSeriesPpoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesPpo200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesPpoExecute(r ApiGetTimeSeriesPpoRequest) (*GetTimeSeriesPpo200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesPpo200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesPpo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ppo"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.seriesType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", r.seriesType, "form", "")
	} else {
        var defaultValue string = "close"
        parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", defaultValue, "form", "")
        r.seriesType = &defaultValue
	}
	if r.fastPeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fast_period", r.fastPeriod, "form", "")
	} else {
        var defaultValue int64 = 12
        parameterAddToHeaderOrQuery(localVarQueryParams, "fast_period", defaultValue, "form", "")
        r.fastPeriod = &defaultValue
	}
	if r.slowPeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "slow_period", r.slowPeriod, "form", "")
	} else {
        var defaultValue int64 = 26
        parameterAddToHeaderOrQuery(localVarQueryParams, "slow_period", defaultValue, "form", "")
        r.slowPeriod = &defaultValue
	}
	if r.maType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ma_type", r.maType, "form", "")
	} else {
        var defaultValue string = "SMA"
        parameterAddToHeaderOrQuery(localVarQueryParams, "ma_type", defaultValue, "form", "")
        r.maType = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesRocRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	seriesType *string
	timePeriod *int64
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesRocRequest) Interval(interval string) ApiGetTimeSeriesRocRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesRocRequest) Symbol(symbol string) ApiGetTimeSeriesRocRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesRocRequest) Isin(isin string) ApiGetTimeSeriesRocRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesRocRequest) Figi(figi string) ApiGetTimeSeriesRocRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesRocRequest) Cusip(cusip string) ApiGetTimeSeriesRocRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesRocRequest) Outputsize(outputsize int64) ApiGetTimeSeriesRocRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesRocRequest) Exchange(exchange string) ApiGetTimeSeriesRocRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesRocRequest) MicCode(micCode string) ApiGetTimeSeriesRocRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesRocRequest) Country(country string) ApiGetTimeSeriesRocRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesRocRequest) Type_(type_ string) ApiGetTimeSeriesRocRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesRocRequest) Timezone(timezone string) ApiGetTimeSeriesRocRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesRocRequest) StartDate(startDate string) ApiGetTimeSeriesRocRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesRocRequest) EndDate(endDate string) ApiGetTimeSeriesRocRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesRocRequest) Date(date string) ApiGetTimeSeriesRocRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesRocRequest) Order(order string) ApiGetTimeSeriesRocRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesRocRequest) Prepost(prepost bool) ApiGetTimeSeriesRocRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesRocRequest) Format(format string) ApiGetTimeSeriesRocRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesRocRequest) Delimiter(delimiter string) ApiGetTimeSeriesRocRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesRocRequest) Dp(dp int64) ApiGetTimeSeriesRocRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesRocRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesRocRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesRocRequest) Adjust(adjust string) ApiGetTimeSeriesRocRequest {
	r.adjust = &adjust
	return r
}

// Price type on which technical indicator is calculated
func (r ApiGetTimeSeriesRocRequest) SeriesType(seriesType string) ApiGetTimeSeriesRocRequest {
	r.seriesType = &seriesType
	return r
}

// Number of periods to average over. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesRocRequest) TimePeriod(timePeriod int64) ApiGetTimeSeriesRocRequest {
	r.timePeriod = &timePeriod
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesRocRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesRocRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesRocRequest) Execute() (*GetTimeSeriesRoc200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesRocExecute(r)
}

/*
GetTimeSeriesRoc Rate of change

The Rate of Change (ROC) endpoint calculates the percentage change in a security's price over a defined period, returning a time series of ROC values. This data helps users track momentum by showing how quickly prices are changing, which can be useful for identifying potential price movements.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesRocRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesRoc(ctx context.Context) ApiGetTimeSeriesRocRequest {
	return ApiGetTimeSeriesRocRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesRoc200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesRocExecute(r ApiGetTimeSeriesRocRequest) (*GetTimeSeriesRoc200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesRoc200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesRoc")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roc"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.seriesType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", r.seriesType, "form", "")
	} else {
        var defaultValue string = "close"
        parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", defaultValue, "form", "")
        r.seriesType = &defaultValue
	}
	if r.timePeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", r.timePeriod, "form", "")
	} else {
        var defaultValue int64 = 9
        parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", defaultValue, "form", "")
        r.timePeriod = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesRocpRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	seriesType *string
	timePeriod *int64
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesRocpRequest) Interval(interval string) ApiGetTimeSeriesRocpRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesRocpRequest) Symbol(symbol string) ApiGetTimeSeriesRocpRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesRocpRequest) Isin(isin string) ApiGetTimeSeriesRocpRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesRocpRequest) Figi(figi string) ApiGetTimeSeriesRocpRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesRocpRequest) Cusip(cusip string) ApiGetTimeSeriesRocpRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesRocpRequest) Outputsize(outputsize int64) ApiGetTimeSeriesRocpRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesRocpRequest) Exchange(exchange string) ApiGetTimeSeriesRocpRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesRocpRequest) MicCode(micCode string) ApiGetTimeSeriesRocpRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesRocpRequest) Country(country string) ApiGetTimeSeriesRocpRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesRocpRequest) Type_(type_ string) ApiGetTimeSeriesRocpRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesRocpRequest) Timezone(timezone string) ApiGetTimeSeriesRocpRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesRocpRequest) StartDate(startDate string) ApiGetTimeSeriesRocpRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesRocpRequest) EndDate(endDate string) ApiGetTimeSeriesRocpRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesRocpRequest) Date(date string) ApiGetTimeSeriesRocpRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesRocpRequest) Order(order string) ApiGetTimeSeriesRocpRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesRocpRequest) Prepost(prepost bool) ApiGetTimeSeriesRocpRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesRocpRequest) Format(format string) ApiGetTimeSeriesRocpRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesRocpRequest) Delimiter(delimiter string) ApiGetTimeSeriesRocpRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesRocpRequest) Dp(dp int64) ApiGetTimeSeriesRocpRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesRocpRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesRocpRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesRocpRequest) Adjust(adjust string) ApiGetTimeSeriesRocpRequest {
	r.adjust = &adjust
	return r
}

// Price type on which technical indicator is calculated
func (r ApiGetTimeSeriesRocpRequest) SeriesType(seriesType string) ApiGetTimeSeriesRocpRequest {
	r.seriesType = &seriesType
	return r
}

// Number of periods to average over. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesRocpRequest) TimePeriod(timePeriod int64) ApiGetTimeSeriesRocpRequest {
	r.timePeriod = &timePeriod
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesRocpRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesRocpRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesRocpRequest) Execute() (*GetTimeSeriesRocp200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesRocpExecute(r)
}

/*
GetTimeSeriesRocp Rate of change percentage

The Rate of Change Percentage (ROCP) endpoint calculates and returns the percentage change in the price of a financial security over a user-defined period. This data helps users identify shifts in price momentum and potential trend reversals by providing a clear numerical representation of how much the price has increased or decreased in percentage terms.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesRocpRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesRocp(ctx context.Context) ApiGetTimeSeriesRocpRequest {
	return ApiGetTimeSeriesRocpRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesRocp200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesRocpExecute(r ApiGetTimeSeriesRocpRequest) (*GetTimeSeriesRocp200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesRocp200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesRocp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rocp"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.seriesType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", r.seriesType, "form", "")
	} else {
        var defaultValue string = "close"
        parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", defaultValue, "form", "")
        r.seriesType = &defaultValue
	}
	if r.timePeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", r.timePeriod, "form", "")
	} else {
        var defaultValue int64 = 9
        parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", defaultValue, "form", "")
        r.timePeriod = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesRocrRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	seriesType *string
	timePeriod *int64
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesRocrRequest) Interval(interval string) ApiGetTimeSeriesRocrRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesRocrRequest) Symbol(symbol string) ApiGetTimeSeriesRocrRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesRocrRequest) Isin(isin string) ApiGetTimeSeriesRocrRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesRocrRequest) Figi(figi string) ApiGetTimeSeriesRocrRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesRocrRequest) Cusip(cusip string) ApiGetTimeSeriesRocrRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesRocrRequest) Outputsize(outputsize int64) ApiGetTimeSeriesRocrRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesRocrRequest) Exchange(exchange string) ApiGetTimeSeriesRocrRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesRocrRequest) MicCode(micCode string) ApiGetTimeSeriesRocrRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesRocrRequest) Country(country string) ApiGetTimeSeriesRocrRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesRocrRequest) Type_(type_ string) ApiGetTimeSeriesRocrRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesRocrRequest) Timezone(timezone string) ApiGetTimeSeriesRocrRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesRocrRequest) StartDate(startDate string) ApiGetTimeSeriesRocrRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesRocrRequest) EndDate(endDate string) ApiGetTimeSeriesRocrRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesRocrRequest) Date(date string) ApiGetTimeSeriesRocrRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesRocrRequest) Order(order string) ApiGetTimeSeriesRocrRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesRocrRequest) Prepost(prepost bool) ApiGetTimeSeriesRocrRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesRocrRequest) Format(format string) ApiGetTimeSeriesRocrRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesRocrRequest) Delimiter(delimiter string) ApiGetTimeSeriesRocrRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesRocrRequest) Dp(dp int64) ApiGetTimeSeriesRocrRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesRocrRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesRocrRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesRocrRequest) Adjust(adjust string) ApiGetTimeSeriesRocrRequest {
	r.adjust = &adjust
	return r
}

// Price type on which technical indicator is calculated
func (r ApiGetTimeSeriesRocrRequest) SeriesType(seriesType string) ApiGetTimeSeriesRocrRequest {
	r.seriesType = &seriesType
	return r
}

// Number of periods to average over. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesRocrRequest) TimePeriod(timePeriod int64) ApiGetTimeSeriesRocrRequest {
	r.timePeriod = &timePeriod
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesRocrRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesRocrRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesRocrRequest) Execute() (*GetTimeSeriesRocr200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesRocrExecute(r)
}

/*
GetTimeSeriesRocr Rate of change ratio

The Rate of Change Ratio (ROCR) endpoint calculates and returns the ratio of a security's current price to its price from a specified number of periods ago. This data helps users track price momentum and identify potential trend reversals by providing a clear numerical value that reflects price changes over time.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesRocrRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesRocr(ctx context.Context) ApiGetTimeSeriesRocrRequest {
	return ApiGetTimeSeriesRocrRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesRocr200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesRocrExecute(r ApiGetTimeSeriesRocrRequest) (*GetTimeSeriesRocr200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesRocr200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesRocr")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rocr"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.seriesType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", r.seriesType, "form", "")
	} else {
        var defaultValue string = "close"
        parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", defaultValue, "form", "")
        r.seriesType = &defaultValue
	}
	if r.timePeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", r.timePeriod, "form", "")
	} else {
        var defaultValue int64 = 9
        parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", defaultValue, "form", "")
        r.timePeriod = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesRocr100Request struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	seriesType *string
	timePeriod *int64
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesRocr100Request) Interval(interval string) ApiGetTimeSeriesRocr100Request {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesRocr100Request) Symbol(symbol string) ApiGetTimeSeriesRocr100Request {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesRocr100Request) Isin(isin string) ApiGetTimeSeriesRocr100Request {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesRocr100Request) Figi(figi string) ApiGetTimeSeriesRocr100Request {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesRocr100Request) Cusip(cusip string) ApiGetTimeSeriesRocr100Request {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesRocr100Request) Outputsize(outputsize int64) ApiGetTimeSeriesRocr100Request {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesRocr100Request) Exchange(exchange string) ApiGetTimeSeriesRocr100Request {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesRocr100Request) MicCode(micCode string) ApiGetTimeSeriesRocr100Request {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesRocr100Request) Country(country string) ApiGetTimeSeriesRocr100Request {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesRocr100Request) Type_(type_ string) ApiGetTimeSeriesRocr100Request {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesRocr100Request) Timezone(timezone string) ApiGetTimeSeriesRocr100Request {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesRocr100Request) StartDate(startDate string) ApiGetTimeSeriesRocr100Request {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesRocr100Request) EndDate(endDate string) ApiGetTimeSeriesRocr100Request {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesRocr100Request) Date(date string) ApiGetTimeSeriesRocr100Request {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesRocr100Request) Order(order string) ApiGetTimeSeriesRocr100Request {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesRocr100Request) Prepost(prepost bool) ApiGetTimeSeriesRocr100Request {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesRocr100Request) Format(format string) ApiGetTimeSeriesRocr100Request {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesRocr100Request) Delimiter(delimiter string) ApiGetTimeSeriesRocr100Request {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesRocr100Request) Dp(dp int64) ApiGetTimeSeriesRocr100Request {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesRocr100Request) PreviousClose(previousClose bool) ApiGetTimeSeriesRocr100Request {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesRocr100Request) Adjust(adjust string) ApiGetTimeSeriesRocr100Request {
	r.adjust = &adjust
	return r
}

// Price type on which technical indicator is calculated
func (r ApiGetTimeSeriesRocr100Request) SeriesType(seriesType string) ApiGetTimeSeriesRocr100Request {
	r.seriesType = &seriesType
	return r
}

// Number of periods to average over. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesRocr100Request) TimePeriod(timePeriod int64) ApiGetTimeSeriesRocr100Request {
	r.timePeriod = &timePeriod
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesRocr100Request) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesRocr100Request {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesRocr100Request) Execute() (*GetTimeSeriesRocr100200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesRocr100Execute(r)
}

/*
GetTimeSeriesRocr100 Rate of change ratio 100

The Rate of Change Ratio 100 (ROCR100) endpoint calculates the percentage change in a security's price over a specified period, expressed as a ratio to 100. It returns data that highlights the momentum of the price movement and identifies potential trend reversals. This endpoint is useful for users looking to assess the strength and direction of a security's price trend over time.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesRocr100Request
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesRocr100(ctx context.Context) ApiGetTimeSeriesRocr100Request {
	return ApiGetTimeSeriesRocr100Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesRocr100200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesRocr100Execute(r ApiGetTimeSeriesRocr100Request) (*GetTimeSeriesRocr100200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesRocr100200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesRocr100")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rocr100"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.seriesType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", r.seriesType, "form", "")
	} else {
        var defaultValue string = "close"
        parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", defaultValue, "form", "")
        r.seriesType = &defaultValue
	}
	if r.timePeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", r.timePeriod, "form", "")
	} else {
        var defaultValue int64 = 9
        parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", defaultValue, "form", "")
        r.timePeriod = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesRsiRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	seriesType *string
	timePeriod *int64
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesRsiRequest) Interval(interval string) ApiGetTimeSeriesRsiRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesRsiRequest) Symbol(symbol string) ApiGetTimeSeriesRsiRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesRsiRequest) Isin(isin string) ApiGetTimeSeriesRsiRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesRsiRequest) Figi(figi string) ApiGetTimeSeriesRsiRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesRsiRequest) Cusip(cusip string) ApiGetTimeSeriesRsiRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesRsiRequest) Outputsize(outputsize int64) ApiGetTimeSeriesRsiRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesRsiRequest) Exchange(exchange string) ApiGetTimeSeriesRsiRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesRsiRequest) MicCode(micCode string) ApiGetTimeSeriesRsiRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesRsiRequest) Country(country string) ApiGetTimeSeriesRsiRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesRsiRequest) Type_(type_ string) ApiGetTimeSeriesRsiRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesRsiRequest) Timezone(timezone string) ApiGetTimeSeriesRsiRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesRsiRequest) StartDate(startDate string) ApiGetTimeSeriesRsiRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesRsiRequest) EndDate(endDate string) ApiGetTimeSeriesRsiRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesRsiRequest) Date(date string) ApiGetTimeSeriesRsiRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesRsiRequest) Order(order string) ApiGetTimeSeriesRsiRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesRsiRequest) Prepost(prepost bool) ApiGetTimeSeriesRsiRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesRsiRequest) Format(format string) ApiGetTimeSeriesRsiRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesRsiRequest) Delimiter(delimiter string) ApiGetTimeSeriesRsiRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesRsiRequest) Dp(dp int64) ApiGetTimeSeriesRsiRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesRsiRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesRsiRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesRsiRequest) Adjust(adjust string) ApiGetTimeSeriesRsiRequest {
	r.adjust = &adjust
	return r
}

// Price type on which technical indicator is calculated
func (r ApiGetTimeSeriesRsiRequest) SeriesType(seriesType string) ApiGetTimeSeriesRsiRequest {
	r.seriesType = &seriesType
	return r
}

// Number of periods to average over. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesRsiRequest) TimePeriod(timePeriod int64) ApiGetTimeSeriesRsiRequest {
	r.timePeriod = &timePeriod
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesRsiRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesRsiRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesRsiRequest) Execute() (*GetTimeSeriesRsi200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesRsiExecute(r)
}

/*
GetTimeSeriesRsi Relative strength index

The Relative Strength Index (RSI) endpoint provides data on the RSI values for a specified financial instrument over a given period. It returns a series of RSI values, which indicate the momentum of price movements and help identify potential overbought or oversold conditions. This data is useful for traders looking to assess the strength of price trends and anticipate possible trend reversals.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesRsiRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesRsi(ctx context.Context) ApiGetTimeSeriesRsiRequest {
	return ApiGetTimeSeriesRsiRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesRsi200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesRsiExecute(r ApiGetTimeSeriesRsiRequest) (*GetTimeSeriesRsi200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesRsi200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesRsi")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rsi"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.seriesType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", r.seriesType, "form", "")
	} else {
        var defaultValue string = "close"
        parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", defaultValue, "form", "")
        r.seriesType = &defaultValue
	}
	if r.timePeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", r.timePeriod, "form", "")
	} else {
        var defaultValue int64 = 14
        parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", defaultValue, "form", "")
        r.timePeriod = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesRvolRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	timePeriod *int64
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesRvolRequest) Interval(interval string) ApiGetTimeSeriesRvolRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesRvolRequest) Symbol(symbol string) ApiGetTimeSeriesRvolRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesRvolRequest) Isin(isin string) ApiGetTimeSeriesRvolRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesRvolRequest) Figi(figi string) ApiGetTimeSeriesRvolRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesRvolRequest) Cusip(cusip string) ApiGetTimeSeriesRvolRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesRvolRequest) Outputsize(outputsize int64) ApiGetTimeSeriesRvolRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesRvolRequest) Exchange(exchange string) ApiGetTimeSeriesRvolRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesRvolRequest) MicCode(micCode string) ApiGetTimeSeriesRvolRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesRvolRequest) Country(country string) ApiGetTimeSeriesRvolRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesRvolRequest) Type_(type_ string) ApiGetTimeSeriesRvolRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesRvolRequest) Timezone(timezone string) ApiGetTimeSeriesRvolRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesRvolRequest) StartDate(startDate string) ApiGetTimeSeriesRvolRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesRvolRequest) EndDate(endDate string) ApiGetTimeSeriesRvolRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesRvolRequest) Date(date string) ApiGetTimeSeriesRvolRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesRvolRequest) Order(order string) ApiGetTimeSeriesRvolRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesRvolRequest) Prepost(prepost bool) ApiGetTimeSeriesRvolRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesRvolRequest) Format(format string) ApiGetTimeSeriesRvolRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesRvolRequest) Delimiter(delimiter string) ApiGetTimeSeriesRvolRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesRvolRequest) Dp(dp int64) ApiGetTimeSeriesRvolRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesRvolRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesRvolRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesRvolRequest) Adjust(adjust string) ApiGetTimeSeriesRvolRequest {
	r.adjust = &adjust
	return r
}

// Number of periods to average over. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesRvolRequest) TimePeriod(timePeriod int64) ApiGetTimeSeriesRvolRequest {
	r.timePeriod = &timePeriod
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesRvolRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesRvolRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesRvolRequest) Execute() (*GetTimeSeriesRvol200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesRvolExecute(r)
}

/*
GetTimeSeriesRvol Relative volume

The Relative Volume endpoint (/rvol) provides a ratio comparing a security's current trading volume to its average volume over a specified period. This data helps users detect unusual trading activity and assess the strength of price movements, offering insights into potential market breakouts.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesRvolRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesRvol(ctx context.Context) ApiGetTimeSeriesRvolRequest {
	return ApiGetTimeSeriesRvolRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesRvol200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesRvolExecute(r ApiGetTimeSeriesRvolRequest) (*GetTimeSeriesRvol200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesRvol200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesRvol")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rvol"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.timePeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", r.timePeriod, "form", "")
	} else {
        var defaultValue int64 = 14
        parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", defaultValue, "form", "")
        r.timePeriod = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesSarRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	acceleration *float64
	maximum *float64
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesSarRequest) Interval(interval string) ApiGetTimeSeriesSarRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesSarRequest) Symbol(symbol string) ApiGetTimeSeriesSarRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesSarRequest) Isin(isin string) ApiGetTimeSeriesSarRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesSarRequest) Figi(figi string) ApiGetTimeSeriesSarRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesSarRequest) Cusip(cusip string) ApiGetTimeSeriesSarRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesSarRequest) Outputsize(outputsize int64) ApiGetTimeSeriesSarRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesSarRequest) Exchange(exchange string) ApiGetTimeSeriesSarRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesSarRequest) MicCode(micCode string) ApiGetTimeSeriesSarRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesSarRequest) Country(country string) ApiGetTimeSeriesSarRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesSarRequest) Type_(type_ string) ApiGetTimeSeriesSarRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesSarRequest) Timezone(timezone string) ApiGetTimeSeriesSarRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesSarRequest) StartDate(startDate string) ApiGetTimeSeriesSarRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesSarRequest) EndDate(endDate string) ApiGetTimeSeriesSarRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesSarRequest) Date(date string) ApiGetTimeSeriesSarRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesSarRequest) Order(order string) ApiGetTimeSeriesSarRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesSarRequest) Prepost(prepost bool) ApiGetTimeSeriesSarRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesSarRequest) Format(format string) ApiGetTimeSeriesSarRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesSarRequest) Delimiter(delimiter string) ApiGetTimeSeriesSarRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesSarRequest) Dp(dp int64) ApiGetTimeSeriesSarRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesSarRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesSarRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesSarRequest) Adjust(adjust string) ApiGetTimeSeriesSarRequest {
	r.adjust = &adjust
	return r
}

// The rate of change in the indicator&#39;s values.
func (r ApiGetTimeSeriesSarRequest) Acceleration(acceleration float64) ApiGetTimeSeriesSarRequest {
	r.acceleration = &acceleration
	return r
}

// The maximum value considered for the indicator calculation.
func (r ApiGetTimeSeriesSarRequest) Maximum(maximum float64) ApiGetTimeSeriesSarRequest {
	r.maximum = &maximum
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesSarRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesSarRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesSarRequest) Execute() (*GetTimeSeriesSar200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesSarExecute(r)
}

/*
GetTimeSeriesSar Parabolic stop and reverse

The Parabolic Stop and Reverse (SAR) endpoint provides data on potential support and resistance levels for a specified security, using its price and time. This endpoint returns numerical values that help traders determine possible entry and exit points in their trading strategies.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesSarRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesSar(ctx context.Context) ApiGetTimeSeriesSarRequest {
	return ApiGetTimeSeriesSarRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesSar200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesSarExecute(r ApiGetTimeSeriesSarRequest) (*GetTimeSeriesSar200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesSar200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesSar")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sar"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.acceleration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "acceleration", r.acceleration, "form", "")
	} else {
        var defaultValue float64 = 0.02
        parameterAddToHeaderOrQuery(localVarQueryParams, "acceleration", defaultValue, "form", "")
        r.acceleration = &defaultValue
	}
	if r.maximum != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maximum", r.maximum, "form", "")
	} else {
        var defaultValue float64 = 0.2
        parameterAddToHeaderOrQuery(localVarQueryParams, "maximum", defaultValue, "form", "")
        r.maximum = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesSarExtRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	startValue *float64
	offsetOnReverse *float64
	accelerationLimitLong *float64
	accelerationLong *float64
	accelerationMaxLong *float64
	accelerationLimitShort *float64
	accelerationShort *float64
	accelerationMaxShort *float64
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesSarExtRequest) Interval(interval string) ApiGetTimeSeriesSarExtRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesSarExtRequest) Symbol(symbol string) ApiGetTimeSeriesSarExtRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesSarExtRequest) Isin(isin string) ApiGetTimeSeriesSarExtRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesSarExtRequest) Figi(figi string) ApiGetTimeSeriesSarExtRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesSarExtRequest) Cusip(cusip string) ApiGetTimeSeriesSarExtRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesSarExtRequest) Outputsize(outputsize int64) ApiGetTimeSeriesSarExtRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesSarExtRequest) Exchange(exchange string) ApiGetTimeSeriesSarExtRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesSarExtRequest) MicCode(micCode string) ApiGetTimeSeriesSarExtRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesSarExtRequest) Country(country string) ApiGetTimeSeriesSarExtRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesSarExtRequest) Type_(type_ string) ApiGetTimeSeriesSarExtRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesSarExtRequest) Timezone(timezone string) ApiGetTimeSeriesSarExtRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesSarExtRequest) StartDate(startDate string) ApiGetTimeSeriesSarExtRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesSarExtRequest) EndDate(endDate string) ApiGetTimeSeriesSarExtRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesSarExtRequest) Date(date string) ApiGetTimeSeriesSarExtRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesSarExtRequest) Order(order string) ApiGetTimeSeriesSarExtRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesSarExtRequest) Prepost(prepost bool) ApiGetTimeSeriesSarExtRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesSarExtRequest) Format(format string) ApiGetTimeSeriesSarExtRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesSarExtRequest) Delimiter(delimiter string) ApiGetTimeSeriesSarExtRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesSarExtRequest) Dp(dp int64) ApiGetTimeSeriesSarExtRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesSarExtRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesSarExtRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesSarExtRequest) Adjust(adjust string) ApiGetTimeSeriesSarExtRequest {
	r.adjust = &adjust
	return r
}

// The initial value for the indicator calculation.
func (r ApiGetTimeSeriesSarExtRequest) StartValue(startValue float64) ApiGetTimeSeriesSarExtRequest {
	r.startValue = &startValue
	return r
}

// The adjustment applied when the indicator&#39;s direction changes.
func (r ApiGetTimeSeriesSarExtRequest) OffsetOnReverse(offsetOnReverse float64) ApiGetTimeSeriesSarExtRequest {
	r.offsetOnReverse = &offsetOnReverse
	return r
}

// The maximum acceleration value for long positions.
func (r ApiGetTimeSeriesSarExtRequest) AccelerationLimitLong(accelerationLimitLong float64) ApiGetTimeSeriesSarExtRequest {
	r.accelerationLimitLong = &accelerationLimitLong
	return r
}

// The acceleration value for long positions.
func (r ApiGetTimeSeriesSarExtRequest) AccelerationLong(accelerationLong float64) ApiGetTimeSeriesSarExtRequest {
	r.accelerationLong = &accelerationLong
	return r
}

// The highest allowed acceleration for long positions.
func (r ApiGetTimeSeriesSarExtRequest) AccelerationMaxLong(accelerationMaxLong float64) ApiGetTimeSeriesSarExtRequest {
	r.accelerationMaxLong = &accelerationMaxLong
	return r
}

// The maximum acceleration value for short positions.
func (r ApiGetTimeSeriesSarExtRequest) AccelerationLimitShort(accelerationLimitShort float64) ApiGetTimeSeriesSarExtRequest {
	r.accelerationLimitShort = &accelerationLimitShort
	return r
}

// The acceleration value for short positions.
func (r ApiGetTimeSeriesSarExtRequest) AccelerationShort(accelerationShort float64) ApiGetTimeSeriesSarExtRequest {
	r.accelerationShort = &accelerationShort
	return r
}

// The highest allowed acceleration for short positions.
func (r ApiGetTimeSeriesSarExtRequest) AccelerationMaxShort(accelerationMaxShort float64) ApiGetTimeSeriesSarExtRequest {
	r.accelerationMaxShort = &accelerationMaxShort
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesSarExtRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesSarExtRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesSarExtRequest) Execute() (*GetTimeSeriesSarExt200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesSarExtExecute(r)
}

/*
GetTimeSeriesSarExt Parabolic stop and reverse extended

The Parabolic SAR Extended (SAREXT) endpoint provides a customizable version of the Parabolic SAR indicator, which is used to identify potential entry and exit points in trading. Users can adjust parameters such as acceleration factors to tailor the indicator to specific trading strategies. The endpoint returns data points indicating potential trend reversals.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesSarExtRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesSarExt(ctx context.Context) ApiGetTimeSeriesSarExtRequest {
	return ApiGetTimeSeriesSarExtRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesSarExt200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesSarExtExecute(r ApiGetTimeSeriesSarExtRequest) (*GetTimeSeriesSarExt200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesSarExt200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesSarExt")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sarext"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.startValue != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_value", r.startValue, "form", "")
	} else {
        var defaultValue float64 = 0
        parameterAddToHeaderOrQuery(localVarQueryParams, "start_value", defaultValue, "form", "")
        r.startValue = &defaultValue
	}
	if r.offsetOnReverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset_on_reverse", r.offsetOnReverse, "form", "")
	} else {
        var defaultValue float64 = 0
        parameterAddToHeaderOrQuery(localVarQueryParams, "offset_on_reverse", defaultValue, "form", "")
        r.offsetOnReverse = &defaultValue
	}
	if r.accelerationLimitLong != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "acceleration_limit_long", r.accelerationLimitLong, "form", "")
	} else {
        var defaultValue float64 = 0.02
        parameterAddToHeaderOrQuery(localVarQueryParams, "acceleration_limit_long", defaultValue, "form", "")
        r.accelerationLimitLong = &defaultValue
	}
	if r.accelerationLong != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "acceleration_long", r.accelerationLong, "form", "")
	} else {
        var defaultValue float64 = 0.02
        parameterAddToHeaderOrQuery(localVarQueryParams, "acceleration_long", defaultValue, "form", "")
        r.accelerationLong = &defaultValue
	}
	if r.accelerationMaxLong != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "acceleration_max_long", r.accelerationMaxLong, "form", "")
	} else {
        var defaultValue float64 = 0.2
        parameterAddToHeaderOrQuery(localVarQueryParams, "acceleration_max_long", defaultValue, "form", "")
        r.accelerationMaxLong = &defaultValue
	}
	if r.accelerationLimitShort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "acceleration_limit_short", r.accelerationLimitShort, "form", "")
	} else {
        var defaultValue float64 = 0.02
        parameterAddToHeaderOrQuery(localVarQueryParams, "acceleration_limit_short", defaultValue, "form", "")
        r.accelerationLimitShort = &defaultValue
	}
	if r.accelerationShort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "acceleration_short", r.accelerationShort, "form", "")
	} else {
        var defaultValue float64 = 0.02
        parameterAddToHeaderOrQuery(localVarQueryParams, "acceleration_short", defaultValue, "form", "")
        r.accelerationShort = &defaultValue
	}
	if r.accelerationMaxShort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "acceleration_max_short", r.accelerationMaxShort, "form", "")
	} else {
        var defaultValue float64 = 0.2
        parameterAddToHeaderOrQuery(localVarQueryParams, "acceleration_max_short", defaultValue, "form", "")
        r.accelerationMaxShort = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesSmaRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	seriesType *string
	timePeriod *int64
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesSmaRequest) Interval(interval string) ApiGetTimeSeriesSmaRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesSmaRequest) Symbol(symbol string) ApiGetTimeSeriesSmaRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesSmaRequest) Isin(isin string) ApiGetTimeSeriesSmaRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesSmaRequest) Figi(figi string) ApiGetTimeSeriesSmaRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesSmaRequest) Cusip(cusip string) ApiGetTimeSeriesSmaRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesSmaRequest) Outputsize(outputsize int64) ApiGetTimeSeriesSmaRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesSmaRequest) Exchange(exchange string) ApiGetTimeSeriesSmaRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesSmaRequest) MicCode(micCode string) ApiGetTimeSeriesSmaRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesSmaRequest) Country(country string) ApiGetTimeSeriesSmaRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesSmaRequest) Type_(type_ string) ApiGetTimeSeriesSmaRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesSmaRequest) Timezone(timezone string) ApiGetTimeSeriesSmaRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesSmaRequest) StartDate(startDate string) ApiGetTimeSeriesSmaRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesSmaRequest) EndDate(endDate string) ApiGetTimeSeriesSmaRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesSmaRequest) Date(date string) ApiGetTimeSeriesSmaRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesSmaRequest) Order(order string) ApiGetTimeSeriesSmaRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesSmaRequest) Prepost(prepost bool) ApiGetTimeSeriesSmaRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesSmaRequest) Format(format string) ApiGetTimeSeriesSmaRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesSmaRequest) Delimiter(delimiter string) ApiGetTimeSeriesSmaRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesSmaRequest) Dp(dp int64) ApiGetTimeSeriesSmaRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesSmaRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesSmaRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesSmaRequest) Adjust(adjust string) ApiGetTimeSeriesSmaRequest {
	r.adjust = &adjust
	return r
}

// Price type on which technical indicator is calculated
func (r ApiGetTimeSeriesSmaRequest) SeriesType(seriesType string) ApiGetTimeSeriesSmaRequest {
	r.seriesType = &seriesType
	return r
}

// Number of periods to average over. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesSmaRequest) TimePeriod(timePeriod int64) ApiGetTimeSeriesSmaRequest {
	r.timePeriod = &timePeriod
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesSmaRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesSmaRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesSmaRequest) Execute() (*GetTimeSeriesSma200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesSmaExecute(r)
}

/*
GetTimeSeriesSma Simple moving average

The Simple Moving Average (SMA) endpoint calculates and returns the average price of a security over a user-defined time period. This endpoint provides a series of data points that represent the smoothed price trend, which can help users identify potential price movements and evaluate historical price behavior.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesSmaRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesSma(ctx context.Context) ApiGetTimeSeriesSmaRequest {
	return ApiGetTimeSeriesSmaRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesSma200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesSmaExecute(r ApiGetTimeSeriesSmaRequest) (*GetTimeSeriesSma200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesSma200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesSma")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sma"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.seriesType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", r.seriesType, "form", "")
	} else {
        var defaultValue string = "close"
        parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", defaultValue, "form", "")
        r.seriesType = &defaultValue
	}
	if r.timePeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", r.timePeriod, "form", "")
	} else {
        var defaultValue int64 = 9
        parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", defaultValue, "form", "")
        r.timePeriod = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesSqrtRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	seriesType *string
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesSqrtRequest) Interval(interval string) ApiGetTimeSeriesSqrtRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesSqrtRequest) Symbol(symbol string) ApiGetTimeSeriesSqrtRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesSqrtRequest) Isin(isin string) ApiGetTimeSeriesSqrtRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesSqrtRequest) Figi(figi string) ApiGetTimeSeriesSqrtRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesSqrtRequest) Cusip(cusip string) ApiGetTimeSeriesSqrtRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesSqrtRequest) Outputsize(outputsize int64) ApiGetTimeSeriesSqrtRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesSqrtRequest) Exchange(exchange string) ApiGetTimeSeriesSqrtRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesSqrtRequest) MicCode(micCode string) ApiGetTimeSeriesSqrtRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesSqrtRequest) Country(country string) ApiGetTimeSeriesSqrtRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesSqrtRequest) Type_(type_ string) ApiGetTimeSeriesSqrtRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesSqrtRequest) Timezone(timezone string) ApiGetTimeSeriesSqrtRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesSqrtRequest) StartDate(startDate string) ApiGetTimeSeriesSqrtRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesSqrtRequest) EndDate(endDate string) ApiGetTimeSeriesSqrtRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesSqrtRequest) Date(date string) ApiGetTimeSeriesSqrtRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesSqrtRequest) Order(order string) ApiGetTimeSeriesSqrtRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesSqrtRequest) Prepost(prepost bool) ApiGetTimeSeriesSqrtRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesSqrtRequest) Format(format string) ApiGetTimeSeriesSqrtRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesSqrtRequest) Delimiter(delimiter string) ApiGetTimeSeriesSqrtRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesSqrtRequest) Dp(dp int64) ApiGetTimeSeriesSqrtRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesSqrtRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesSqrtRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesSqrtRequest) Adjust(adjust string) ApiGetTimeSeriesSqrtRequest {
	r.adjust = &adjust
	return r
}

// Price type on which technical indicator is calculated
func (r ApiGetTimeSeriesSqrtRequest) SeriesType(seriesType string) ApiGetTimeSeriesSqrtRequest {
	r.seriesType = &seriesType
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesSqrtRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesSqrtRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesSqrtRequest) Execute() (*GetTimeSeriesSqrt200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesSqrtExecute(r)
}

/*
GetTimeSeriesSqrt Square root

The Square Root (SQRT) endpoint computes the square root of a specified numerical input. It returns a single numerical value representing the square root, which can be used in various mathematical computations or financial models requiring this specific transformation.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesSqrtRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesSqrt(ctx context.Context) ApiGetTimeSeriesSqrtRequest {
	return ApiGetTimeSeriesSqrtRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesSqrt200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesSqrtExecute(r ApiGetTimeSeriesSqrtRequest) (*GetTimeSeriesSqrt200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesSqrt200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesSqrt")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sqrt"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.seriesType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", r.seriesType, "form", "")
	} else {
        var defaultValue string = "close"
        parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", defaultValue, "form", "")
        r.seriesType = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesStdDevRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	seriesType *string
	timePeriod *int64
	sd *float64
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesStdDevRequest) Interval(interval string) ApiGetTimeSeriesStdDevRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesStdDevRequest) Symbol(symbol string) ApiGetTimeSeriesStdDevRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesStdDevRequest) Isin(isin string) ApiGetTimeSeriesStdDevRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesStdDevRequest) Figi(figi string) ApiGetTimeSeriesStdDevRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesStdDevRequest) Cusip(cusip string) ApiGetTimeSeriesStdDevRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesStdDevRequest) Outputsize(outputsize int64) ApiGetTimeSeriesStdDevRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesStdDevRequest) Exchange(exchange string) ApiGetTimeSeriesStdDevRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesStdDevRequest) MicCode(micCode string) ApiGetTimeSeriesStdDevRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesStdDevRequest) Country(country string) ApiGetTimeSeriesStdDevRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesStdDevRequest) Type_(type_ string) ApiGetTimeSeriesStdDevRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesStdDevRequest) Timezone(timezone string) ApiGetTimeSeriesStdDevRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesStdDevRequest) StartDate(startDate string) ApiGetTimeSeriesStdDevRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesStdDevRequest) EndDate(endDate string) ApiGetTimeSeriesStdDevRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesStdDevRequest) Date(date string) ApiGetTimeSeriesStdDevRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesStdDevRequest) Order(order string) ApiGetTimeSeriesStdDevRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesStdDevRequest) Prepost(prepost bool) ApiGetTimeSeriesStdDevRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesStdDevRequest) Format(format string) ApiGetTimeSeriesStdDevRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesStdDevRequest) Delimiter(delimiter string) ApiGetTimeSeriesStdDevRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesStdDevRequest) Dp(dp int64) ApiGetTimeSeriesStdDevRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesStdDevRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesStdDevRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesStdDevRequest) Adjust(adjust string) ApiGetTimeSeriesStdDevRequest {
	r.adjust = &adjust
	return r
}

// Price type on which technical indicator is calculated
func (r ApiGetTimeSeriesStdDevRequest) SeriesType(seriesType string) ApiGetTimeSeriesStdDevRequest {
	r.seriesType = &seriesType
	return r
}

// Number of periods to average over. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesStdDevRequest) TimePeriod(timePeriod int64) ApiGetTimeSeriesStdDevRequest {
	r.timePeriod = &timePeriod
	return r
}

// The standard deviation applied in the calculation.
func (r ApiGetTimeSeriesStdDevRequest) Sd(sd float64) ApiGetTimeSeriesStdDevRequest {
	r.sd = &sd
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesStdDevRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesStdDevRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesStdDevRequest) Execute() (*GetTimeSeriesStdDev200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesStdDevExecute(r)
}

/*
GetTimeSeriesStdDev Standard deviation

The Standard Deviation (STDDEV) endpoint calculates the dispersion of a financial instrument's price data from its average value. It returns a numerical value representing the volatility of the asset over a specified period. This endpoint is useful for traders and analysts to assess price variability and identify periods of high or low volatility in the market.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesStdDevRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesStdDev(ctx context.Context) ApiGetTimeSeriesStdDevRequest {
	return ApiGetTimeSeriesStdDevRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesStdDev200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesStdDevExecute(r ApiGetTimeSeriesStdDevRequest) (*GetTimeSeriesStdDev200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesStdDev200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesStdDev")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stddev"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.seriesType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", r.seriesType, "form", "")
	} else {
        var defaultValue string = "close"
        parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", defaultValue, "form", "")
        r.seriesType = &defaultValue
	}
	if r.timePeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", r.timePeriod, "form", "")
	} else {
        var defaultValue int64 = 9
        parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", defaultValue, "form", "")
        r.timePeriod = &defaultValue
	}
	if r.sd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sd", r.sd, "form", "")
	} else {
        var defaultValue float64 = 2
        parameterAddToHeaderOrQuery(localVarQueryParams, "sd", defaultValue, "form", "")
        r.sd = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesStochRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	fastKPeriod *int64
	slowKPeriod *int64
	slowDPeriod *int64
	slowKmaType *string
	slowDmaType *string
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesStochRequest) Interval(interval string) ApiGetTimeSeriesStochRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesStochRequest) Symbol(symbol string) ApiGetTimeSeriesStochRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesStochRequest) Isin(isin string) ApiGetTimeSeriesStochRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesStochRequest) Figi(figi string) ApiGetTimeSeriesStochRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesStochRequest) Cusip(cusip string) ApiGetTimeSeriesStochRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesStochRequest) Outputsize(outputsize int64) ApiGetTimeSeriesStochRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesStochRequest) Exchange(exchange string) ApiGetTimeSeriesStochRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesStochRequest) MicCode(micCode string) ApiGetTimeSeriesStochRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesStochRequest) Country(country string) ApiGetTimeSeriesStochRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesStochRequest) Type_(type_ string) ApiGetTimeSeriesStochRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesStochRequest) Timezone(timezone string) ApiGetTimeSeriesStochRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesStochRequest) StartDate(startDate string) ApiGetTimeSeriesStochRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesStochRequest) EndDate(endDate string) ApiGetTimeSeriesStochRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesStochRequest) Date(date string) ApiGetTimeSeriesStochRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesStochRequest) Order(order string) ApiGetTimeSeriesStochRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesStochRequest) Prepost(prepost bool) ApiGetTimeSeriesStochRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesStochRequest) Format(format string) ApiGetTimeSeriesStochRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesStochRequest) Delimiter(delimiter string) ApiGetTimeSeriesStochRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesStochRequest) Dp(dp int64) ApiGetTimeSeriesStochRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesStochRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesStochRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesStochRequest) Adjust(adjust string) ApiGetTimeSeriesStochRequest {
	r.adjust = &adjust
	return r
}

// The time period for the fast %K line in the Stochastic Oscillator. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesStochRequest) FastKPeriod(fastKPeriod int64) ApiGetTimeSeriesStochRequest {
	r.fastKPeriod = &fastKPeriod
	return r
}

// The time period for the slow %K line in the Stochastic Oscillator. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesStochRequest) SlowKPeriod(slowKPeriod int64) ApiGetTimeSeriesStochRequest {
	r.slowKPeriod = &slowKPeriod
	return r
}

// The time period for the slow %D line in the Stochastic Oscillator. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesStochRequest) SlowDPeriod(slowDPeriod int64) ApiGetTimeSeriesStochRequest {
	r.slowDPeriod = &slowDPeriod
	return r
}

// The type of slow %K Moving Average used. Default is SMA.
func (r ApiGetTimeSeriesStochRequest) SlowKmaType(slowKmaType string) ApiGetTimeSeriesStochRequest {
	r.slowKmaType = &slowKmaType
	return r
}

// The type of slow Displaced Moving Average used. Default is SMA.
func (r ApiGetTimeSeriesStochRequest) SlowDmaType(slowDmaType string) ApiGetTimeSeriesStochRequest {
	r.slowDmaType = &slowDmaType
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesStochRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesStochRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesStochRequest) Execute() (*GetTimeSeriesStoch200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesStochExecute(r)
}

/*
GetTimeSeriesStoch Stochastic oscillator

The Stochastic Oscillator endpoint provides data on a momentum indicator that evaluates a security's closing price relative to its price range over a specified timeframe. It returns values indicating potential overbought or oversold conditions, aiding in identifying possible trend reversals. Users receive the %K and %D values, which are essential for analyzing the momentum and potential turning points in the market.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesStochRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesStoch(ctx context.Context) ApiGetTimeSeriesStochRequest {
	return ApiGetTimeSeriesStochRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesStoch200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesStochExecute(r ApiGetTimeSeriesStochRequest) (*GetTimeSeriesStoch200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesStoch200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesStoch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stoch"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.fastKPeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fast_k_period", r.fastKPeriod, "form", "")
	} else {
        var defaultValue int64 = 14
        parameterAddToHeaderOrQuery(localVarQueryParams, "fast_k_period", defaultValue, "form", "")
        r.fastKPeriod = &defaultValue
	}
	if r.slowKPeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "slow_k_period", r.slowKPeriod, "form", "")
	} else {
        var defaultValue int64 = 1
        parameterAddToHeaderOrQuery(localVarQueryParams, "slow_k_period", defaultValue, "form", "")
        r.slowKPeriod = &defaultValue
	}
	if r.slowDPeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "slow_d_period", r.slowDPeriod, "form", "")
	} else {
        var defaultValue int64 = 3
        parameterAddToHeaderOrQuery(localVarQueryParams, "slow_d_period", defaultValue, "form", "")
        r.slowDPeriod = &defaultValue
	}
	if r.slowKmaType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "slow_kma_type", r.slowKmaType, "form", "")
	} else {
        var defaultValue string = "SMA"
        parameterAddToHeaderOrQuery(localVarQueryParams, "slow_kma_type", defaultValue, "form", "")
        r.slowKmaType = &defaultValue
	}
	if r.slowDmaType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "slow_dma_type", r.slowDmaType, "form", "")
	} else {
        var defaultValue string = "SMA"
        parameterAddToHeaderOrQuery(localVarQueryParams, "slow_dma_type", defaultValue, "form", "")
        r.slowDmaType = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesStochFRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	fastKPeriod *int64
	fastDPeriod *int64
	fastDmaType *string
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesStochFRequest) Interval(interval string) ApiGetTimeSeriesStochFRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesStochFRequest) Symbol(symbol string) ApiGetTimeSeriesStochFRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesStochFRequest) Isin(isin string) ApiGetTimeSeriesStochFRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesStochFRequest) Figi(figi string) ApiGetTimeSeriesStochFRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesStochFRequest) Cusip(cusip string) ApiGetTimeSeriesStochFRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesStochFRequest) Outputsize(outputsize int64) ApiGetTimeSeriesStochFRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesStochFRequest) Exchange(exchange string) ApiGetTimeSeriesStochFRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesStochFRequest) MicCode(micCode string) ApiGetTimeSeriesStochFRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesStochFRequest) Country(country string) ApiGetTimeSeriesStochFRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesStochFRequest) Type_(type_ string) ApiGetTimeSeriesStochFRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesStochFRequest) Timezone(timezone string) ApiGetTimeSeriesStochFRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesStochFRequest) StartDate(startDate string) ApiGetTimeSeriesStochFRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesStochFRequest) EndDate(endDate string) ApiGetTimeSeriesStochFRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesStochFRequest) Date(date string) ApiGetTimeSeriesStochFRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesStochFRequest) Order(order string) ApiGetTimeSeriesStochFRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesStochFRequest) Prepost(prepost bool) ApiGetTimeSeriesStochFRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesStochFRequest) Format(format string) ApiGetTimeSeriesStochFRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesStochFRequest) Delimiter(delimiter string) ApiGetTimeSeriesStochFRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesStochFRequest) Dp(dp int64) ApiGetTimeSeriesStochFRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesStochFRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesStochFRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesStochFRequest) Adjust(adjust string) ApiGetTimeSeriesStochFRequest {
	r.adjust = &adjust
	return r
}

// The time period for the fast %K line in the Stochastic Oscillator. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesStochFRequest) FastKPeriod(fastKPeriod int64) ApiGetTimeSeriesStochFRequest {
	r.fastKPeriod = &fastKPeriod
	return r
}

// The time period for the fast %D line in the Stochastic Oscillator. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesStochFRequest) FastDPeriod(fastDPeriod int64) ApiGetTimeSeriesStochFRequest {
	r.fastDPeriod = &fastDPeriod
	return r
}

// The type of fast Displaced Moving Average used.
func (r ApiGetTimeSeriesStochFRequest) FastDmaType(fastDmaType string) ApiGetTimeSeriesStochFRequest {
	r.fastDmaType = &fastDmaType
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesStochFRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesStochFRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesStochFRequest) Execute() (*GetTimeSeriesStochF200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesStochFExecute(r)
}

/*
GetTimeSeriesStochF Stochastic fast

The Stochastic Fast (STOCHF) endpoint calculates the fast version of the Stochastic Oscillator, providing data on the momentum of a financial instrument by comparing a particular closing price to a range of its prices over a specified period. This endpoint returns the %K and %D values, which are used to identify potential overbought or oversold conditions in the market. It is useful for traders who need quick, responsive insights into price movements, although it may generate more false signals due to its sensitivity.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesStochFRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesStochF(ctx context.Context) ApiGetTimeSeriesStochFRequest {
	return ApiGetTimeSeriesStochFRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesStochF200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesStochFExecute(r ApiGetTimeSeriesStochFRequest) (*GetTimeSeriesStochF200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesStochF200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesStochF")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stochf"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.fastKPeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fast_k_period", r.fastKPeriod, "form", "")
	} else {
        var defaultValue int64 = 14
        parameterAddToHeaderOrQuery(localVarQueryParams, "fast_k_period", defaultValue, "form", "")
        r.fastKPeriod = &defaultValue
	}
	if r.fastDPeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fast_d_period", r.fastDPeriod, "form", "")
	} else {
        var defaultValue int64 = 3
        parameterAddToHeaderOrQuery(localVarQueryParams, "fast_d_period", defaultValue, "form", "")
        r.fastDPeriod = &defaultValue
	}
	if r.fastDmaType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fast_dma_type", r.fastDmaType, "form", "")
	} else {
        var defaultValue string = "SMA"
        parameterAddToHeaderOrQuery(localVarQueryParams, "fast_dma_type", defaultValue, "form", "")
        r.fastDmaType = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesStochRsiRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	seriesType *string
	rsiLength *int64
	stochLength *int64
	kPeriod *int64
	slowKmaType *string
	dPeriod *int64
	slowDmaType *string
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesStochRsiRequest) Interval(interval string) ApiGetTimeSeriesStochRsiRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesStochRsiRequest) Symbol(symbol string) ApiGetTimeSeriesStochRsiRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesStochRsiRequest) Isin(isin string) ApiGetTimeSeriesStochRsiRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesStochRsiRequest) Figi(figi string) ApiGetTimeSeriesStochRsiRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesStochRsiRequest) Cusip(cusip string) ApiGetTimeSeriesStochRsiRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesStochRsiRequest) Outputsize(outputsize int64) ApiGetTimeSeriesStochRsiRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesStochRsiRequest) Exchange(exchange string) ApiGetTimeSeriesStochRsiRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesStochRsiRequest) MicCode(micCode string) ApiGetTimeSeriesStochRsiRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesStochRsiRequest) Country(country string) ApiGetTimeSeriesStochRsiRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesStochRsiRequest) Type_(type_ string) ApiGetTimeSeriesStochRsiRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesStochRsiRequest) Timezone(timezone string) ApiGetTimeSeriesStochRsiRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesStochRsiRequest) StartDate(startDate string) ApiGetTimeSeriesStochRsiRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesStochRsiRequest) EndDate(endDate string) ApiGetTimeSeriesStochRsiRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesStochRsiRequest) Date(date string) ApiGetTimeSeriesStochRsiRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesStochRsiRequest) Order(order string) ApiGetTimeSeriesStochRsiRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesStochRsiRequest) Prepost(prepost bool) ApiGetTimeSeriesStochRsiRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesStochRsiRequest) Format(format string) ApiGetTimeSeriesStochRsiRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesStochRsiRequest) Delimiter(delimiter string) ApiGetTimeSeriesStochRsiRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesStochRsiRequest) Dp(dp int64) ApiGetTimeSeriesStochRsiRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesStochRsiRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesStochRsiRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesStochRsiRequest) Adjust(adjust string) ApiGetTimeSeriesStochRsiRequest {
	r.adjust = &adjust
	return r
}

// Specifies the price data type: open, high, low, or close.
func (r ApiGetTimeSeriesStochRsiRequest) SeriesType(seriesType string) ApiGetTimeSeriesStochRsiRequest {
	r.seriesType = &seriesType
	return r
}

// Length of period for calculating the RSI component. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesStochRsiRequest) RsiLength(rsiLength int64) ApiGetTimeSeriesStochRsiRequest {
	r.rsiLength = &rsiLength
	return r
}

// Period length for computing the stochastic oscillator of the RSI. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesStochRsiRequest) StochLength(stochLength int64) ApiGetTimeSeriesStochRsiRequest {
	r.stochLength = &stochLength
	return r
}

// Period for smoothing the %K line. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesStochRsiRequest) KPeriod(kPeriod int64) ApiGetTimeSeriesStochRsiRequest {
	r.kPeriod = &kPeriod
	return r
}

func (r ApiGetTimeSeriesStochRsiRequest) SlowKmaType(slowKmaType string) ApiGetTimeSeriesStochRsiRequest {
	r.slowKmaType = &slowKmaType
	return r
}

// Period for smoothing the %D line, which is a moving average of %K. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesStochRsiRequest) DPeriod(dPeriod int64) ApiGetTimeSeriesStochRsiRequest {
	r.dPeriod = &dPeriod
	return r
}

func (r ApiGetTimeSeriesStochRsiRequest) SlowDmaType(slowDmaType string) ApiGetTimeSeriesStochRsiRequest {
	r.slowDmaType = &slowDmaType
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesStochRsiRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesStochRsiRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesStochRsiRequest) Execute() (*GetTimeSeriesStochRsi200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesStochRsiExecute(r)
}

/*
GetTimeSeriesStochRsi Stochastic relative strength index

The Stochastic Relative Strength Index (Stochastic RSI) endpoint calculates the Stochastic RSI values for a given financial instrument, providing data on its momentum and potential price reversals. This endpoint returns time-series data, including the %K and %D lines, which help users identify overbought or oversold conditions. Ideal for traders seeking to refine entry and exit points by analyzing short-term price movements.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesStochRsiRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesStochRsi(ctx context.Context) ApiGetTimeSeriesStochRsiRequest {
	return ApiGetTimeSeriesStochRsiRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesStochRsi200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesStochRsiExecute(r ApiGetTimeSeriesStochRsiRequest) (*GetTimeSeriesStochRsi200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesStochRsi200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesStochRsi")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stochrsi"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.seriesType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", r.seriesType, "form", "")
	} else {
        var defaultValue string = "close"
        parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", defaultValue, "form", "")
        r.seriesType = &defaultValue
	}
	if r.rsiLength != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rsi_length", r.rsiLength, "form", "")
	} else {
        var defaultValue int64 = 14
        parameterAddToHeaderOrQuery(localVarQueryParams, "rsi_length", defaultValue, "form", "")
        r.rsiLength = &defaultValue
	}
	if r.stochLength != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stoch_length", r.stochLength, "form", "")
	} else {
        var defaultValue int64 = 14
        parameterAddToHeaderOrQuery(localVarQueryParams, "stoch_length", defaultValue, "form", "")
        r.stochLength = &defaultValue
	}
	if r.kPeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "k_period", r.kPeriod, "form", "")
	} else {
        var defaultValue int64 = 3
        parameterAddToHeaderOrQuery(localVarQueryParams, "k_period", defaultValue, "form", "")
        r.kPeriod = &defaultValue
	}
	if r.slowKmaType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "slow_kma_type", r.slowKmaType, "form", "")
	}
	if r.dPeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "d_period", r.dPeriod, "form", "")
	} else {
        var defaultValue int64 = 3
        parameterAddToHeaderOrQuery(localVarQueryParams, "d_period", defaultValue, "form", "")
        r.dPeriod = &defaultValue
	}
	if r.slowDmaType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "slow_dma_type", r.slowDmaType, "form", "")
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesSubRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	seriesType1 *string
	seriesType2 *string
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesSubRequest) Interval(interval string) ApiGetTimeSeriesSubRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesSubRequest) Symbol(symbol string) ApiGetTimeSeriesSubRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesSubRequest) Isin(isin string) ApiGetTimeSeriesSubRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesSubRequest) Figi(figi string) ApiGetTimeSeriesSubRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesSubRequest) Cusip(cusip string) ApiGetTimeSeriesSubRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesSubRequest) Outputsize(outputsize int64) ApiGetTimeSeriesSubRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesSubRequest) Exchange(exchange string) ApiGetTimeSeriesSubRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesSubRequest) MicCode(micCode string) ApiGetTimeSeriesSubRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesSubRequest) Country(country string) ApiGetTimeSeriesSubRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesSubRequest) Type_(type_ string) ApiGetTimeSeriesSubRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesSubRequest) Timezone(timezone string) ApiGetTimeSeriesSubRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesSubRequest) StartDate(startDate string) ApiGetTimeSeriesSubRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesSubRequest) EndDate(endDate string) ApiGetTimeSeriesSubRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesSubRequest) Date(date string) ApiGetTimeSeriesSubRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesSubRequest) Order(order string) ApiGetTimeSeriesSubRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesSubRequest) Prepost(prepost bool) ApiGetTimeSeriesSubRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesSubRequest) Format(format string) ApiGetTimeSeriesSubRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesSubRequest) Delimiter(delimiter string) ApiGetTimeSeriesSubRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesSubRequest) Dp(dp int64) ApiGetTimeSeriesSubRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesSubRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesSubRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesSubRequest) Adjust(adjust string) ApiGetTimeSeriesSubRequest {
	r.adjust = &adjust
	return r
}

// Price type used as the first part of technical indicator
func (r ApiGetTimeSeriesSubRequest) SeriesType1(seriesType1 string) ApiGetTimeSeriesSubRequest {
	r.seriesType1 = &seriesType1
	return r
}

// Price type used as the second part of technical indicator
func (r ApiGetTimeSeriesSubRequest) SeriesType2(seriesType2 string) ApiGetTimeSeriesSubRequest {
	r.seriesType2 = &seriesType2
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesSubRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesSubRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesSubRequest) Execute() (*GetTimeSeriesSub200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesSubExecute(r)
}

/*
GetTimeSeriesSub Subtraction

The Subtraction (SUB) endpoint calculates the difference between two input data series, such as technical indicators or price data. It returns a time series of the resulting values, allowing users to compare or normalize data by highlighting the variance between the two series.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesSubRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesSub(ctx context.Context) ApiGetTimeSeriesSubRequest {
	return ApiGetTimeSeriesSubRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesSub200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesSubExecute(r ApiGetTimeSeriesSubRequest) (*GetTimeSeriesSub200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesSub200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesSub")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sub"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.seriesType1 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "series_type_1", r.seriesType1, "form", "")
	} else {
        var defaultValue string = "open"
        parameterAddToHeaderOrQuery(localVarQueryParams, "series_type_1", defaultValue, "form", "")
        r.seriesType1 = &defaultValue
	}
	if r.seriesType2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "series_type_2", r.seriesType2, "form", "")
	} else {
        var defaultValue string = "close"
        parameterAddToHeaderOrQuery(localVarQueryParams, "series_type_2", defaultValue, "form", "")
        r.seriesType2 = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesSumRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	seriesType *string
	timePeriod *int64
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesSumRequest) Interval(interval string) ApiGetTimeSeriesSumRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesSumRequest) Symbol(symbol string) ApiGetTimeSeriesSumRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesSumRequest) Isin(isin string) ApiGetTimeSeriesSumRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesSumRequest) Figi(figi string) ApiGetTimeSeriesSumRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesSumRequest) Cusip(cusip string) ApiGetTimeSeriesSumRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesSumRequest) Outputsize(outputsize int64) ApiGetTimeSeriesSumRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesSumRequest) Exchange(exchange string) ApiGetTimeSeriesSumRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesSumRequest) MicCode(micCode string) ApiGetTimeSeriesSumRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesSumRequest) Country(country string) ApiGetTimeSeriesSumRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesSumRequest) Type_(type_ string) ApiGetTimeSeriesSumRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesSumRequest) Timezone(timezone string) ApiGetTimeSeriesSumRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesSumRequest) StartDate(startDate string) ApiGetTimeSeriesSumRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesSumRequest) EndDate(endDate string) ApiGetTimeSeriesSumRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesSumRequest) Date(date string) ApiGetTimeSeriesSumRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesSumRequest) Order(order string) ApiGetTimeSeriesSumRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesSumRequest) Prepost(prepost bool) ApiGetTimeSeriesSumRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesSumRequest) Format(format string) ApiGetTimeSeriesSumRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesSumRequest) Delimiter(delimiter string) ApiGetTimeSeriesSumRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesSumRequest) Dp(dp int64) ApiGetTimeSeriesSumRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesSumRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesSumRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesSumRequest) Adjust(adjust string) ApiGetTimeSeriesSumRequest {
	r.adjust = &adjust
	return r
}

// Price type on which technical indicator is calculated
func (r ApiGetTimeSeriesSumRequest) SeriesType(seriesType string) ApiGetTimeSeriesSumRequest {
	r.seriesType = &seriesType
	return r
}

// Number of periods to average over. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesSumRequest) TimePeriod(timePeriod int64) ApiGetTimeSeriesSumRequest {
	r.timePeriod = &timePeriod
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesSumRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesSumRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesSumRequest) Execute() (*GetTimeSeriesSum200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesSumExecute(r)
}

/*
GetTimeSeriesSum Summation

The Summation (SUM) endpoint calculates the cumulative total of a specified data series over a defined time period. It returns a numerical value representing the sum, which can be used to track the aggregate value of financial data, such as stock prices or trading volumes, over time. This endpoint is useful for users needing to compute the total accumulation of a dataset for further analysis or reporting.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesSumRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesSum(ctx context.Context) ApiGetTimeSeriesSumRequest {
	return ApiGetTimeSeriesSumRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesSum200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesSumExecute(r ApiGetTimeSeriesSumRequest) (*GetTimeSeriesSum200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesSum200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesSum")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sum"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.seriesType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", r.seriesType, "form", "")
	} else {
        var defaultValue string = "close"
        parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", defaultValue, "form", "")
        r.seriesType = &defaultValue
	}
	if r.timePeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", r.timePeriod, "form", "")
	} else {
        var defaultValue int64 = 9
        parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", defaultValue, "form", "")
        r.timePeriod = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesSuperTrendRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	period *int64
	multiplier *int64
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesSuperTrendRequest) Interval(interval string) ApiGetTimeSeriesSuperTrendRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesSuperTrendRequest) Symbol(symbol string) ApiGetTimeSeriesSuperTrendRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesSuperTrendRequest) Isin(isin string) ApiGetTimeSeriesSuperTrendRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesSuperTrendRequest) Figi(figi string) ApiGetTimeSeriesSuperTrendRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesSuperTrendRequest) Cusip(cusip string) ApiGetTimeSeriesSuperTrendRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesSuperTrendRequest) Outputsize(outputsize int64) ApiGetTimeSeriesSuperTrendRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesSuperTrendRequest) Exchange(exchange string) ApiGetTimeSeriesSuperTrendRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesSuperTrendRequest) MicCode(micCode string) ApiGetTimeSeriesSuperTrendRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesSuperTrendRequest) Country(country string) ApiGetTimeSeriesSuperTrendRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesSuperTrendRequest) Type_(type_ string) ApiGetTimeSeriesSuperTrendRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesSuperTrendRequest) Timezone(timezone string) ApiGetTimeSeriesSuperTrendRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesSuperTrendRequest) StartDate(startDate string) ApiGetTimeSeriesSuperTrendRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesSuperTrendRequest) EndDate(endDate string) ApiGetTimeSeriesSuperTrendRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesSuperTrendRequest) Date(date string) ApiGetTimeSeriesSuperTrendRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesSuperTrendRequest) Order(order string) ApiGetTimeSeriesSuperTrendRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesSuperTrendRequest) Prepost(prepost bool) ApiGetTimeSeriesSuperTrendRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesSuperTrendRequest) Format(format string) ApiGetTimeSeriesSuperTrendRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesSuperTrendRequest) Delimiter(delimiter string) ApiGetTimeSeriesSuperTrendRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesSuperTrendRequest) Dp(dp int64) ApiGetTimeSeriesSuperTrendRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesSuperTrendRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesSuperTrendRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesSuperTrendRequest) Adjust(adjust string) ApiGetTimeSeriesSuperTrendRequest {
	r.adjust = &adjust
	return r
}

// The period used for calculation in the indicator. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesSuperTrendRequest) Period(period int64) ApiGetTimeSeriesSuperTrendRequest {
	r.period = &period
	return r
}

// The factor used to adjust the indicator&#39;s sensitivity.
func (r ApiGetTimeSeriesSuperTrendRequest) Multiplier(multiplier int64) ApiGetTimeSeriesSuperTrendRequest {
	r.multiplier = &multiplier
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesSuperTrendRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesSuperTrendRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesSuperTrendRequest) Execute() (*GetTimeSeriesSuperTrend200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesSuperTrendExecute(r)
}

/*
GetTimeSeriesSuperTrend Supertrend

The Supertrend endpoint provides data on the Supertrend indicator, a tool used to identify potential buy and sell signals in trending markets. It returns values that indicate the current trend direction and potential reversal points based on price, time, and volatility. Users can leverage this data to pinpoint optimal entry and exit points for trades.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesSuperTrendRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesSuperTrend(ctx context.Context) ApiGetTimeSeriesSuperTrendRequest {
	return ApiGetTimeSeriesSuperTrendRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesSuperTrend200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesSuperTrendExecute(r ApiGetTimeSeriesSuperTrendRequest) (*GetTimeSeriesSuperTrend200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesSuperTrend200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesSuperTrend")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/supertrend"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.period != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "period", r.period, "form", "")
	} else {
        var defaultValue int64 = 10
        parameterAddToHeaderOrQuery(localVarQueryParams, "period", defaultValue, "form", "")
        r.period = &defaultValue
	}
	if r.multiplier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "multiplier", r.multiplier, "form", "")
	} else {
        var defaultValue int64 = 3
        parameterAddToHeaderOrQuery(localVarQueryParams, "multiplier", defaultValue, "form", "")
        r.multiplier = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesSuperTrendHeikinAshiCandlesRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	period *int64
	multiplier *int64
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesSuperTrendHeikinAshiCandlesRequest) Interval(interval string) ApiGetTimeSeriesSuperTrendHeikinAshiCandlesRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesSuperTrendHeikinAshiCandlesRequest) Symbol(symbol string) ApiGetTimeSeriesSuperTrendHeikinAshiCandlesRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesSuperTrendHeikinAshiCandlesRequest) Isin(isin string) ApiGetTimeSeriesSuperTrendHeikinAshiCandlesRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesSuperTrendHeikinAshiCandlesRequest) Figi(figi string) ApiGetTimeSeriesSuperTrendHeikinAshiCandlesRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesSuperTrendHeikinAshiCandlesRequest) Cusip(cusip string) ApiGetTimeSeriesSuperTrendHeikinAshiCandlesRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesSuperTrendHeikinAshiCandlesRequest) Outputsize(outputsize int64) ApiGetTimeSeriesSuperTrendHeikinAshiCandlesRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesSuperTrendHeikinAshiCandlesRequest) Exchange(exchange string) ApiGetTimeSeriesSuperTrendHeikinAshiCandlesRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesSuperTrendHeikinAshiCandlesRequest) MicCode(micCode string) ApiGetTimeSeriesSuperTrendHeikinAshiCandlesRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesSuperTrendHeikinAshiCandlesRequest) Country(country string) ApiGetTimeSeriesSuperTrendHeikinAshiCandlesRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesSuperTrendHeikinAshiCandlesRequest) Type_(type_ string) ApiGetTimeSeriesSuperTrendHeikinAshiCandlesRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesSuperTrendHeikinAshiCandlesRequest) Timezone(timezone string) ApiGetTimeSeriesSuperTrendHeikinAshiCandlesRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesSuperTrendHeikinAshiCandlesRequest) StartDate(startDate string) ApiGetTimeSeriesSuperTrendHeikinAshiCandlesRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesSuperTrendHeikinAshiCandlesRequest) EndDate(endDate string) ApiGetTimeSeriesSuperTrendHeikinAshiCandlesRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesSuperTrendHeikinAshiCandlesRequest) Date(date string) ApiGetTimeSeriesSuperTrendHeikinAshiCandlesRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesSuperTrendHeikinAshiCandlesRequest) Order(order string) ApiGetTimeSeriesSuperTrendHeikinAshiCandlesRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesSuperTrendHeikinAshiCandlesRequest) Prepost(prepost bool) ApiGetTimeSeriesSuperTrendHeikinAshiCandlesRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesSuperTrendHeikinAshiCandlesRequest) Format(format string) ApiGetTimeSeriesSuperTrendHeikinAshiCandlesRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesSuperTrendHeikinAshiCandlesRequest) Delimiter(delimiter string) ApiGetTimeSeriesSuperTrendHeikinAshiCandlesRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesSuperTrendHeikinAshiCandlesRequest) Dp(dp int64) ApiGetTimeSeriesSuperTrendHeikinAshiCandlesRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesSuperTrendHeikinAshiCandlesRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesSuperTrendHeikinAshiCandlesRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesSuperTrendHeikinAshiCandlesRequest) Adjust(adjust string) ApiGetTimeSeriesSuperTrendHeikinAshiCandlesRequest {
	r.adjust = &adjust
	return r
}

// The period used for calculation in the indicator. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesSuperTrendHeikinAshiCandlesRequest) Period(period int64) ApiGetTimeSeriesSuperTrendHeikinAshiCandlesRequest {
	r.period = &period
	return r
}

// The factor used to adjust the indicator&#39;s sensitivity.
func (r ApiGetTimeSeriesSuperTrendHeikinAshiCandlesRequest) Multiplier(multiplier int64) ApiGetTimeSeriesSuperTrendHeikinAshiCandlesRequest {
	r.multiplier = &multiplier
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesSuperTrendHeikinAshiCandlesRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesSuperTrendHeikinAshiCandlesRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesSuperTrendHeikinAshiCandlesRequest) Execute() (*GetTimeSeriesSuperTrendHeikinAshiCandles200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesSuperTrendHeikinAshiCandlesExecute(r)
}

/*
GetTimeSeriesSuperTrendHeikinAshiCandles Supertrend Heikin Ashi candles

The Supertrend Heikin Ashi candles endpoint provides data combining Supertrend signals with Heikin Ashi candlestick patterns. It returns a series of data points indicating trend direction and smoothed price movements, useful for identifying potential buy or sell opportunities in trading.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesSuperTrendHeikinAshiCandlesRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesSuperTrendHeikinAshiCandles(ctx context.Context) ApiGetTimeSeriesSuperTrendHeikinAshiCandlesRequest {
	return ApiGetTimeSeriesSuperTrendHeikinAshiCandlesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesSuperTrendHeikinAshiCandles200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesSuperTrendHeikinAshiCandlesExecute(r ApiGetTimeSeriesSuperTrendHeikinAshiCandlesRequest) (*GetTimeSeriesSuperTrendHeikinAshiCandles200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesSuperTrendHeikinAshiCandles200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesSuperTrendHeikinAshiCandles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/supertrend_heikinashicandles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.period != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "period", r.period, "form", "")
	} else {
        var defaultValue int64 = 10
        parameterAddToHeaderOrQuery(localVarQueryParams, "period", defaultValue, "form", "")
        r.period = &defaultValue
	}
	if r.multiplier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "multiplier", r.multiplier, "form", "")
	} else {
        var defaultValue int64 = 3
        parameterAddToHeaderOrQuery(localVarQueryParams, "multiplier", defaultValue, "form", "")
        r.multiplier = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesT3maRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	seriesType *string
	timePeriod *int64
	vFactor *float64
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesT3maRequest) Interval(interval string) ApiGetTimeSeriesT3maRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesT3maRequest) Symbol(symbol string) ApiGetTimeSeriesT3maRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesT3maRequest) Isin(isin string) ApiGetTimeSeriesT3maRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesT3maRequest) Figi(figi string) ApiGetTimeSeriesT3maRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesT3maRequest) Cusip(cusip string) ApiGetTimeSeriesT3maRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesT3maRequest) Outputsize(outputsize int64) ApiGetTimeSeriesT3maRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesT3maRequest) Exchange(exchange string) ApiGetTimeSeriesT3maRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesT3maRequest) MicCode(micCode string) ApiGetTimeSeriesT3maRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesT3maRequest) Country(country string) ApiGetTimeSeriesT3maRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesT3maRequest) Type_(type_ string) ApiGetTimeSeriesT3maRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesT3maRequest) Timezone(timezone string) ApiGetTimeSeriesT3maRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesT3maRequest) StartDate(startDate string) ApiGetTimeSeriesT3maRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesT3maRequest) EndDate(endDate string) ApiGetTimeSeriesT3maRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesT3maRequest) Date(date string) ApiGetTimeSeriesT3maRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesT3maRequest) Order(order string) ApiGetTimeSeriesT3maRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesT3maRequest) Prepost(prepost bool) ApiGetTimeSeriesT3maRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesT3maRequest) Format(format string) ApiGetTimeSeriesT3maRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesT3maRequest) Delimiter(delimiter string) ApiGetTimeSeriesT3maRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesT3maRequest) Dp(dp int64) ApiGetTimeSeriesT3maRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesT3maRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesT3maRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesT3maRequest) Adjust(adjust string) ApiGetTimeSeriesT3maRequest {
	r.adjust = &adjust
	return r
}

// Price type on which technical indicator is calculated
func (r ApiGetTimeSeriesT3maRequest) SeriesType(seriesType string) ApiGetTimeSeriesT3maRequest {
	r.seriesType = &seriesType
	return r
}

// Number of periods to average over. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesT3maRequest) TimePeriod(timePeriod int64) ApiGetTimeSeriesT3maRequest {
	r.timePeriod = &timePeriod
	return r
}

// The factor used to adjust the indicator&#39;s volatility. Takes values in the range from &#x60;0&#x60; to &#x60;1&#x60;
func (r ApiGetTimeSeriesT3maRequest) VFactor(vFactor float64) ApiGetTimeSeriesT3maRequest {
	r.vFactor = &vFactor
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesT3maRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesT3maRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesT3maRequest) Execute() (*GetTimeSeriesT3ma200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesT3maExecute(r)
}

/*
GetTimeSeriesT3ma Triple exponential moving average

The Triple Exponential Moving Average (T3MA) endpoint calculates a smoothed moving average using three exponential moving averages on price data. It returns a dataset that highlights price trends with reduced lag, offering precise trend analysis. This is useful for identifying trend direction and potential reversal points.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesT3maRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesT3ma(ctx context.Context) ApiGetTimeSeriesT3maRequest {
	return ApiGetTimeSeriesT3maRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesT3ma200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesT3maExecute(r ApiGetTimeSeriesT3maRequest) (*GetTimeSeriesT3ma200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesT3ma200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesT3ma")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/t3ma"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.seriesType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", r.seriesType, "form", "")
	} else {
        var defaultValue string = "close"
        parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", defaultValue, "form", "")
        r.seriesType = &defaultValue
	}
	if r.timePeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", r.timePeriod, "form", "")
	} else {
        var defaultValue int64 = 9
        parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", defaultValue, "form", "")
        r.timePeriod = &defaultValue
	}
	if r.vFactor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "v_factor", r.vFactor, "form", "")
	} else {
        var defaultValue float64 = 0.7
        parameterAddToHeaderOrQuery(localVarQueryParams, "v_factor", defaultValue, "form", "")
        r.vFactor = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesTRangeRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesTRangeRequest) Interval(interval string) ApiGetTimeSeriesTRangeRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesTRangeRequest) Symbol(symbol string) ApiGetTimeSeriesTRangeRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesTRangeRequest) Isin(isin string) ApiGetTimeSeriesTRangeRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesTRangeRequest) Figi(figi string) ApiGetTimeSeriesTRangeRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesTRangeRequest) Cusip(cusip string) ApiGetTimeSeriesTRangeRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesTRangeRequest) Outputsize(outputsize int64) ApiGetTimeSeriesTRangeRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesTRangeRequest) Exchange(exchange string) ApiGetTimeSeriesTRangeRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesTRangeRequest) MicCode(micCode string) ApiGetTimeSeriesTRangeRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesTRangeRequest) Country(country string) ApiGetTimeSeriesTRangeRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesTRangeRequest) Type_(type_ string) ApiGetTimeSeriesTRangeRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesTRangeRequest) Timezone(timezone string) ApiGetTimeSeriesTRangeRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesTRangeRequest) StartDate(startDate string) ApiGetTimeSeriesTRangeRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesTRangeRequest) EndDate(endDate string) ApiGetTimeSeriesTRangeRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesTRangeRequest) Date(date string) ApiGetTimeSeriesTRangeRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesTRangeRequest) Order(order string) ApiGetTimeSeriesTRangeRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesTRangeRequest) Prepost(prepost bool) ApiGetTimeSeriesTRangeRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesTRangeRequest) Format(format string) ApiGetTimeSeriesTRangeRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesTRangeRequest) Delimiter(delimiter string) ApiGetTimeSeriesTRangeRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesTRangeRequest) Dp(dp int64) ApiGetTimeSeriesTRangeRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesTRangeRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesTRangeRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesTRangeRequest) Adjust(adjust string) ApiGetTimeSeriesTRangeRequest {
	r.adjust = &adjust
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesTRangeRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesTRangeRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesTRangeRequest) Execute() (*GetTimeSeriesTRange200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesTRangeExecute(r)
}

/*
GetTimeSeriesTRange True range

The True Range (TRANGE) endpoint calculates the range of price movement for a specified period, providing a measure of market volatility. It returns data that includes the highest and lowest prices over the period, along with the closing price from the previous period. This information is useful for traders to assess market volatility and adjust their trading strategies accordingly.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesTRangeRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesTRange(ctx context.Context) ApiGetTimeSeriesTRangeRequest {
	return ApiGetTimeSeriesTRangeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesTRange200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesTRangeExecute(r ApiGetTimeSeriesTRangeRequest) (*GetTimeSeriesTRange200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesTRange200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesTRange")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/trange"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesTemaRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	seriesType *string
	timePeriod *int64
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesTemaRequest) Interval(interval string) ApiGetTimeSeriesTemaRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesTemaRequest) Symbol(symbol string) ApiGetTimeSeriesTemaRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesTemaRequest) Isin(isin string) ApiGetTimeSeriesTemaRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesTemaRequest) Figi(figi string) ApiGetTimeSeriesTemaRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesTemaRequest) Cusip(cusip string) ApiGetTimeSeriesTemaRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesTemaRequest) Outputsize(outputsize int64) ApiGetTimeSeriesTemaRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesTemaRequest) Exchange(exchange string) ApiGetTimeSeriesTemaRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesTemaRequest) MicCode(micCode string) ApiGetTimeSeriesTemaRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesTemaRequest) Country(country string) ApiGetTimeSeriesTemaRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesTemaRequest) Type_(type_ string) ApiGetTimeSeriesTemaRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesTemaRequest) Timezone(timezone string) ApiGetTimeSeriesTemaRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesTemaRequest) StartDate(startDate string) ApiGetTimeSeriesTemaRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesTemaRequest) EndDate(endDate string) ApiGetTimeSeriesTemaRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesTemaRequest) Date(date string) ApiGetTimeSeriesTemaRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesTemaRequest) Order(order string) ApiGetTimeSeriesTemaRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesTemaRequest) Prepost(prepost bool) ApiGetTimeSeriesTemaRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesTemaRequest) Format(format string) ApiGetTimeSeriesTemaRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesTemaRequest) Delimiter(delimiter string) ApiGetTimeSeriesTemaRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesTemaRequest) Dp(dp int64) ApiGetTimeSeriesTemaRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesTemaRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesTemaRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesTemaRequest) Adjust(adjust string) ApiGetTimeSeriesTemaRequest {
	r.adjust = &adjust
	return r
}

// Price type on which technical indicator is calculated
func (r ApiGetTimeSeriesTemaRequest) SeriesType(seriesType string) ApiGetTimeSeriesTemaRequest {
	r.seriesType = &seriesType
	return r
}

// The time period used for calculation in the indicator. Default is 9.
func (r ApiGetTimeSeriesTemaRequest) TimePeriod(timePeriod int64) ApiGetTimeSeriesTemaRequest {
	r.timePeriod = &timePeriod
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesTemaRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesTemaRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesTemaRequest) Execute() (*GetTimeSeriesTema200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesTemaExecute(r)
}

/*
GetTimeSeriesTema Triple exponential moving average

The Triple Exponential Moving Average (TEMA) endpoint calculates and returns the TEMA values for a specified financial instrument over a given time period. This endpoint provides a series of data points that smooth out price fluctuations by applying three layers of exponential moving averages, allowing users to identify and track underlying trends in the instrument's price movement.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesTemaRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesTema(ctx context.Context) ApiGetTimeSeriesTemaRequest {
	return ApiGetTimeSeriesTemaRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesTema200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesTemaExecute(r ApiGetTimeSeriesTemaRequest) (*GetTimeSeriesTema200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesTema200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesTema")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tema"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.seriesType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", r.seriesType, "form", "")
	} else {
        var defaultValue string = "close"
        parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", defaultValue, "form", "")
        r.seriesType = &defaultValue
	}
	if r.timePeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", r.timePeriod, "form", "")
	} else {
        var defaultValue int64 = 9
        parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", defaultValue, "form", "")
        r.timePeriod = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesTrimaRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	seriesType *string
	timePeriod *int64
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesTrimaRequest) Interval(interval string) ApiGetTimeSeriesTrimaRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesTrimaRequest) Symbol(symbol string) ApiGetTimeSeriesTrimaRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesTrimaRequest) Isin(isin string) ApiGetTimeSeriesTrimaRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesTrimaRequest) Figi(figi string) ApiGetTimeSeriesTrimaRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesTrimaRequest) Cusip(cusip string) ApiGetTimeSeriesTrimaRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesTrimaRequest) Outputsize(outputsize int64) ApiGetTimeSeriesTrimaRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesTrimaRequest) Exchange(exchange string) ApiGetTimeSeriesTrimaRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesTrimaRequest) MicCode(micCode string) ApiGetTimeSeriesTrimaRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesTrimaRequest) Country(country string) ApiGetTimeSeriesTrimaRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesTrimaRequest) Type_(type_ string) ApiGetTimeSeriesTrimaRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesTrimaRequest) Timezone(timezone string) ApiGetTimeSeriesTrimaRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesTrimaRequest) StartDate(startDate string) ApiGetTimeSeriesTrimaRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesTrimaRequest) EndDate(endDate string) ApiGetTimeSeriesTrimaRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesTrimaRequest) Date(date string) ApiGetTimeSeriesTrimaRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesTrimaRequest) Order(order string) ApiGetTimeSeriesTrimaRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesTrimaRequest) Prepost(prepost bool) ApiGetTimeSeriesTrimaRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesTrimaRequest) Format(format string) ApiGetTimeSeriesTrimaRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesTrimaRequest) Delimiter(delimiter string) ApiGetTimeSeriesTrimaRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesTrimaRequest) Dp(dp int64) ApiGetTimeSeriesTrimaRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesTrimaRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesTrimaRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesTrimaRequest) Adjust(adjust string) ApiGetTimeSeriesTrimaRequest {
	r.adjust = &adjust
	return r
}

// Price type on which technical indicator is calculated
func (r ApiGetTimeSeriesTrimaRequest) SeriesType(seriesType string) ApiGetTimeSeriesTrimaRequest {
	r.seriesType = &seriesType
	return r
}

// Number of periods to average over. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesTrimaRequest) TimePeriod(timePeriod int64) ApiGetTimeSeriesTrimaRequest {
	r.timePeriod = &timePeriod
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesTrimaRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesTrimaRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesTrimaRequest) Execute() (*GetTimeSeriesTrima200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesTrimaExecute(r)
}

/*
GetTimeSeriesTrima Triangular moving average

The Triangular Moving Average (TRIMA) endpoint calculates and returns the smoothed average price of a financial security over a specified period, with a focus on central data points. This endpoint provides a balanced view of price trends by applying a double smoothing process, making it useful for identifying underlying price patterns and reducing short-term fluctuations.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesTrimaRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesTrima(ctx context.Context) ApiGetTimeSeriesTrimaRequest {
	return ApiGetTimeSeriesTrimaRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesTrima200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesTrimaExecute(r ApiGetTimeSeriesTrimaRequest) (*GetTimeSeriesTrima200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesTrima200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesTrima")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/trima"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.seriesType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", r.seriesType, "form", "")
	} else {
        var defaultValue string = "close"
        parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", defaultValue, "form", "")
        r.seriesType = &defaultValue
	}
	if r.timePeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", r.timePeriod, "form", "")
	} else {
        var defaultValue int64 = 9
        parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", defaultValue, "form", "")
        r.timePeriod = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesTsfRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	seriesType *string
	timePeriod *int64
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesTsfRequest) Interval(interval string) ApiGetTimeSeriesTsfRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesTsfRequest) Symbol(symbol string) ApiGetTimeSeriesTsfRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesTsfRequest) Isin(isin string) ApiGetTimeSeriesTsfRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesTsfRequest) Figi(figi string) ApiGetTimeSeriesTsfRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesTsfRequest) Cusip(cusip string) ApiGetTimeSeriesTsfRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesTsfRequest) Outputsize(outputsize int64) ApiGetTimeSeriesTsfRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesTsfRequest) Exchange(exchange string) ApiGetTimeSeriesTsfRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesTsfRequest) MicCode(micCode string) ApiGetTimeSeriesTsfRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesTsfRequest) Country(country string) ApiGetTimeSeriesTsfRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesTsfRequest) Type_(type_ string) ApiGetTimeSeriesTsfRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesTsfRequest) Timezone(timezone string) ApiGetTimeSeriesTsfRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesTsfRequest) StartDate(startDate string) ApiGetTimeSeriesTsfRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesTsfRequest) EndDate(endDate string) ApiGetTimeSeriesTsfRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesTsfRequest) Date(date string) ApiGetTimeSeriesTsfRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesTsfRequest) Order(order string) ApiGetTimeSeriesTsfRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesTsfRequest) Prepost(prepost bool) ApiGetTimeSeriesTsfRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesTsfRequest) Format(format string) ApiGetTimeSeriesTsfRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesTsfRequest) Delimiter(delimiter string) ApiGetTimeSeriesTsfRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesTsfRequest) Dp(dp int64) ApiGetTimeSeriesTsfRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesTsfRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesTsfRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesTsfRequest) Adjust(adjust string) ApiGetTimeSeriesTsfRequest {
	r.adjust = &adjust
	return r
}

// Price type on which technical indicator is calculated
func (r ApiGetTimeSeriesTsfRequest) SeriesType(seriesType string) ApiGetTimeSeriesTsfRequest {
	r.seriesType = &seriesType
	return r
}

// Number of periods to average over. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesTsfRequest) TimePeriod(timePeriod int64) ApiGetTimeSeriesTsfRequest {
	r.timePeriod = &timePeriod
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesTsfRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesTsfRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesTsfRequest) Execute() (*GetTimeSeriesTsf200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesTsfExecute(r)
}

/*
GetTimeSeriesTsf Time series forecast

The Time Series Forecast (TSF) endpoint provides projected future price levels using linear regression analysis. It returns data that helps users identify potential support and resistance levels, as well as trend direction in a financial market. This endpoint is useful for traders seeking to anticipate price movements and adjust their strategies accordingly.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesTsfRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesTsf(ctx context.Context) ApiGetTimeSeriesTsfRequest {
	return ApiGetTimeSeriesTsfRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesTsf200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesTsfExecute(r ApiGetTimeSeriesTsfRequest) (*GetTimeSeriesTsf200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesTsf200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesTsf")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tsf"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.seriesType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", r.seriesType, "form", "")
	} else {
        var defaultValue string = "close"
        parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", defaultValue, "form", "")
        r.seriesType = &defaultValue
	}
	if r.timePeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", r.timePeriod, "form", "")
	} else {
        var defaultValue int64 = 9
        parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", defaultValue, "form", "")
        r.timePeriod = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesTypPriceRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesTypPriceRequest) Interval(interval string) ApiGetTimeSeriesTypPriceRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesTypPriceRequest) Symbol(symbol string) ApiGetTimeSeriesTypPriceRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesTypPriceRequest) Isin(isin string) ApiGetTimeSeriesTypPriceRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesTypPriceRequest) Figi(figi string) ApiGetTimeSeriesTypPriceRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesTypPriceRequest) Cusip(cusip string) ApiGetTimeSeriesTypPriceRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesTypPriceRequest) Outputsize(outputsize int64) ApiGetTimeSeriesTypPriceRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesTypPriceRequest) Exchange(exchange string) ApiGetTimeSeriesTypPriceRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesTypPriceRequest) MicCode(micCode string) ApiGetTimeSeriesTypPriceRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesTypPriceRequest) Country(country string) ApiGetTimeSeriesTypPriceRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesTypPriceRequest) Type_(type_ string) ApiGetTimeSeriesTypPriceRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesTypPriceRequest) Timezone(timezone string) ApiGetTimeSeriesTypPriceRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesTypPriceRequest) StartDate(startDate string) ApiGetTimeSeriesTypPriceRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesTypPriceRequest) EndDate(endDate string) ApiGetTimeSeriesTypPriceRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesTypPriceRequest) Date(date string) ApiGetTimeSeriesTypPriceRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesTypPriceRequest) Order(order string) ApiGetTimeSeriesTypPriceRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesTypPriceRequest) Prepost(prepost bool) ApiGetTimeSeriesTypPriceRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesTypPriceRequest) Format(format string) ApiGetTimeSeriesTypPriceRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesTypPriceRequest) Delimiter(delimiter string) ApiGetTimeSeriesTypPriceRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesTypPriceRequest) Dp(dp int64) ApiGetTimeSeriesTypPriceRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesTypPriceRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesTypPriceRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesTypPriceRequest) Adjust(adjust string) ApiGetTimeSeriesTypPriceRequest {
	r.adjust = &adjust
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesTypPriceRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesTypPriceRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesTypPriceRequest) Execute() (*GetTimeSeriesTypPrice200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesTypPriceExecute(r)
}

/*
GetTimeSeriesTypPrice Typical price

The Typical Price (TYPPRICE) endpoint calculates and returns the average of a financial instrument's high, low, and close prices for a given period. This endpoint provides a simplified metric that reflects the central tendency of price movements, useful for traders and analysts who need a straightforward view of price trends.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesTypPriceRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesTypPrice(ctx context.Context) ApiGetTimeSeriesTypPriceRequest {
	return ApiGetTimeSeriesTypPriceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesTypPrice200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesTypPriceExecute(r ApiGetTimeSeriesTypPriceRequest) (*GetTimeSeriesTypPrice200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesTypPrice200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesTypPrice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/typprice"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesUltOscRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	timePeriod1 *int64
	timePeriod2 *int64
	timePeriod3 *int64
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesUltOscRequest) Interval(interval string) ApiGetTimeSeriesUltOscRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesUltOscRequest) Symbol(symbol string) ApiGetTimeSeriesUltOscRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesUltOscRequest) Isin(isin string) ApiGetTimeSeriesUltOscRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesUltOscRequest) Figi(figi string) ApiGetTimeSeriesUltOscRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesUltOscRequest) Cusip(cusip string) ApiGetTimeSeriesUltOscRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesUltOscRequest) Outputsize(outputsize int64) ApiGetTimeSeriesUltOscRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesUltOscRequest) Exchange(exchange string) ApiGetTimeSeriesUltOscRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesUltOscRequest) MicCode(micCode string) ApiGetTimeSeriesUltOscRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesUltOscRequest) Country(country string) ApiGetTimeSeriesUltOscRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesUltOscRequest) Type_(type_ string) ApiGetTimeSeriesUltOscRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesUltOscRequest) Timezone(timezone string) ApiGetTimeSeriesUltOscRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesUltOscRequest) StartDate(startDate string) ApiGetTimeSeriesUltOscRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesUltOscRequest) EndDate(endDate string) ApiGetTimeSeriesUltOscRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesUltOscRequest) Date(date string) ApiGetTimeSeriesUltOscRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesUltOscRequest) Order(order string) ApiGetTimeSeriesUltOscRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesUltOscRequest) Prepost(prepost bool) ApiGetTimeSeriesUltOscRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesUltOscRequest) Format(format string) ApiGetTimeSeriesUltOscRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesUltOscRequest) Delimiter(delimiter string) ApiGetTimeSeriesUltOscRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesUltOscRequest) Dp(dp int64) ApiGetTimeSeriesUltOscRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesUltOscRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesUltOscRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesUltOscRequest) Adjust(adjust string) ApiGetTimeSeriesUltOscRequest {
	r.adjust = &adjust
	return r
}

// The first time period used for calculation in the indicator. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesUltOscRequest) TimePeriod1(timePeriod1 int64) ApiGetTimeSeriesUltOscRequest {
	r.timePeriod1 = &timePeriod1
	return r
}

// The second time period used for calculation in the indicator. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesUltOscRequest) TimePeriod2(timePeriod2 int64) ApiGetTimeSeriesUltOscRequest {
	r.timePeriod2 = &timePeriod2
	return r
}

// The third time period used for calculation in the indicator. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesUltOscRequest) TimePeriod3(timePeriod3 int64) ApiGetTimeSeriesUltOscRequest {
	r.timePeriod3 = &timePeriod3
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesUltOscRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesUltOscRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesUltOscRequest) Execute() (*GetTimeSeriesUltOsc200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesUltOscExecute(r)
}

/*
GetTimeSeriesUltOsc Ultimate oscillator endpoint

The Ultimate Oscillator endpoint (/ultosc) calculates a momentum oscillator that integrates short, intermediate, and long-term price movements to detect potential overbought or oversold conditions and possible trend reversals. It returns a time series of oscillator values, which can be used to assess market momentum and identify entry or exit points in trading strategies.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesUltOscRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesUltOsc(ctx context.Context) ApiGetTimeSeriesUltOscRequest {
	return ApiGetTimeSeriesUltOscRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesUltOsc200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesUltOscExecute(r ApiGetTimeSeriesUltOscRequest) (*GetTimeSeriesUltOsc200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesUltOsc200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesUltOsc")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ultosc"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.timePeriod1 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_period_1", r.timePeriod1, "form", "")
	} else {
        var defaultValue int64 = 7
        parameterAddToHeaderOrQuery(localVarQueryParams, "time_period_1", defaultValue, "form", "")
        r.timePeriod1 = &defaultValue
	}
	if r.timePeriod2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_period_2", r.timePeriod2, "form", "")
	} else {
        var defaultValue int64 = 14
        parameterAddToHeaderOrQuery(localVarQueryParams, "time_period_2", defaultValue, "form", "")
        r.timePeriod2 = &defaultValue
	}
	if r.timePeriod3 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_period_3", r.timePeriod3, "form", "")
	} else {
        var defaultValue int64 = 28
        parameterAddToHeaderOrQuery(localVarQueryParams, "time_period_3", defaultValue, "form", "")
        r.timePeriod3 = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesVarRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	seriesType *string
	timePeriod *int64
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesVarRequest) Interval(interval string) ApiGetTimeSeriesVarRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesVarRequest) Symbol(symbol string) ApiGetTimeSeriesVarRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesVarRequest) Isin(isin string) ApiGetTimeSeriesVarRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesVarRequest) Figi(figi string) ApiGetTimeSeriesVarRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesVarRequest) Cusip(cusip string) ApiGetTimeSeriesVarRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesVarRequest) Outputsize(outputsize int64) ApiGetTimeSeriesVarRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesVarRequest) Exchange(exchange string) ApiGetTimeSeriesVarRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesVarRequest) MicCode(micCode string) ApiGetTimeSeriesVarRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesVarRequest) Country(country string) ApiGetTimeSeriesVarRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesVarRequest) Type_(type_ string) ApiGetTimeSeriesVarRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesVarRequest) Timezone(timezone string) ApiGetTimeSeriesVarRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesVarRequest) StartDate(startDate string) ApiGetTimeSeriesVarRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesVarRequest) EndDate(endDate string) ApiGetTimeSeriesVarRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesVarRequest) Date(date string) ApiGetTimeSeriesVarRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesVarRequest) Order(order string) ApiGetTimeSeriesVarRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesVarRequest) Prepost(prepost bool) ApiGetTimeSeriesVarRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesVarRequest) Format(format string) ApiGetTimeSeriesVarRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesVarRequest) Delimiter(delimiter string) ApiGetTimeSeriesVarRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesVarRequest) Dp(dp int64) ApiGetTimeSeriesVarRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesVarRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesVarRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesVarRequest) Adjust(adjust string) ApiGetTimeSeriesVarRequest {
	r.adjust = &adjust
	return r
}

// Price type on which technical indicator is calculated
func (r ApiGetTimeSeriesVarRequest) SeriesType(seriesType string) ApiGetTimeSeriesVarRequest {
	r.seriesType = &seriesType
	return r
}

// Number of periods to average over. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesVarRequest) TimePeriod(timePeriod int64) ApiGetTimeSeriesVarRequest {
	r.timePeriod = &timePeriod
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesVarRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesVarRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesVarRequest) Execute() (*GetTimeSeriesVar200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesVarExecute(r)
}

/*
GetTimeSeriesVar Variance

The Variance (VAR) endpoint calculates the statistical variance of a financial data series, providing a measure of how much the data points deviate from the average value. It returns a numerical value representing this dispersion, which can be used to assess the volatility of a security over a specified period. This information is crucial for traders and analysts who need to evaluate the risk associated with price fluctuations in the market.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesVarRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesVar(ctx context.Context) ApiGetTimeSeriesVarRequest {
	return ApiGetTimeSeriesVarRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesVar200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesVarExecute(r ApiGetTimeSeriesVarRequest) (*GetTimeSeriesVar200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesVar200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesVar")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/var"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.seriesType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", r.seriesType, "form", "")
	} else {
        var defaultValue string = "close"
        parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", defaultValue, "form", "")
        r.seriesType = &defaultValue
	}
	if r.timePeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", r.timePeriod, "form", "")
	} else {
        var defaultValue int64 = 9
        parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", defaultValue, "form", "")
        r.timePeriod = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesVwapRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	sdTimePeriod *int64
	sd *float64
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesVwapRequest) Interval(interval string) ApiGetTimeSeriesVwapRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesVwapRequest) Symbol(symbol string) ApiGetTimeSeriesVwapRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesVwapRequest) Isin(isin string) ApiGetTimeSeriesVwapRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesVwapRequest) Figi(figi string) ApiGetTimeSeriesVwapRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesVwapRequest) Cusip(cusip string) ApiGetTimeSeriesVwapRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesVwapRequest) Outputsize(outputsize int64) ApiGetTimeSeriesVwapRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesVwapRequest) Exchange(exchange string) ApiGetTimeSeriesVwapRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesVwapRequest) MicCode(micCode string) ApiGetTimeSeriesVwapRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesVwapRequest) Country(country string) ApiGetTimeSeriesVwapRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesVwapRequest) Type_(type_ string) ApiGetTimeSeriesVwapRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesVwapRequest) Timezone(timezone string) ApiGetTimeSeriesVwapRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesVwapRequest) StartDate(startDate string) ApiGetTimeSeriesVwapRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesVwapRequest) EndDate(endDate string) ApiGetTimeSeriesVwapRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesVwapRequest) Date(date string) ApiGetTimeSeriesVwapRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesVwapRequest) Order(order string) ApiGetTimeSeriesVwapRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesVwapRequest) Prepost(prepost bool) ApiGetTimeSeriesVwapRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesVwapRequest) Format(format string) ApiGetTimeSeriesVwapRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesVwapRequest) Delimiter(delimiter string) ApiGetTimeSeriesVwapRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesVwapRequest) Dp(dp int64) ApiGetTimeSeriesVwapRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesVwapRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesVwapRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesVwapRequest) Adjust(adjust string) ApiGetTimeSeriesVwapRequest {
	r.adjust = &adjust
	return r
}

// The time period for the standard deviation calculation. Must be greater than &#x60;0&#x60;. Recommended value is &#x60;9&#x60;. This parameter is only used together with &#x60;sd&#x60;.
func (r ApiGetTimeSeriesVwapRequest) SdTimePeriod(sdTimePeriod int64) ApiGetTimeSeriesVwapRequest {
	r.sdTimePeriod = &sdTimePeriod
	return r
}

// The standard deviation applied in the calculation. Must be greater than &#x60;0&#x60;. Recommended value is &#x60;2&#x60;. This parameter is only used together with &#x60;sd_time_period&#x60;.
func (r ApiGetTimeSeriesVwapRequest) Sd(sd float64) ApiGetTimeSeriesVwapRequest {
	r.sd = &sd
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesVwapRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesVwapRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesVwapRequest) Execute() (*GetTimeSeriesVwap200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesVwapExecute(r)
}

/*
GetTimeSeriesVwap Volume weighted average price

The Volume Weighted Average Price (VWAP) endpoint provides the VWAP value for a specified stock or asset over a given time period. This indicator calculates the average price at which a security has traded throughout the day, based on both volume and price. It is useful for identifying the true average price of an asset, helping traders to assess the current price relative to the day's average.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesVwapRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesVwap(ctx context.Context) ApiGetTimeSeriesVwapRequest {
	return ApiGetTimeSeriesVwapRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesVwap200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesVwapExecute(r ApiGetTimeSeriesVwapRequest) (*GetTimeSeriesVwap200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesVwap200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesVwap")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vwap"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.sdTimePeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sd_time_period", r.sdTimePeriod, "form", "")
	} else {
        var defaultValue int64 = 0
        parameterAddToHeaderOrQuery(localVarQueryParams, "sd_time_period", defaultValue, "form", "")
        r.sdTimePeriod = &defaultValue
	}
	if r.sd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sd", r.sd, "form", "")
	} else {
        var defaultValue float64 = 0
        parameterAddToHeaderOrQuery(localVarQueryParams, "sd", defaultValue, "form", "")
        r.sd = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesWclPriceRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesWclPriceRequest) Interval(interval string) ApiGetTimeSeriesWclPriceRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesWclPriceRequest) Symbol(symbol string) ApiGetTimeSeriesWclPriceRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesWclPriceRequest) Isin(isin string) ApiGetTimeSeriesWclPriceRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesWclPriceRequest) Figi(figi string) ApiGetTimeSeriesWclPriceRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesWclPriceRequest) Cusip(cusip string) ApiGetTimeSeriesWclPriceRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesWclPriceRequest) Outputsize(outputsize int64) ApiGetTimeSeriesWclPriceRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesWclPriceRequest) Exchange(exchange string) ApiGetTimeSeriesWclPriceRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesWclPriceRequest) MicCode(micCode string) ApiGetTimeSeriesWclPriceRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesWclPriceRequest) Country(country string) ApiGetTimeSeriesWclPriceRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesWclPriceRequest) Type_(type_ string) ApiGetTimeSeriesWclPriceRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesWclPriceRequest) Timezone(timezone string) ApiGetTimeSeriesWclPriceRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesWclPriceRequest) StartDate(startDate string) ApiGetTimeSeriesWclPriceRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesWclPriceRequest) EndDate(endDate string) ApiGetTimeSeriesWclPriceRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesWclPriceRequest) Date(date string) ApiGetTimeSeriesWclPriceRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesWclPriceRequest) Order(order string) ApiGetTimeSeriesWclPriceRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesWclPriceRequest) Prepost(prepost bool) ApiGetTimeSeriesWclPriceRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesWclPriceRequest) Format(format string) ApiGetTimeSeriesWclPriceRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesWclPriceRequest) Delimiter(delimiter string) ApiGetTimeSeriesWclPriceRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesWclPriceRequest) Dp(dp int64) ApiGetTimeSeriesWclPriceRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesWclPriceRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesWclPriceRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesWclPriceRequest) Adjust(adjust string) ApiGetTimeSeriesWclPriceRequest {
	r.adjust = &adjust
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesWclPriceRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesWclPriceRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesWclPriceRequest) Execute() (*GetTimeSeriesWclPrice200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesWclPriceExecute(r)
}

/*
GetTimeSeriesWclPrice Weighted close price

The Weighted Close Price (WCLPRICE) endpoint calculates a security's average price by giving additional weight to the closing price, using the formula: (High + Low + Close * 2) / 4.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesWclPriceRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesWclPrice(ctx context.Context) ApiGetTimeSeriesWclPriceRequest {
	return ApiGetTimeSeriesWclPriceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesWclPrice200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesWclPriceExecute(r ApiGetTimeSeriesWclPriceRequest) (*GetTimeSeriesWclPrice200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesWclPrice200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesWclPrice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wclprice"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesWillRRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	timePeriod *int64
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesWillRRequest) Interval(interval string) ApiGetTimeSeriesWillRRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesWillRRequest) Symbol(symbol string) ApiGetTimeSeriesWillRRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesWillRRequest) Isin(isin string) ApiGetTimeSeriesWillRRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesWillRRequest) Figi(figi string) ApiGetTimeSeriesWillRRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesWillRRequest) Cusip(cusip string) ApiGetTimeSeriesWillRRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesWillRRequest) Outputsize(outputsize int64) ApiGetTimeSeriesWillRRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesWillRRequest) Exchange(exchange string) ApiGetTimeSeriesWillRRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesWillRRequest) MicCode(micCode string) ApiGetTimeSeriesWillRRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesWillRRequest) Country(country string) ApiGetTimeSeriesWillRRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesWillRRequest) Type_(type_ string) ApiGetTimeSeriesWillRRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesWillRRequest) Timezone(timezone string) ApiGetTimeSeriesWillRRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesWillRRequest) StartDate(startDate string) ApiGetTimeSeriesWillRRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesWillRRequest) EndDate(endDate string) ApiGetTimeSeriesWillRRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesWillRRequest) Date(date string) ApiGetTimeSeriesWillRRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesWillRRequest) Order(order string) ApiGetTimeSeriesWillRRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesWillRRequest) Prepost(prepost bool) ApiGetTimeSeriesWillRRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesWillRRequest) Format(format string) ApiGetTimeSeriesWillRRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesWillRRequest) Delimiter(delimiter string) ApiGetTimeSeriesWillRRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesWillRRequest) Dp(dp int64) ApiGetTimeSeriesWillRRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesWillRRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesWillRRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesWillRRequest) Adjust(adjust string) ApiGetTimeSeriesWillRRequest {
	r.adjust = &adjust
	return r
}

// Number of periods to average over. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesWillRRequest) TimePeriod(timePeriod int64) ApiGetTimeSeriesWillRRequest {
	r.timePeriod = &timePeriod
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesWillRRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesWillRRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesWillRRequest) Execute() (*GetTimeSeriesWillR200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesWillRExecute(r)
}

/*
GetTimeSeriesWillR Williams %R

The Williams %R (WILLR) endpoint calculates the Williams Percent Range, a momentum indicator that evaluates a security's closing price relative to its high-low range over a specified period. This endpoint returns data that helps users identify potential overbought or oversold conditions and possible trend reversals in the market.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesWillRRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesWillR(ctx context.Context) ApiGetTimeSeriesWillRRequest {
	return ApiGetTimeSeriesWillRRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesWillR200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesWillRExecute(r ApiGetTimeSeriesWillRRequest) (*GetTimeSeriesWillR200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesWillR200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesWillR")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/willr"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.timePeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", r.timePeriod, "form", "")
	} else {
        var defaultValue int64 = 14
        parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", defaultValue, "form", "")
        r.timePeriod = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesWmaRequest struct {
	ctx context.Context
	ApiService *TechnicalIndicatorAPIService
	interval *string
	symbol *string
	isin *string
	figi *string
	cusip *string
	outputsize *int64
	exchange *string
	micCode *string
	country *string
	type_ *string
	timezone *string
	startDate *string
	endDate *string
	date *string
	order *string
	prepost *bool
	format *string
	delimiter *string
	dp *int64
	previousClose *bool
	adjust *string
	seriesType *string
	timePeriod *int64
	includeOhlc *bool
}

// Interval between two consecutive points in time series
func (r ApiGetTimeSeriesWmaRequest) Interval(interval string) ApiGetTimeSeriesWmaRequest {
	r.interval = &interval
	return r
}

// Symbol ticker of the instrument. E.g. &#x60;AAPL&#x60;, &#x60;EUR/USD&#x60;, &#x60;ETH/BTC&#x60;, ...
func (r ApiGetTimeSeriesWmaRequest) Symbol(symbol string) ApiGetTimeSeriesWmaRequest {
	r.symbol = &symbol
	return r
}

// Filter by international securities identification number (ISIN)
func (r ApiGetTimeSeriesWmaRequest) Isin(isin string) ApiGetTimeSeriesWmaRequest {
	r.isin = &isin
	return r
}

// The FIGI of an instrument for which data is requested
func (r ApiGetTimeSeriesWmaRequest) Figi(figi string) ApiGetTimeSeriesWmaRequest {
	r.figi = &figi
	return r
}

// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the &lt;a href&#x3D;\&quot;https://twelvedata.com/account/add-ons\&quot;&gt;Add-ons&lt;/a&gt; section
func (r ApiGetTimeSeriesWmaRequest) Cusip(cusip string) ApiGetTimeSeriesWmaRequest {
	r.cusip = &cusip
	return r
}

// Number of data points to retrieve. Supports values in the range from &#x60;1&#x60; to &#x60;5000&#x60;. Default &#x60;30&#x60; when no date parameters are set, otherwise set to maximum
func (r ApiGetTimeSeriesWmaRequest) Outputsize(outputsize int64) ApiGetTimeSeriesWmaRequest {
	r.outputsize = &outputsize
	return r
}

// Exchange where instrument is traded
func (r ApiGetTimeSeriesWmaRequest) Exchange(exchange string) ApiGetTimeSeriesWmaRequest {
	r.exchange = &exchange
	return r
}

// Market Identifier Code (MIC) under ISO 10383 standard
func (r ApiGetTimeSeriesWmaRequest) MicCode(micCode string) ApiGetTimeSeriesWmaRequest {
	r.micCode = &micCode
	return r
}

// The country where the instrument is traded, e.g., &#x60;United States&#x60; or &#x60;US&#x60;
func (r ApiGetTimeSeriesWmaRequest) Country(country string) ApiGetTimeSeriesWmaRequest {
	r.country = &country
	return r
}

// The asset class to which the instrument belongs
func (r ApiGetTimeSeriesWmaRequest) Type_(type_ string) ApiGetTimeSeriesWmaRequest {
	r.type_ = &type_
	return r
}

// Timezone at which output datetime will be displayed. Supports: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;Exchange&lt;/code&gt; for local exchange time&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;UTC&lt;/code&gt; for datetime at universal UTC standard&lt;/li&gt; &lt;li&gt;3. Timezone name according to the IANA Time Zone Database. E.g. &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Asia/Singapore&lt;/code&gt;. Full list of timezones can be found &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\&quot; target&#x3D;\&quot;blank\&quot;&gt;here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;i&gt;Take note that the IANA Timezone name is case-sensitive&lt;/i&gt;
func (r ApiGetTimeSeriesWmaRequest) Timezone(timezone string) ApiGetTimeSeriesWmaRequest {
	r.timezone = &timezone
	return r
}

// Can be used separately and together with &#x60;end_date&#x60;. Format &#x60;2006-01-02&#x60; or &#x60;2006-01-02T15:04:05&#x60;  Default location: &lt;ul&gt; &lt;li&gt;Forex and Cryptocurrencies - &lt;code&gt;UTC&lt;/code&gt;&lt;/li&gt; &lt;li&gt;Stocks - where exchange is located (e.g. for AAPL it will be &lt;code&gt;America/New_York&lt;/code&gt;)&lt;/li&gt; &lt;/ul&gt; Both parameters take into account if &lt;code&gt;timezone&lt;/code&gt; parameter is provided.&lt;br/&gt; If &lt;code&gt;timezone&lt;/code&gt; is given then, &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; will be used in the specified location  Examples: &lt;ul&gt; &lt;li&gt;1. &lt;code&gt;&amp;symbol&#x3D;AAPL&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 New York time up to current date&lt;/li&gt; &lt;li&gt;2. &lt;code&gt;&amp;symbol&#x3D;EUR/USD&amp;timezone&#x3D;Asia/Singapore&amp;start_date&#x3D;2019-08-09T15:50:00&amp;…&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date&lt;/li&gt; &lt;li&gt;3. &lt;code&gt;&amp;symbol&#x3D;ETH/BTC&amp;timezone&#x3D;Europe/Zurich&amp;start_date&#x3D;2019-08-09T15:50:00&amp;end_date&#x3D;2019-08-09T15:55:00&amp;...&lt;/code&gt;&lt;br/&gt; Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00&lt;/li&gt; &lt;/ul&gt;
func (r ApiGetTimeSeriesWmaRequest) StartDate(startDate string) ApiGetTimeSeriesWmaRequest {
	r.startDate = &startDate
	return r
}

// The ending date and time for data selection, see &#x60;start_date&#x60; description for details.
func (r ApiGetTimeSeriesWmaRequest) EndDate(endDate string) ApiGetTimeSeriesWmaRequest {
	r.endDate = &endDate
	return r
}

// Specifies the exact date to get the data for. Could be the exact date, e.g. &#x60;2021-10-27&#x60;, or in human language &#x60;today&#x60; or &#x60;yesterday&#x60;
func (r ApiGetTimeSeriesWmaRequest) Date(date string) ApiGetTimeSeriesWmaRequest {
	r.date = &date
	return r
}

// Sorting order of the output
func (r ApiGetTimeSeriesWmaRequest) Order(order string) ApiGetTimeSeriesWmaRequest {
	r.order = &order
	return r
}

// Returns quotes that include pre-market and post-market data. Only for &#x60;Pro&#x60; and above plans. Available at the &#x60;1min&#x60;, &#x60;5min&#x60;, &#x60;15min&#x60;, and &#x60;30min&#x60; intervals for US equities. Open, high, low, close values are supplied without volume
func (r ApiGetTimeSeriesWmaRequest) Prepost(prepost bool) ApiGetTimeSeriesWmaRequest {
	r.prepost = &prepost
	return r
}

// The format of the response data
func (r ApiGetTimeSeriesWmaRequest) Format(format string) ApiGetTimeSeriesWmaRequest {
	r.format = &format
	return r
}

// The separator used in the CSV response data
func (r ApiGetTimeSeriesWmaRequest) Delimiter(delimiter string) ApiGetTimeSeriesWmaRequest {
	r.delimiter = &delimiter
	return r
}

// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
func (r ApiGetTimeSeriesWmaRequest) Dp(dp int64) ApiGetTimeSeriesWmaRequest {
	r.dp = &dp
	return r
}

// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
func (r ApiGetTimeSeriesWmaRequest) PreviousClose(previousClose bool) ApiGetTimeSeriesWmaRequest {
	r.previousClose = &previousClose
	return r
}

// Adjusting mode for prices
func (r ApiGetTimeSeriesWmaRequest) Adjust(adjust string) ApiGetTimeSeriesWmaRequest {
	r.adjust = &adjust
	return r
}

// Price type on which technical indicator is calculated
func (r ApiGetTimeSeriesWmaRequest) SeriesType(seriesType string) ApiGetTimeSeriesWmaRequest {
	r.seriesType = &seriesType
	return r
}

// Number of periods to average over. Takes values in the range from &#x60;1&#x60; to &#x60;800&#x60;
func (r ApiGetTimeSeriesWmaRequest) TimePeriod(timePeriod int64) ApiGetTimeSeriesWmaRequest {
	r.timePeriod = &timePeriod
	return r
}

// Specify if OHLC values should be added in the output
func (r ApiGetTimeSeriesWmaRequest) IncludeOhlc(includeOhlc bool) ApiGetTimeSeriesWmaRequest {
	r.includeOhlc = &includeOhlc
	return r
}

func (r ApiGetTimeSeriesWmaRequest) Execute() (*GetTimeSeriesWma200Response, *http.Response, error) {
	return r.ApiService.GetTimeSeriesWmaExecute(r)
}

/*
GetTimeSeriesWma Weighted moving average

The Weighted Moving Average (WMA) endpoint calculates and returns the WMA values for a given security over a specified period. This endpoint provides a time series of weighted averages, where recent prices have a higher influence, allowing users to track and analyze short-term price trends effectively.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesWmaRequest
*/
func (a *TechnicalIndicatorAPIService) GetTimeSeriesWma(ctx context.Context) ApiGetTimeSeriesWmaRequest {
	return ApiGetTimeSeriesWmaRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeSeriesWma200Response
func (a *TechnicalIndicatorAPIService) GetTimeSeriesWmaExecute(r ApiGetTimeSeriesWmaRequest) (*GetTimeSeriesWma200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeSeriesWma200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechnicalIndicatorAPIService.GetTimeSeriesWma")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wma"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	}
	if r.isin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isin", r.isin, "form", "")
	}
	if r.figi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "figi", r.figi, "form", "")
	}
	if r.cusip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cusip", r.cusip, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.outputsize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", r.outputsize, "form", "")
	} else {
        var defaultValue int64 = 30
        parameterAddToHeaderOrQuery(localVarQueryParams, "outputsize", defaultValue, "form", "")
        r.outputsize = &defaultValue
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "form", "")
	}
	if r.micCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mic_code", r.micCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
        var defaultValue string = "Exchange"
        parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
        r.timezone = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.prepost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", r.prepost, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "prepost", defaultValue, "form", "")
        r.prepost = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "JSON"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "form", "")
	} else {
        var defaultValue string = ";"
        parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", defaultValue, "form", "")
        r.delimiter = &defaultValue
	}
	if r.dp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp", r.dp, "form", "")
	} else {
        var defaultValue int64 = -1
        parameterAddToHeaderOrQuery(localVarQueryParams, "dp", defaultValue, "form", "")
        r.dp = &defaultValue
	}
	if r.previousClose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", r.previousClose, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "previous_close", defaultValue, "form", "")
        r.previousClose = &defaultValue
	}
	if r.adjust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", r.adjust, "form", "")
	} else {
        var defaultValue string = "splits"
        parameterAddToHeaderOrQuery(localVarQueryParams, "adjust", defaultValue, "form", "")
        r.adjust = &defaultValue
	}
	if r.seriesType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", r.seriesType, "form", "")
	} else {
        var defaultValue string = "close"
        parameterAddToHeaderOrQuery(localVarQueryParams, "series_type", defaultValue, "form", "")
        r.seriesType = &defaultValue
	}
	if r.timePeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", r.timePeriod, "form", "")
	} else {
        var defaultValue int64 = 9
        parameterAddToHeaderOrQuery(localVarQueryParams, "time_period", defaultValue, "form", "")
        r.timePeriod = &defaultValue
	}
	if r.includeOhlc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", r.includeOhlc, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_ohlc", defaultValue, "form", "")
        r.includeOhlc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authorizationHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["queryParameter"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
